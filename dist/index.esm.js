import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import React, { useState, forwardRef, useRef, useImperativeHandle, useCallback, useEffect, useMemo, memo, useLayoutEffect } from 'react';
import toast, { Toaster } from 'react-hot-toast';

/**
 * Color Design Tokens
 * 브랜드 아이덴티티와 UI 의미 전달을 위한 컬러 시스템
 */
// All colors export
var colors = {
  primary: {
    /** 브랜드 아이덴티티를 대표하는 메인 컬러 */
    mainviolet: '#7248D9',
    /** 중립적인 컬러 - Typography 및 넓은 영역 Fill에 사용 */
    gray: {
      900: '#171717',
      800: '#292929',
      700: '#595959',
      600: '#7A7A7A',
      500: '#999999',
      400: '#B8B8B8',
      300: '#D6D6D6',
      200: '#EBEBEB',
      100: '#F5F5F5',
      black: '#000000',
      white: '#FFFFFF'
    },
    /** 넓은 영역에서 Fill로 사용 가능한 중립 색상 계열 */
    coolGray: {
      900: '#151719',
      800: '#25282D',
      700: '#393F46',
      600: '#505862',
      500: '#6E7887',
      400: '#8D97A5',
      300: '#AFB6C0',
      200: '#D1D5DB',
      100: '#E8EAED',
      50: '#F3F5F6'
    },
    /** 메인 컬러보다는 덜 강조되지만, 일러스트 및 보조 정보 강조에 사용 */
    tint: {
      violet: {
        700: '#4B1FA3',
        600: '#5B27C4',
        500: '#7248D9',
        400: '#8B6EE4',
        300: '#A88FEA',
        200: '#C8B7F4',
        100: '#E5DEF9',
        50: '#F8F4FE'
      },
      blue: {
        700: '#0038B8',
        600: '#004AF5',
        500: '#2F6EFF',
        400: '#5C92FF',
        300: '#8FB4FF',
        200: '#C2D6FF',
        100: '#E0EBFF',
        50: '#F0F5FF'
      },
      red: {
        700: '#C70000',
        600: '#E51A1A',
        500: '#FF2E2E',
        400: '#FF6666',
        300: '#FF9494',
        200: '#FFC2C2',
        100: '#FFE0E0',
        50: '#FFF0F0'
      },
      yellow: {
        700: '#F59B00',
        600: '#FFB200',
        500: '#FFCC00',
        400: '#FFDA47',
        300: '#FFE785',
        200: '#FFF1B8',
        100: '#FFF7D6',
        50: '#FFFAE5'
      },
      green: {
        700: '#00996B',
        600: '#00AD74',
        500: '#00C785',
        400: '#55DD99',
        300: '#88E7B8',
        200: '#BBF2D2',
        100: '#DDF8E6',
        50: '#F0FFF5'
      }
    }
  },
  /** 텍스트, 상태, 배경, 보더, 비활성, Dim 등 UI 의미 전달용 컬러셋 */
  semantic: {
    text: {
      /** 콘텐츠에서 가장 중요한 정보를 전달할 때 사용 */
      primary: '#25282D',
      /** 주요 정보 외의 부가적인 내용을 전달할 때 사용 */
      secondary: '#505862',
      /** 시각적 우선순위가 낮은 텍스트에 사용 */
      tertiary: '#8D97A5',
      /** 상호작용이 불가능하거나 비활성화된 상태의 텍스트에 사용 */
      disabled: '#D1D5DB',
      /** 어두운 배경 위에 사용되는 밝은 텍스트 컬러 */
      inverse: '#FFFFFF'
    },
    state: {
      /** 작업 완료, 저장 성공 등 긍정적인 상태를 나타냄 */
      success: '#00C785',
      /** 주의가 필요한 상황이나 경고 메시지를 전달할 때 사용 */
      warning: '#FFCC00',
      /** 오류 상태나 실패 메시지를 표시할 때 사용 */
      error: '#FF2E2E',
      /** 보조적인 정보나 안내 메시지를 전달할 때 사용 */
      info: '#2F6EFF'
    },
    background: {
      /** 기본 페이지 또는 레이아웃의 배경으로 사용 */
      primary: '#FFFFFF',
      /** Primary 배경과 대비를 주어 시각적 계층을 형성할 때 사용 */
      secondary: '#E8EAED'
    },
    border: {
      /** 강조보다는 미묘한 구분을 목적으로 하며, 디바이더 역할까지 겸함 */
      default: '#EBEBEB',
      /** 콘텐츠 간의 명확한 구획이 필요할 때 사용하는 보더 컬러 */
      strong: '#D6D6D6'
    },
    disabled: {
      /** 텍스트 또는 아이콘이 비활성 상태임을 나타낼 때 사용 */
      foreground: '#D1D5DB',
      /** 버튼, 입력 필드 등 UI가 비활성화된 배경으로 사용 */
      background: '#F3F5F6'
    },
    dim: {
      /** 모달, 드롭다운 등 레이어 위에 표시되는 오버레이 배경 */
      overlay: '#000000B3'
    }
  },
  /** 의료 플랫폼 특성을 반영해 피부, 머리카락, 장기 표현용 컬러 */
  illustration: {
    skin: {
      /** 피부 표현 시 밝은 톤으로 사용 */
      light: '#FFEBE1',
      /** 피부 기본 톤을 표현할 때 사용 */
      base: '#FFDAC4',
      /** 피부 음영 표현용 컬러 */
      shadow: '#FFCBB7',
      /** 피부 깊은 음영이나 입체감을 줄 때 사용 */
      deepshadow: '#F8B29C'
    },
    hair: {
      /** 머리카락 하이라이트 표현용 컬러 */
      light: '#706965',
      /** 머리카락 기본 색상을 표현할 때 사용 */
      base: '#37322F',
      /** 머리카락 음영 및 입체감 표현용 컬러 */
      shadow: '#1A1716'
    },
    organ: {
      /** 긍정적 상태나 특정 장기 강조용 컬러 */
      light: '#FFB5B5',
      /** 장기 표현 시 기본 색상으로 사용 */
      base: '#FF8F8F',
      /** 장기 음영 표현용 컬러 */
      shadow: '#FB7474',
      /** 장기 깊은 음영이나 강조를 위해 사용 */
      deepshadow: '#CD5151'
    }
  }
};
// 하위 호환성을 위한 개별 export (deprecated)
/** @deprecated colors.primary 사용을 권장합니다 */
var primary = colors.primary.mainviolet;
/** @deprecated colors.primary.gray 사용을 권장합니다 */
var gray = colors.primary.gray;
/** @deprecated colors.primary.coolGray 사용을 권장합니다 */
var coolGray = colors.primary.coolGray;
/** @deprecated colors.primary.tint 사용을 권장합니다 */
var tint = colors.primary.tint;
/** @deprecated colors.semantic 사용을 권장합니다 */
var semantic = colors.semantic;
/** @deprecated colors.illustration 사용을 권장합니다 */
var illustration = colors.illustration;

var colors$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    colors: colors,
    coolGray: coolGray,
    gray: gray,
    illustration: illustration,
    primary: primary,
    semantic: semantic,
    tint: tint
});

/**
 * Typography Design Tokens
 * 서비스와 사용자가 커뮤니케이션하는 주요 요소
 */
// Font Family
var fontFamily = {
  /** 웹사이트에 사용되는 모든 폰트는 Pretendard를 기반으로 함 */
  primary: 'Pretendard'
};
// Font Sizes (rem 단위로 반응형 지원)
var fontSize = {
  xxxxl: '2rem',
  // 32px
  xxxl: '1.75rem',
  // 28px
  xxl: '1.5rem',
  // 24px
  xl: '1.25rem',
  // 20px
  l: '1.125rem',
  // 18px
  m: '1rem',
  // 16px
  s: '0.875rem',
  // 14px
  xs: '0.75rem',
  // 12px
  xxs: '0.625rem',
  // 10px
  xxxs: '0.688rem' // 11px
};
// Font Weights
var fontWeight = {
  bold: 700,
  semibold: 600,
  medium: 500,
  regular: 400
};
// Line Heights
var lineHeight = {
  xxxxl: '42px',
  xxxl: '36px',
  xxl: '32px',
  xl: '28px',
  l: '24px',
  m: '24px',
  s: '22px',
  xs: '20px',
  xxs: '18px',
  xxxs: '17px'
};
// Letter Spacings
var letterSpacing = {
  m: '0',
  s: '-1%',
  xs: '-2%'
};
// Text Styles (React.CSSProperties 호환)
var textStyles = {
  /** 주목도를 높이고 큰 타이틀 영역 강조에 사용 */
  display1: {
    fontSize: fontSize.xxxxl,
    fontWeight: fontWeight.bold,
    lineHeight: lineHeight.xxxxl,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 중간 크기 타이틀에 사용 */
  display2: {
    fontSize: fontSize.xxxl,
    fontWeight: fontWeight.bold,
    lineHeight: lineHeight.xxxl,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 정보성 카드 타이틀에 주로 사용 */
  heading1: {
    fontSize: fontSize.xxl,
    fontWeight: fontWeight.bold,
    lineHeight: lineHeight.xxl,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 섹션 구분 타이틀 등에 사용 */
  heading2: {
    fontSize: fontSize.xl,
    fontWeight: fontWeight.semibold,
    lineHeight: lineHeight.xl,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 소제목 등에 사용 */
  heading3: {
    fontSize: fontSize.l,
    fontWeight: fontWeight.semibold,
    lineHeight: lineHeight.l,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 리스트 아이템, 버튼 텍스트 등에 사용 */
  heading4: {
    fontSize: fontSize.m,
    fontWeight: fontWeight.semibold,
    lineHeight: lineHeight.m,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 부가 정보, 캡션 등에 사용 */
  heading5: {
    fontSize: fontSize.s,
    fontWeight: fontWeight.semibold,
    lineHeight: lineHeight.s,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 주요 본문 텍스트에 사용 */
  body1: {
    fontSize: fontSize.m,
    fontWeight: fontWeight.regular,
    lineHeight: lineHeight.l,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 보조 본문 텍스트에 사용 */
  body2: {
    fontSize: fontSize.s,
    fontWeight: fontWeight.regular,
    lineHeight: lineHeight.s,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 본문 보조, 하위 위계 텍스트 쓰임새로 사용 권장 */
  body3: {
    fontSize: fontSize.xs,
    fontWeight: fontWeight.regular,
    lineHeight: lineHeight.xxs,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  },
  /** 보조 정보나 컴포넌트 레벨에서 사용 */
  caption: {
    fontSize: fontSize.xs,
    fontWeight: fontWeight.regular,
    lineHeight: lineHeight.xs,
    letterSpacing: letterSpacing.m,
    fontFamily: fontFamily.primary
  }
};
// All typography export
var typography = {
  fontFamily: fontFamily,
  fontSize: fontSize,
  fontWeight: fontWeight,
  lineHeight: lineHeight,
  letterSpacing: letterSpacing,
  textStyles: textStyles
};

var typography$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: typography,
    fontFamily: fontFamily,
    fontSize: fontSize,
    fontWeight: fontWeight,
    letterSpacing: letterSpacing,
    lineHeight: lineHeight,
    textStyles: textStyles,
    typography: typography
});

/**
 * Spacing Design Tokens
 * 균일한 요소와 간격을 사용하여 UI의 체계적인 배열을 도와줌
 * 4와 8의 배수에 기반한 스페이싱 시스템
 */
var spacing = {
  /** 2px - 최소 간격 */
  xxxs: '2px',
  /** 4px - 매우 작은 간격 */
  xxs: '4px',
  /** 8px - 작은 간격 */
  xs: '8px',
  /** 12px - 작은-중간 간격 */
  s: '12px',
  /** 16px - 기본 간격 */
  m: '16px',
  /** 20px - 중간-큰 간격 */
  l: '20px',
  /** 24px - 큰 간격 */
  xl: '24px',
  /** 32px - 매우 큰 간격 */
  xxl: '32px',
  /** 40px - 최대 간격 */
  xxxl: '40px'
};

var spacing$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: spacing,
    spacing: spacing
});

/**
 * Radius Design Tokens
 * UI 요소의 모서리를 둥글게 하여 부드러운 사용자 경험을 제공
 */
var radius = {
  /** 작은 버튼, 입력 필드, 체크박스에 최소한의 둥근 효과를 줄 때 사용 */
  xs: '4px',
  /** 카드, 드롭다운, 배너, 일반 버튼에 기본적인 둥근 스타일을 적용할 때 사용 */
  s: '8px',
  /** 중간 크기의 카드, 팝업, 모달에 부드러운 곡률을 적용할 때 사용 */
  m: '12px',
  /** 큰 모달, 프로필 이미지, 강조 영역에 둥근 효과를 줄 때 사용 */
  l: '16px',
  /** Hero Section과 같은 대형 UI 요소에 강한 둥근 효과를 적용할 때 사용 */
  xl: '20px',
  /** 아바타, 토글 버튼과 같은 완전한 원형 요소에 적용할 때 사용 */
  full: '50%'
};

var radius$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: radius,
    radius: radius
});

/**
 * Shadow Design Tokens
 * 그림자는 적용된 UI의 높이(elevation)와 이동 방향, 가장자리 등에 대한 단서를 제공
 */
var shadows = {
  /** 높이 48px 이하의 작은 요소에 가벼운 깊이감을 줄 때 사용 - 아이콘, 버튼, 배지, 입력 필드, 체크박스 등 */
  s: '0px 1px 8px rgba(0, 0, 0, 0.1)',
  /** 너비 또는 높이가 48px ~ 200px 사이의 중간 크기 요소를 명확히 구분할 때 사용 - 카드, 모달, 드롭다운, 중간 크기 버튼 등 */
  m: '0px 1px 16px rgba(0, 0, 0, 0.1)',
  /** 너비 200px 이상 또는 화면 너비의 50% 이상을 초과하는 큰 요소, 또는 강조가 필요한 구성 요소에 사용 - 다이얼로그, 대형 카드 등 */
  l: '0px 1px 24px rgba(0, 0, 0, 0.12)'
};

var shadows$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: shadows,
    shadows: shadows
});

/**
 * Border Design Tokens
 * 컴포넌트에 테두리를 추가하여 구분감을 제공하는 속성
 */
// Border Widths
var borderWidth = {
  /** UI 요소의 기본적인 구분감을 제공할 때 사용 */
  s: '1px',
  /** 1px보다 더 명확한 구분이 필요할 때 사용 */
  m: '1.5px',
  /** 중요한 요소를 강조하거나, 요소 간 강한 대비가 필요할 때 사용 */
  l: '2px'
};
// Border Styles
var borderStyle = {
  solid: 'solid',
  dashed: 'dashed',
  dotted: 'dotted',
  none: 'none'
};
// Combined Border Tokens
var border = {
  /** 기본 보더 - UI 요소의 기본적인 구분감 제공 */
  s: "".concat(borderWidth.s, " ").concat(borderStyle.solid),
  /** 중간 보더 - 더 명확한 구분이 필요할 때 */
  m: "".concat(borderWidth.m, " ").concat(borderStyle.solid),
  /** 큰 보더 - 중요한 요소 강조나 강한 대비가 필요할 때 */
  l: "".concat(borderWidth.l, " ").concat(borderStyle.solid),
  /** 보더 없음 */
  none: borderStyle.none
};
// All borders export
var borders = {
  borderWidth: borderWidth,
  borderStyle: borderStyle,
  border: border
};

var borders$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    border: border,
    borderStyle: borderStyle,
    borderWidth: borderWidth,
    borders: borders,
    default: borders
});

/**
 * Design Tokens Entry Point
 * 모든 디자인 토큰을 중앙에서 관리합니다
 */
// Individual token exports
// Combined tokens export
var tokens = {
  colors: function () {
    return Promise.resolve().then(function () { return colors$1; });
  },
  typography: function () {
    return Promise.resolve().then(function () { return typography$1; });
  },
  spacing: function () {
    return Promise.resolve().then(function () { return spacing$1; });
  },
  radius: function () {
    return Promise.resolve().then(function () { return radius$1; });
  },
  shadows: function () {
    return Promise.resolve().then(function () { return shadows$1; });
  },
  borders: function () {
    return Promise.resolve().then(function () { return borders$1; });
  }
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var LoadingIcon = function () {
  return jsx("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 50 50",
    className: "loading-icon",
    children: jsx("circle", {
      cx: "25",
      cy: "25",
      r: "20",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "4",
      strokeLinecap: "round"
    })
  });
};
var Button = function (_a) {
  var _b = _a.type,
    type = _b === void 0 ? 'solid' : _b,
    _c = _a.level,
    level = _c === void 0 ? 'CTA' : _c,
    _d = _a.size,
    size = _d === void 0 ? 'l' : _d,
    _e = _a.width,
    width = _e === void 0 ? '320px' : _e,
    _f = _a.disabled,
    disabled = _f === void 0 ? false : _f,
    icon = _a.icon,
    children = _a.children,
    onClick = _a.onClick,
    _g = _a.className,
    className = _g === void 0 ? '' : _g,
    _h = _a.isLoading,
    isLoading = _h === void 0 ? false : _h,
    _j = _a.underline,
    underline = _j === void 0 ? false : _j;
  var _k = useState(false),
    isHovered = _k[0],
    setIsHovered = _k[1];
  var _l = useState(false),
    isPressed = _l[0],
    setIsPressed = _l[1];
  // Size configurations
  var sizeConfig = {
    l: {
      paddingX: type === 'text' ? '12px' : '16px',
      paddingY: type === 'text' ? '0px' : '12px',
      borderRadius: type === 'text' ? '12px' : '12px',
      width: '320px',
      height: type === 'text' ? '32px' : '48px',
      fontSize: '16px',
      fontWeight: '500',
      iconSize: '20px'
    },
    m: {
      paddingX: type === 'text' ? '8px' : '12px',
      paddingY: type === 'text' ? '0px' : '8px',
      borderRadius: type === 'text' ? '12px' : '8px',
      width: '320px',
      height: type === 'text' ? '24px' : '40px',
      fontSize: '14px',
      fontWeight: '500',
      iconSize: '16px'
    },
    s: {
      paddingX: type === 'text' ? '8px' : '8px',
      paddingY: type === 'text' ? '0px' : '6px',
      borderRadius: type === 'text' ? '12px' : '4px',
      width: '320px',
      height: type === 'text' ? '20px' : '32px',
      fontSize: '12px',
      fontWeight: '500',
      iconSize: type === 'text' ? '14px' : '16px'
    }
  };
  var getStyles = function () {
    var config = sizeConfig[size];
    // width 동적 설정
    var getWidth = function () {
      if (width === 'fill') {
        return '100%';
      }
      return width;
    };
    var styles = {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: "".concat(config.paddingY, " ").concat(config.paddingX),
      borderRadius: config.borderRadius,
      width: getWidth(),
      height: config.height,
      border: type === 'text' ? 'none' : '1px solid transparent',
      cursor: disabled || isLoading ? 'not-allowed' : 'pointer',
      transition: 'all 0.2s ease',
      fontSize: config.fontSize,
      fontWeight: config.fontWeight,
      textDecoration: type === 'text' && underline ? 'underline' : 'none',
      background: 'none'
    };
    // Type별 스타일 적용
    if (type === 'solid') {
      styles = __assign(__assign({}, styles), getSolidStyles(level, disabled, isLoading, isPressed, isHovered));
    } else if (type === 'outlined') {
      styles = __assign(__assign({}, styles), getOutlinedStyles(disabled, isLoading, isPressed, isHovered));
    } else if (type === 'text') {
      styles = __assign(__assign({}, styles), getTextStyles(disabled));
    }
    return styles;
  };
  var getSolidStyles = function (level, disabled, isLoading, isPressed, isHovered) {
    if (disabled) {
      return {
        backgroundColor: colors.semantic.disabled.background,
        color: colors.semantic.disabled.foreground,
        border: "1px solid ".concat(colors.semantic.disabled.background)
      };
    }
    if (isLoading) {
      if (level === 'CTA') {
        return {
          backgroundColor: colors.primary.mainviolet,
          color: colors.semantic.background.primary,
          border: "1px solid ".concat(colors.primary.mainviolet)
        };
      } else if (level === 'secondary') {
        return {
          backgroundColor: colors.primary.tint.violet[200],
          color: colors.primary.mainviolet,
          border: "1px solid ".concat(colors.primary.tint.violet[200])
        };
      } else if (level === 'tertiary') {
        return {
          backgroundColor: colors.semantic.disabled.background,
          color: colors.semantic.text.primary,
          border: "1px solid ".concat(colors.semantic.disabled.background)
        };
      }
    }
    // Level별 색상 정의
    var levelColors = {
      CTA: {
        normal: {
          bg: colors.primary.mainviolet,
          text: colors.semantic.background.primary
        },
        hovered: {
          bg: colors.primary.tint.violet[600],
          text: colors.semantic.background.primary
        },
        pressed: {
          bg: colors.primary.tint.violet[700],
          text: colors.semantic.background.primary
        }
      },
      secondary: {
        normal: {
          bg: colors.primary.tint.violet[100],
          text: colors.primary.mainviolet
        },
        hovered: {
          bg: colors.primary.tint.violet[200],
          text: colors.primary.mainviolet
        },
        pressed: {
          bg: colors.primary.tint.violet[300],
          text: colors.primary.tint.violet[600]
        }
      },
      tertiary: {
        normal: {
          bg: colors.semantic.disabled.background,
          text: colors.semantic.text.primary
        },
        hovered: {
          bg: colors.primary.coolGray[100],
          text: colors.semantic.text.primary
        },
        pressed: {
          bg: colors.semantic.disabled.foreground,
          text: colors.semantic.text.primary
        }
      }
    };
    var currentLevel = levelColors[level];
    var currentState = currentLevel.normal;
    if (isPressed) {
      currentState = currentLevel.pressed;
    } else if (isHovered) {
      currentState = currentLevel.hovered;
    }
    return {
      backgroundColor: currentState.bg,
      color: currentState.text,
      border: "1px solid ".concat(currentState.bg)
    };
  };
  var getOutlinedStyles = function (disabled, isLoading, isPressed, isHovered) {
    if (disabled) {
      return {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.disabled.foreground,
        border: "1px solid ".concat(colors.semantic.disabled.foreground)
      };
    }
    if (isLoading) {
      return {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.text.primary,
        border: "1px solid ".concat(colors.semantic.border.strong)
      };
    }
    if (isPressed) {
      return {
        backgroundColor: colors.primary.coolGray[100],
        color: colors.semantic.text.primary,
        border: "1px solid ".concat(colors.semantic.border.strong)
      };
    } else if (isHovered) {
      return {
        backgroundColor: colors.semantic.disabled.background,
        color: colors.semantic.text.primary,
        border: "1px solid ".concat(colors.semantic.border.strong)
      };
    } else {
      return {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.text.primary,
        border: "1px solid ".concat(colors.semantic.border.strong)
      };
    }
  };
  var getTextStyles = function (disabled, isPressed, isHovered) {
    if (disabled) {
      return {
        color: colors.semantic.disabled.foreground,
        backgroundColor: 'transparent'
      };
    }
    // text 버튼은 배경색 변화 없이 텍스트 색상만 변경
    return {
      color: colors.semantic.text.primary,
      backgroundColor: 'transparent'
    };
  };
  var handleClick = function () {
    if (!disabled && !isLoading && onClick) {
      onClick();
    }
  };
  var handleMouseEnter = function () {
    if (!disabled && !isLoading) {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    setIsHovered(false);
    setIsPressed(false);
  };
  var handleMouseDown = function () {
    if (!disabled && !isLoading) {
      setIsPressed(true);
    }
  };
  var handleMouseUp = function () {
    setIsPressed(false);
  };
  var renderContent = function () {
    if (isLoading) {
      return jsx(LoadingIcon, {});
    }
    var config = sizeConfig[size];
    var iconStyle = {
      width: config.iconSize,
      height: config.iconSize,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    };
    return jsxs("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '4px'
      },
      children: [(icon === null || icon === void 0 ? void 0 : icon.left) && jsx("div", {
        style: iconStyle,
        children: icon.left
      }), children && jsx("span", {
        children: children
      }), (icon === null || icon === void 0 ? void 0 : icon.right) && jsx("div", {
        style: iconStyle,
        children: icon.right
      })]
    });
  };
  return jsx("button", {
    style: getStyles(),
    onClick: handleClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    disabled: disabled || isLoading,
    className: className,
    children: renderContent()
  });
};

var Font = function (_a) {
  var type = _a.type,
    fontWeight$1 = _a.fontWeight,
    _b = _a.color,
    color = _b === void 0 ? colors.semantic.text.primary : _b,
    hoverColor = _a.hoverColor,
    _c = _a.align,
    align = _c === void 0 ? 'left' : _c,
    whiteSpace = _a.whiteSpace,
    _d = _a.noWhiteSpace,
    noWhiteSpace = _d === void 0 ? false : _d,
    _e = _a.underline,
    underline = _e === void 0 ? false : _e,
    className = _a.className,
    style = _a.style,
    children = _a.children;
  var baseStyle = textStyles[type];
  var fontStyles = __assign(__assign(__assign(__assign({}, baseStyle), fontWeight$1 && {
    fontWeight: fontWeight[fontWeight$1]
  }), {
    color: color,
    textAlign: align,
    whiteSpace: noWhiteSpace ? 'nowrap' : whiteSpace || 'normal',
    wordBreak: 'keep-all',
    textOverflow: noWhiteSpace ? 'ellipsis' : undefined,
    overflow: noWhiteSpace ? 'hidden' : undefined,
    textDecoration: underline ? 'underline' : 'none',
    margin: 0,
    padding: 0,
    transition: 'color 0.2s ease'
  }), style);
  var handleMouseEnter = function (e) {
    if (hoverColor) {
      e.currentTarget.style.color = hoverColor;
    }
  };
  var handleMouseLeave = function (e) {
    if (hoverColor) {
      e.currentTarget.style.color = color;
    }
  };
  return jsx("span", {
    style: fontStyles,
    className: className,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    children: children
  });
};

var Lock = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6.5 6.5C6.5 3.46243 8.96243 1 12 1C15.0376 1 17.5 3.46243 17.5 6.5V8.5H18C19.6569 8.5 21 9.84315 21 11.5V20C21 21.6569 19.6569 23 18 23H6C4.34315 23 3 21.6569 3 20V11.5C3 9.84315 4.34315 8.5 6 8.5H6.5V6.5ZM9 8.5H15V6.5C15 4.84315 13.6569 3.5 12 3.5C10.3431 3.5 9 4.84315 9 6.5V8.5ZM11 14.5C11 13.9477 11.4477 13.5 12 13.5C12.5523 13.5 13 13.9477 13 14.5V17.5C13 18.0523 12.5523 18.5 12 18.5C11.4477 18.5 11 18.0523 11 17.5V14.5Z\" fill=\"#25282D\"/></svg>";
var New = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M15.2337 7.19995C15.786 7.19995 16.2337 7.64767 16.2337 8.19995V16.3812C16.2337 16.9335 15.786 17.3812 15.2337 17.3812H14.93C14.6016 17.3812 14.2942 17.22 14.1074 16.9499L9.93374 10.9125H9.84936V16.3812C9.84936 16.9335 9.40165 17.3812 8.84937 17.3812H8.73999C8.18771 17.3812 7.73999 16.9335 7.73999 16.3812V8.19995C7.73999 7.64767 8.18771 7.19995 8.73999 7.19995H9.06997C9.3994 7.19995 9.7077 7.3622 9.89422 7.63373L14.04 13.6687H14.1384V8.19995C14.1384 7.64767 14.5861 7.19995 15.1384 7.19995H15.2337Z\" fill=\"white\"/></svg>";
var Truncation = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"20.5\" r=\"1.5\" fill=\"#25282D\"/><circle cx=\"18.5\" cy=\"20.5\" r=\"1.5\" fill=\"#25282D\"/><circle cx=\"12\" cy=\"20.5\" r=\"1.5\" fill=\"#25282D\"/></svg>";
var add = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 3C12.5523 3 13 3.44772 13 4V11H20C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H13V20C13 20.5523 12.5523 21 12 21C11.4477 21 11 20.5523 11 20V13H4C3.44772 13 3 12.5523 3 12C3 11.4477 3.44772 11 4 11H11V4C11 3.44772 11.4477 3 12 3Z\" fill=\"#25282D\"/></svg>";
var addCircleFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 6.25C11.4477 6.25 11 6.69772 11 7.25V11H7.25C6.69771 11 6.25 11.4477 6.25 12C6.25 12.5523 6.69771 13 7.25 13H11V16.75C11 17.3023 11.4477 17.75 12 17.75C12.5523 17.75 13 17.3023 13 16.75V13H16.75C17.3023 13 17.75 12.5523 17.75 12C17.75 11.4477 17.3023 11 16.75 11H13V7.25C13 6.69772 12.5523 6.25 12 6.25Z\" fill=\"#25282D\"/></svg>";
var addCircleStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 6.25C12.5523 6.25 13 6.69772 13 7.25V11H16.75C17.3023 11 17.75 11.4477 17.75 12C17.75 12.5523 17.3023 13 16.75 13H13V16.75C13 17.3023 12.5523 17.75 12 17.75C11.4477 17.75 11 17.3023 11 16.75V13H7.25C6.69771 13 6.25 12.5523 6.25 12C6.25 11.4477 6.69771 11 7.25 11H11V7.25C11 6.69772 11.4477 6.25 12 6.25Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z\" fill=\"#25282D\"/></svg>";
var arrowDown = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.7071 15.7071C19.0976 15.3166 19.0976 14.6834 18.7071 14.2929C18.3166 13.9024 17.6834 13.9024 17.2929 14.2929L13 18.5858V3C13 2.44772 12.5523 2 12 2C11.4477 2 11 2.44772 11 3V18.5858L6.70711 14.2929C6.31658 13.9024 5.68342 13.9024 5.29289 14.2929C4.90237 14.6834 4.90237 15.3166 5.29289 15.7071L11.2929 21.7071C11.6834 22.0976 12.3166 22.0976 12.7071 21.7071L18.7071 15.7071Z\" fill=\"currentColor\"/></svg>";
var arrowLeft = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.29289 18.7071C8.68342 19.0976 9.31658 19.0976 9.70711 18.7071C10.0976 18.3166 10.0976 17.6834 9.70711 17.2929L5.41421 13H21C21.5523 13 22 12.5523 22 12C22 11.4477 21.5523 11 21 11H5.41421L9.70711 6.70711C10.0976 6.31658 10.0976 5.68342 9.70711 5.29289C9.31658 4.90237 8.68342 4.90237 8.29289 5.29289L2.29289 11.2929C1.90237 11.6834 1.90237 12.3166 2.29289 12.7071L8.29289 18.7071Z\" fill=\"currentColor\"/></svg>";
var arrowRight = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.7071 18.7071C15.3166 19.0976 14.6834 19.0976 14.2929 18.7071C13.9024 18.3166 13.9024 17.6834 14.2929 17.2929L18.5858 13H3C2.44772 13 2 12.5523 2 12C2 11.4477 2.44772 11 3 11H18.5858L14.2929 6.70711C13.9024 6.31658 13.9024 5.68342 14.2929 5.29289C14.6834 4.90237 15.3166 4.90237 15.7071 5.29289L21.7071 11.2929C22.0976 11.6834 22.0976 12.3166 21.7071 12.7071L15.7071 18.7071Z\" fill=\"currentColor\"/></svg>";
var arrowUp = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.7071 8.29289C19.0976 8.68342 19.0976 9.31658 18.7071 9.70711C18.3166 10.0976 17.6834 10.0976 17.2929 9.70711L13 5.41421V21C13 21.5523 12.5523 22 12 22C11.4477 22 11 21.5523 11 21V5.41421L6.70711 9.70711C6.31658 10.0976 5.68342 10.0976 5.29289 9.70711C4.90237 9.31658 4.90237 8.68342 5.29289 8.29289L11.2929 2.29289C11.6834 1.90237 12.3166 1.90237 12.7071 2.29289L18.7071 8.29289Z\" fill=\"currentColor\"/></svg>";
var bellFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M21.0025 15.2077L19.1006 13.3977V8.9377C19.1259 7.28152 18.5172 5.67261 17.3869 4.40803C16.2565 3.14346 14.6809 2.30863 12.951 2.0577C11.947 1.93256 10.9263 2.01151 9.95711 2.28927C8.9879 2.56703 8.09242 3.03722 7.33043 3.66846C6.56845 4.2997 5.95746 5.07747 5.53826 5.94989C5.11905 6.82231 4.90125 7.76931 4.89941 8.7277V13.3977L2.99746 15.2077C2.75856 15.4376 2.59655 15.729 2.53169 16.0455C2.46684 16.362 2.502 16.6896 2.63279 16.9873C2.76358 17.2851 2.9842 17.5397 3.26706 17.7194C3.54992 17.8991 3.88248 17.9959 4.22316 17.9977H7.77346V18.3377C7.82281 19.3529 8.29538 20.3082 9.08762 20.9942C9.87986 21.6803 10.9271 22.0411 12 21.9977C13.0729 22.0411 14.1201 21.6803 14.9124 20.9942C15.7046 20.3082 16.1772 19.3529 16.2265 18.3377V17.9977H19.7768C20.1175 17.9959 20.4501 17.8991 20.7329 17.7194C21.0158 17.5397 21.2364 17.2851 21.3672 16.9873C21.498 16.6896 21.5332 16.362 21.4683 16.0455C21.4034 15.729 21.2414 15.4376 21.0025 15.2077ZM14.1133 18.3377C14.0547 18.8187 13.8022 19.2598 13.4086 19.569C13.0149 19.8782 12.5103 20.0318 12 19.9977C11.4897 20.0318 10.9851 19.8782 10.5914 19.569C10.1978 19.2598 9.94533 18.8187 9.88673 18.3377V17.9977H14.1133V18.3377Z\" fill=\"#25282D\"/></svg>";
var bellStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.12602 19C8.04375 18.6804 8 18.3453 8 18V17H16V18C16 18.3453 15.9562 18.6804 15.874 19C15.4299 20.7252 13.8638 22 12 22C10.1362 22 8.57006 20.7252 8.12602 19ZM13.7324 19C13.3866 19.5978 12.7403 20 12 20C11.2597 20 10.6134 19.5978 10.2676 19H13.7324Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 4C8.67235 4 6 6.47621 6 10.7368V12.9131C6 14.3741 5.46807 15.7852 4.50363 16.8827C4.50332 16.8833 4.50287 16.8843 4.50238 16.8856C4.50157 16.8878 4.50091 16.8902 4.50048 16.8925C4.50006 16.8948 4.5 16.8964 4.5 16.897C4.5 16.9232 4.50957 16.9507 4.53375 16.9753C4.54527 16.9869 4.55602 16.9933 4.56302 16.9963C4.56846 16.9987 4.57354 17 4.58218 17H19.4033C19.4567 17 19.5 16.9567 19.5 16.9033C19.5 16.8806 19.4918 16.8582 19.4768 16.8404C18.5239 15.7199 18 14.2963 18 12.8248V10.6781C18 6.48554 15.3364 4 12 4ZM4 10.7368C4 5.5 7.44365 2 12 2C16.5564 2 20 5.5 20 10.6781V12.8248C20 13.8213 20.3548 14.7857 21.0004 15.5448C21.3228 15.924 21.5 16.4056 21.5 16.9033C21.5 18.0613 20.5613 19 19.4033 19H4.58218C3.43222 19 2.5 18.0469 2.5 16.897C2.5 16.4091 2.67775 15.9303 3 15.5639C3.6445 14.8313 4 13.8889 4 12.9131V10.7368Z\" fill=\"#25282D\"/></svg>";
var bookmarkFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18 1H6C4.34315 1 3 2.34315 3 4V21.4197C3 22.2925 3.70753 23 4.58032 23C4.85534 23 5.1256 22.9282 5.36438 22.7918L11.5039 19.2835C11.8113 19.1078 12.1887 19.1078 12.4961 19.2835L18.6356 22.7918C18.8744 22.9282 19.1447 23 19.4197 23C20.2925 23 21 22.2925 21 21.4197V4C21 2.34315 19.6569 1 18 1Z\" fill=\"#25282D\"/></svg>";
var bookmarkStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M18 3H6C5.44772 3 5 3.44772 5 4V20.6965L10.5116 17.547C11.4339 17.02 12.5661 17.02 13.4884 17.547L19 20.6965V4C19 3.44772 18.5523 3 18 3ZM6 1H18C19.6569 1 21 2.34315 21 4V21.4197C21 22.2925 20.2925 23 19.4197 23C19.1447 23 18.8744 22.9282 18.6356 22.7918L12.4961 19.2835C12.1887 19.1078 11.8113 19.1078 11.5039 19.2835L5.36438 22.7918C5.1256 22.9282 4.85534 23 4.58032 23C3.70753 23 3 22.2925 3 21.4197V4C3 2.34315 4.34315 1 6 1Z\" fill=\"#25282D\"/></svg>";
var calendarFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M22 19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V12H22V19ZM5.5 14C4.94772 14 4.5 14.4477 4.5 15V17C4.5 17.5523 4.94772 18 5.5 18H7.5C8.05228 18 8.5 17.5523 8.5 17V15C8.5 14.4477 8.05228 14 7.5 14H5.5ZM16 2C16.5523 2 17 2.44772 17 3V4H19C20.6569 4 22 5.34315 22 7V10H2V7C2 5.34315 3.34315 4 5 4H7V3C7 2.44772 7.44772 2 8 2C8.55228 2 9 2.44772 9 3V4H15V3C15 2.44772 15.4477 2 16 2Z\" fill=\"#000000\"/></svg>";
var calendar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 6H5C4.44772 6 4 6.44772 4 7V19C4 19.5523 4.44772 20 5 20H19C19.5523 20 20 19.5523 20 19V7C20 6.44772 19.5523 6 19 6ZM5 4H19C20.6569 4 22 5.34315 22 7V19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V7C2 5.34315 3.34315 4 5 4Z\" fill=\"#000000\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8 2C8.55228 2 9 2.44772 9 3V7C9 7.55228 8.55228 8 8 8C7.44772 8 7 7.55228 7 7V3C7 2.44772 7.44772 2 8 2Z\" fill=\"#000000\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16 2C16.5523 2 17 2.44772 17 3V7C17 7.55228 16.5523 8 16 8C15.4477 8 15 7.55228 15 7V3C15 2.44772 15.4477 2 16 2Z\" fill=\"#000000\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M2 11C2 10.4477 2.44772 10 3 10H21C21.5523 10 22 10.4477 22 11C22 11.5523 21.5523 12 21 12H3C2.44772 12 2 11.5523 2 11Z\" fill=\"#000000\"/></svg>";
var calendarStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 6H5C4.44772 6 4 6.44772 4 7V19C4 19.5523 4.44772 20 5 20H19C19.5523 20 20 19.5523 20 19V7C20 6.44772 19.5523 6 19 6ZM5 4H19C20.6569 4 22 5.34315 22 7V19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V7C2 5.34315 3.34315 4 5 4Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8 2C8.55228 2 9 2.44772 9 3V7C9 7.55228 8.55228 8 8 8C7.44772 8 7 7.55228 7 7V3C7 2.44772 7.44772 2 8 2Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16 2C16.5523 2 17 2.44772 17 3V7C17 7.55228 16.5523 8 16 8C15.4477 8 15 7.55228 15 7V3C15 2.44772 15.4477 2 16 2Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M2 11C2 10.4477 2.44772 10 3 10H21C21.5523 10 22 10.4477 22 11C22 11.5523 21.5523 12 21 12H3C2.44772 12 2 11.5523 2 11Z\" fill=\"#25282D\"/></svg>";
var callFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.61803 2H7.76985C8.52431 2 9.21456 2.42456 9.55485 3.09791L11.091 6.13762C11.5313 7.00875 11.2784 8.07041 10.4928 8.64957L9.24955 9.56604C9.1039 9.67341 9.05286 9.86792 9.12688 10.033C10.0913 12.1845 11.8139 13.9079 13.9654 14.8724C14.1313 14.9468 14.3265 14.8948 14.4335 14.7477L15.2711 13.596C15.8383 12.816 16.8814 12.552 17.7515 12.9681L20.8629 14.4562C21.5577 14.7885 22 15.4902 22 16.2604V19.382C22 19.7884 21.9054 20.1893 21.7236 20.5528C21.2801 21.4397 20.3736 22 19.382 22H19C10 22 2 14 2 5V4.61803C2 3.6264 2.56027 2.71987 3.44721 2.27639C3.81074 2.09463 4.2116 2 4.61803 2Z\" fill=\"#25282D\"/></svg>";
var callStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.76985 4H4.61803C4.52209 4 4.42746 4.02234 4.34164 4.06525C4.13226 4.16994 4 4.38394 4 4.61803V5C4 12.8954 11.1046 20 19 20H19.382C19.6161 20 19.8301 19.8677 19.9348 19.6584C19.9777 19.5725 20 19.4779 20 19.382V16.2604L16.8885 14.7724L16.0509 15.9241C15.3877 16.8361 14.1763 17.1587 13.1473 16.6974C10.5476 15.5321 8.46691 13.4501 7.30186 10.8511C6.84329 9.82818 7.15895 8.62248 8.06281 7.95618L9.30604 7.03971L7.76985 4ZM7.76985 2H4.61803C4.2116 2 3.81074 2.09463 3.44721 2.27639C2.56027 2.71987 2 3.6264 2 4.61803V5C2 14 10 22 19 22H19.382C20.3736 22 21.2801 21.4397 21.7236 20.5528C21.9054 20.1893 22 19.7884 22 19.382V16.2604C22 15.4902 21.5577 14.7885 20.8629 14.4562L17.7515 12.9681C16.8814 12.552 15.8383 12.816 15.2711 13.596L14.4335 14.7477C14.3265 14.8948 14.1313 14.9468 13.9654 14.8724C11.8139 13.9079 10.0913 12.1845 9.12688 10.033C9.05286 9.86792 9.1039 9.67341 9.24955 9.56604L10.4928 8.64957C11.2784 8.07041 11.5313 7.00875 11.091 6.13762L9.55485 3.09791C9.21456 2.42456 8.52431 2 7.76985 2Z\" fill=\"#25282D\"/></svg>";
var cameraFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6 6L6.67082 4.65836C7.179 3.64201 8.21779 3 9.3541 3H14.6459C15.7822 3 16.821 3.64201 17.3292 4.65836L18 6H20C21.6569 6 23 7.34315 23 9V18C23 19.6569 21.6569 21 20 21H4C2.34315 21 1 19.6569 1 18V9C1 7.34315 2.34315 6 4 6H6ZM12 17.5C14.2091 17.5 16 15.7091 16 13.5C16 11.2909 14.2091 9.5 12 9.5C9.79086 9.5 8 11.2909 8 13.5C8 15.7091 9.79086 17.5 12 17.5Z\" fill=\"#25282D\"/></svg>";
var cameraStorke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 15.5C13.3807 15.5 14.5 14.3807 14.5 13C14.5 11.6193 13.3807 10.5 12 10.5C10.6193 10.5 9.5 11.6193 9.5 13C9.5 14.3807 10.6193 15.5 12 15.5ZM12 17.5C14.4853 17.5 16.5 15.4853 16.5 13C16.5 10.5147 14.4853 8.5 12 8.5C9.51472 8.5 7.5 10.5147 7.5 13C7.5 15.4853 9.51472 17.5 12 17.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.78885 6.89443C7.45007 7.572 6.75754 8 6 8H4C3.44772 8 3 8.44772 3 9V18C3 18.5523 3.44772 19 4 19H20C20.5523 19 21 18.5523 21 18V9C21 8.44772 20.5523 8 20 8H18C17.2425 8 16.5499 7.572 16.2111 6.89443L15.5403 5.55279C15.3709 5.214 15.0247 5 14.6459 5H9.3541C8.97533 5 8.62907 5.214 8.45967 5.55279L7.78885 6.89443ZM18 6L17.3292 4.65836C16.821 3.64201 15.7822 3 14.6459 3H9.3541C8.21779 3 7.179 3.64201 6.67082 4.65836L6 6H4C2.34315 6 1 7.34315 1 9V18C1 19.6569 2.34315 21 4 21H20C21.6569 21 23 19.6569 23 18V9C23 7.34315 21.6569 6 20 6H18Z\" fill=\"#25282D\"/></svg>";
var cancelFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM16.0664 7.93359C15.6759 7.54317 15.0428 7.54318 14.6523 7.93359L12 10.585L9.34863 7.93359C8.95812 7.54328 8.32504 7.54321 7.93457 7.93359C7.54411 8.32406 7.54423 8.95712 7.93457 9.34766L10.5859 11.999L7.93457 14.6514C7.54425 15.0419 7.54418 15.675 7.93457 16.0654C8.32505 16.4557 8.95815 16.4557 9.34863 16.0654L12 13.4131L14.6523 16.0654C15.0429 16.4557 15.676 16.4559 16.0664 16.0654C16.4568 15.675 16.4567 15.0419 16.0664 14.6514L13.4141 11.999L16.0664 9.34766C16.4568 8.95718 16.4567 8.3241 16.0664 7.93359Z\" fill=\"#25282D\"/></svg>";
var cancelStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.0659 7.93388C16.4564 8.3244 16.4564 8.95757 16.0659 9.34809L13.4142 11.9997L16.0659 14.6514C16.4564 15.0419 16.4564 15.6751 16.0659 16.0656C15.6753 16.4561 15.0422 16.4561 14.6517 16.0656L12 13.414L9.34835 16.0656C8.95782 16.4561 8.32466 16.4561 7.93414 16.0656C7.54361 15.6751 7.54361 15.0419 7.93414 14.6514L10.5858 11.9997L7.93414 9.34809C7.54361 8.95757 7.54361 8.3244 7.93414 7.93388C8.32466 7.54335 8.95783 7.54335 9.34835 7.93388L12 10.5855L14.6517 7.93388C15.0422 7.54335 15.6753 7.54335 16.0659 7.93388Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z\" fill=\"#25282D\"/></svg>";
var cautionFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 15.25C11.3096 15.25 10.75 15.8096 10.75 16.5C10.75 17.1904 11.3096 17.75 12 17.75C12.6904 17.75 13.25 17.1904 13.25 16.5C13.25 15.8096 12.6904 15.25 12 15.25ZM12 6.25C11.4477 6.25 11 6.69772 11 7.25V13.25C11 13.8023 11.4477 14.25 12 14.25C12.5523 14.25 13 13.8023 13 13.25V7.25C13 6.69772 12.5523 6.25 12 6.25Z\" fill=\"#25282D\"/></svg>";
var cautionStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.75 16.5C10.75 15.8096 11.3096 15.25 12 15.25C12.6904 15.25 13.25 15.8096 13.25 16.5C13.25 17.1904 12.6904 17.75 12 17.75C11.3096 17.75 10.75 17.1904 10.75 16.5Z\" fill=\"#25282D\"/><path d=\"M12 6.25C11.4477 6.25 11 6.69772 11 7.25V13.25C11 13.8023 11.4477 14.25 12 14.25C12.5523 14.25 13 13.8023 13 13.25V7.25C13 6.69772 12.5523 6.25 12 6.25Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z\" fill=\"#25282D\"/></svg>";
var check = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M20.6585 5.24744C21.0742 5.61112 21.1163 6.24288 20.7526 6.65852L10.2526 18.6585C10.0638 18.8742 9.7916 18.9986 9.50497 19C9.21834 19.0014 8.94488 18.8798 8.754 18.666L3.254 12.5047C2.88622 12.0927 2.92206 11.4605 3.33407 11.0927C3.74608 10.7249 4.37823 10.7608 4.74602 11.1728L9.49252 16.49L19.2474 5.34151C19.6111 4.92587 20.2429 4.88375 20.6585 5.24744Z\" fill=\"#25282D\"/></svg>";
var checkCircleFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM17.1582 7.99707C16.7426 7.63373 16.1106 7.67628 15.7471 8.0918L10.5859 13.9902L8.24609 11.3682C7.87831 10.9562 7.24597 10.9204 6.83398 11.2881C6.422 11.6559 6.38619 12.2882 6.75391 12.7002L9.84766 16.166C10.0385 16.3798 10.312 16.5014 10.5986 16.5C10.8853 16.4986 11.1579 16.3739 11.3467 16.1582L17.2529 9.4082C17.6163 8.99256 17.5737 8.36065 17.1582 7.99707Z\" fill=\"#25282D\"/></svg>";
var checkCircleStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2526 9.6585C17.6163 9.24287 17.5741 8.61111 17.1585 8.24742C16.7429 7.88374 16.1111 7.92586 15.7474 8.3415L10.5863 14.24L8.24601 11.6183C7.87822 11.2063 7.24607 11.1705 6.83406 11.5383C6.42205 11.9061 6.38621 12.5382 6.75399 12.9502L9.84774 16.4159C10.0386 16.6298 10.3121 16.7514 10.5987 16.75C10.8853 16.7486 11.1576 16.6242 11.3463 16.4085L17.2526 9.6585Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12ZM21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z\" fill=\"#25282D\"/></svg>";
var checkboxResting = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M21 2H3C2.44772 2 2 2.44772 2 3V21C2 21.5523 2.44772 22 3 22H21C21.5523 22 22 21.5523 22 21V3C22 2.44772 21.5523 2 21 2ZM3 0C1.34315 0 0 1.34315 0 3V21C0 22.6569 1.34315 24 3 24H21C22.6569 24 24 22.6569 24 21V3C24 1.34315 22.6569 0 21 0H3Z\" fill=\"#25282D\"/></svg>";
var checkboxSelectedFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M21 0C22.6569 0 24 1.34315 24 3V21C24 22.6569 22.6569 24 21 24H3C1.34315 24 0 22.6569 0 21V3C0 1.34315 1.34315 0 3 0H21ZM19.6582 5.99707C19.2426 5.63373 18.6106 5.67628 18.2471 6.0918L9.80469 15.7402L5.74609 11.1934C5.37831 10.7814 4.74599 10.7455 4.33398 11.1133C3.9223 11.481 3.88646 12.1125 4.25391 12.5244L9.06641 17.916C9.25727 18.1298 9.53079 18.2514 9.81738 18.25C10.104 18.2486 10.3767 18.1239 10.5654 17.9082L19.7529 7.4082C20.1163 6.99256 20.0737 6.36065 19.6582 5.99707Z\" fill=\"#25282D\"/></svg>";
var checkboxSelectedStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19.6585 5.99744C20.0742 6.36112 20.1163 6.99288 19.7526 7.40852L10.5651 17.9085C10.3763 18.1242 10.1041 18.2486 9.81747 18.25C9.53084 18.2514 9.25738 18.1298 9.0665 17.916L4.254 12.5248C3.88622 12.1128 3.92206 11.4807 4.33407 11.1129C4.74608 10.7451 5.37823 10.781 5.74602 11.193L9.80502 15.74L18.2474 6.09151C18.6111 5.67587 19.2429 5.63375 19.6585 5.99744Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M21 2H3C2.44772 2 2 2.44772 2 3V21C2 21.5523 2.44772 22 3 22H21C21.5523 22 22 21.5523 22 21V3C22 2.44772 21.5523 2 21 2ZM3 0C1.34315 0 0 1.34315 0 3V21C0 22.6569 1.34315 24 3 24H21C22.6569 24 24 22.6569 24 21V3C24 1.34315 22.6569 0 21 0H3Z\" fill=\"#25282D\"/></svg>";
var chevronDown = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M18.7071 9.29289C19.0976 9.68342 19.0976 10.3166 18.7071 10.7071L18 10L17.2929 9.29289C17.6834 8.90237 18.3166 8.90237 18.7071 9.29289ZM12 14.5858L17.2929 9.29289C17.2929 9.29286 17.2929 9.29289 18 10C18.7071 10.7071 18.7071 10.7071 18.7071 10.7071L12.7071 16.7071C12.3166 17.0976 11.6834 17.0976 11.2929 16.7071L5.29289 10.7071C4.90237 10.3166 4.90237 9.68342 5.29289 9.29289C5.68342 8.90237 6.31658 8.90237 6.70711 9.29289L12 14.5858Z\" fill=\"#000000\"/></svg>";
var chevronLeft = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.7071 18.7071C14.3166 19.0976 13.6834 19.0976 13.2929 18.7071L14 18L14.7071 17.2929C15.0976 17.6834 15.0976 18.3166 14.7071 18.7071ZM9.41421 12L14.7071 17.2929C14.7071 17.2929 14.7071 17.2929 14 18C13.2929 18.7071 13.2929 18.7071 13.2929 18.7071L7.29289 12.7071C6.90237 12.3166 6.90237 11.6834 7.29289 11.2929L13.2929 5.29289C13.6834 4.90237 14.3166 4.90237 14.7071 5.29289C15.0976 5.68342 15.0976 6.31658 14.7071 6.70711L9.41421 12Z\" fill=\"#000000\"/></svg>";
var chevronRight = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9.29289 5.29289C9.68342 4.90237 10.3166 4.90237 10.7071 5.29289L10 6L9.29289 6.70711C8.90237 6.31658 8.90237 5.68342 9.29289 5.29289ZM14.5858 12L9.29289 6.70711C9.29286 6.70708 9.29289 6.70711 10 6C10.7071 5.29289 10.7071 5.29286 10.7071 5.29289L16.7071 11.2929C17.0976 11.6834 17.0976 12.3166 16.7071 12.7071L10.7071 18.7071C10.3166 19.0976 9.68342 19.0976 9.29289 18.7071C8.90237 18.3166 8.90237 17.6834 9.29289 17.2929L14.5858 12Z\" fill=\"#000000\"/></svg>";
var chevronUp = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.29289 14.7071C4.90237 14.3166 4.90237 13.6834 5.29289 13.2929L6 14L6.70711 14.7071C6.31658 15.0976 5.68342 15.0976 5.29289 14.7071ZM12 9.41421L6.70711 14.7071C6.70708 14.7071 6.70711 14.7071 6 14C5.29289 13.2929 5.29286 13.2929 5.29289 13.2929L11.2929 7.29289C11.6834 6.90237 12.3166 6.90237 12.7071 7.29289L18.7071 13.2929C19.0976 13.6834 19.0976 14.3166 18.7071 14.7071C18.3166 15.0976 17.6834 15.0976 17.2929 14.7071L12 9.41421Z\" fill=\"#000000\"/></svg>";
var close = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071Z\" fill=\"#25282D\"/></svg>";
var customerService = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11 3C8.23858 3 6 5.23858 6 8V11.5H4V8C4 4.13401 7.13401 1 11 1H13C16.8659 1 20 4.13373 20 7.99977V18.0004C20 20.2097 18.209 22 16 22H12.5V20H16C17.1047 20 18 19.1048 18 18.0004V7.99977C18 5.2384 15.7615 3 13 3H11Z\" fill=\"#25282D\"/><path d=\"M16.5 10C16.5 8.89543 17.3954 8 18.5 8H19.5C20.6046 8 21.5 8.89543 21.5 10V15C21.5 16.1046 20.6046 17 19.5 17H18.5C17.3954 17 16.5 16.1046 16.5 15V10Z\" fill=\"#25282D\"/><path d=\"M2.5 10C2.5 8.89543 3.39543 8 4.5 8H5.5C6.60457 8 7.5 8.89543 7.5 10V15C7.5 16.1046 6.60457 17 5.5 17H4.5C3.39543 17 2.5 16.1046 2.5 15V10Z\" fill=\"#25282D\"/><path d=\"M21.5 10C22.3284 10 23 10.6716 23 11.5V13.5C23 14.3284 22.3284 15 21.5 15V10Z\" fill=\"#25282D\"/><path d=\"M2.5 10C1.67157 10 1 10.6716 1 11.5V13.5C1 14.3284 1.67157 15 2.5 15V10Z\" fill=\"#25282D\"/><path d=\"M9 21C9 19.8954 9.89543 19 11 19H13C14.1046 19 15 19.8954 15 21C15 22.1046 14.1046 23 13 23H11C9.89543 23 9 22.1046 9 21Z\" fill=\"#25282D\"/></svg>";
var dashboardFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 4C2 2.89543 2.89543 2 4 2H9C10.1046 2 11 2.89543 11 4V9C11 10.1046 10.1046 11 9 11H4C2.89543 11 2 10.1046 2 9V4Z\" fill=\"#25282D\"/><path d=\"M2 15C2 13.8954 2.89543 13 4 13H9C10.1046 13 11 13.8954 11 15V20C11 21.1046 10.1046 22 9 22H4C2.89543 22 2 21.1046 2 20V15Z\" fill=\"#25282D\"/><path d=\"M13 4C13 2.89543 13.8954 2 15 2H20C21.1046 2 22 2.89543 22 4V9C22 10.1046 21.1046 11 20 11H15C13.8954 11 13 10.1046 13 9V4Z\" fill=\"#25282D\"/><path d=\"M13 15C13 13.8954 13.8954 13 15 13H20C21.1046 13 22 13.8954 22 15V20C22 21.1046 21.1046 22 20 22H15C13.8954 22 13 21.1046 13 20V15Z\" fill=\"#25282D\"/></svg>";
var dashboardStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 2C10.1046 2 11 2.89543 11 4V9C11 10.1046 10.1046 11 9 11H4C2.89543 11 2 10.1046 2 9V4C2 2.89543 2.89543 2 4 2H9ZM4.5 4C4.22386 4 4 4.22386 4 4.5V8.5C4 8.77614 4.22386 9 4.5 9H8.5C8.77614 9 9 8.77614 9 8.5V4.5C9 4.22386 8.77614 4 8.5 4H4.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M20 2C21.1046 2 22 2.89543 22 4V9C22 10.1046 21.1046 11 20 11H15C13.8954 11 13 10.1046 13 9V4C13 2.89543 13.8954 2 15 2H20ZM15.5 4C15.2239 4 15 4.22386 15 4.5V8.5C15 8.77614 15.2239 9 15.5 9H19.5C19.7761 9 20 8.77614 20 8.5V4.5C20 4.22386 19.7761 4 19.5 4H15.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 13C10.1046 13 11 13.8954 11 15V20C11 21.1046 10.1046 22 9 22H4C2.89543 22 2 21.1046 2 20V15C2 13.8954 2.89543 13 4 13H9ZM4.5 15C4.22386 15 4 15.2239 4 15.5V19.5C4 19.7761 4.22386 20 4.5 20H8.5C8.77614 20 9 19.7761 9 19.5V15.5C9 15.2239 8.77614 15 8.5 15H4.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M20 13C21.1046 13 22 13.8954 22 15V20C22 21.1046 21.1046 22 20 22H15C13.8954 22 13 21.1046 13 20V15C13 13.8954 13.8954 13 15 13H20ZM15.5 15C15.2239 15 15 15.2239 15 15.5V19.5C15 19.7761 15.2239 20 15.5 20H19.5C19.7761 20 20 19.7761 20 19.5V15.5C20 15.2239 19.7761 15 19.5 15H15.5Z\" fill=\"#25282D\"/></svg>";
var deleteFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.1003 1C14.9228 1 16.4 2.47736 16.4001 4.2998H20.8005C21.408 4.29991 21.9001 4.79294 21.9001 5.40039C21.8999 6.00766 21.4078 6.49989 20.8005 6.5H19.7V19.7002C19.6998 21.5226 18.2226 23 16.4001 23H7.60034C5.77787 23 4.30064 21.5226 4.30054 19.7002V6.5H3.19995C2.59275 6.49979 2.10055 6.00759 2.10034 5.40039C2.10034 4.79301 2.59262 4.30002 3.19995 4.2998H7.60034C7.60045 2.47742 9.07776 1.00011 10.9001 1H13.1003ZM9.79956 9.7998C9.19223 9.80002 8.69995 10.293 8.69995 10.9004V16.4004C8.70016 17.0076 9.19236 17.4998 9.79956 17.5C10.4069 17.5 10.8999 17.0077 10.9001 16.4004V10.9004C10.9001 10.2929 10.4071 9.7998 9.79956 9.7998ZM14.2 9.7998C13.5924 9.7998 13.1003 10.2929 13.1003 10.9004V16.4004C13.1006 17.0077 13.5926 17.5 14.2 17.5C14.8073 17.5 15.2993 17.0077 15.2996 16.4004V10.9004C15.2996 10.2929 14.8075 9.7998 14.2 9.7998ZM10.9001 3.2002C10.2928 3.2003 9.80064 3.69245 9.80054 4.2998H14.2C14.1998 3.69238 13.7078 3.2002 13.1003 3.2002H10.9001Z\" fill=\"#25282D\"/></svg>";
var deleteStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8.69995\" y=\"9.80005\" width=\"2.2\" height=\"7.7\" rx=\"1.1\" fill=\"#25282D\"/><rect x=\"13.1003\" y=\"9.7998\" width=\"2.2\" height=\"7.7\" rx=\"1.1\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.60034 4.3C7.60034 2.47746 9.0778 1 10.9003 1H13.1003C14.9229 1 16.4003 2.47746 16.4003 4.3H20.8003C21.4079 4.3 21.9003 4.79249 21.9003 5.4C21.9003 6.00751 21.4079 6.5 20.8003 6.5H19.7003V19.7C19.7003 21.5225 18.2229 23 16.4003 23H7.60034C5.7778 23 4.30034 21.5225 4.30034 19.7V6.5H3.20034C2.59283 6.5 2.10034 6.00751 2.10034 5.4C2.10034 4.79249 2.59283 4.3 3.20034 4.3H7.60034ZM10.9003 3.2H13.1003C13.7079 3.2 14.2003 3.69249 14.2003 4.3H9.80034C9.80034 3.69249 10.2928 3.2 10.9003 3.2ZM6.50034 6.5V19.7C6.50034 20.3075 6.99283 20.8 7.60034 20.8H16.4003C17.0079 20.8 17.5003 20.3075 17.5003 19.7V6.5H6.50034Z\" fill=\"#25282D\"/></svg>";
var dialog = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.39445 17H19C20.1046 17 21 16.1046 21 15V7C21 5.89543 20.1046 5 19 5H5C3.89543 5 3 5.89543 3 7V18.5963L5.39445 17ZM6 19L3.38675 20.7422C3.13457 20.9103 2.83827 21 2.53518 21C1.68733 21 1 20.3127 1 19.4648V7C1 4.79086 2.79086 3 5 3H19C21.2091 3 23 4.79086 23 7V15C23 17.2091 21.2091 19 19 19H6Z\" fill=\"#25282D\"/><path d=\"M13.25 11.25C13.25 11.9404 12.6904 12.5 12 12.5C11.3096 12.5 10.75 11.9404 10.75 11.25C10.75 10.5596 11.3096 10 12 10C12.6904 10 13.25 10.5596 13.25 11.25Z\" fill=\"#25282D\"/><path d=\"M17.7002 11.25C17.7002 11.9404 17.1406 12.5 16.4502 12.5C15.7598 12.5 15.2002 11.9404 15.2002 11.25C15.2002 10.5596 15.7598 10 16.4502 10C17.1406 10 17.7002 10.5596 17.7002 11.25Z\" fill=\"#25282D\"/><path d=\"M8.7998 11.25C8.7998 11.9404 8.24016 12.5 7.5498 12.5C6.85945 12.5 6.2998 11.9404 6.2998 11.25C6.2998 10.5596 6.85945 10 7.5498 10C8.24016 10 8.7998 10.5596 8.7998 11.25Z\" fill=\"#25282D\"/></svg>";
var download = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3 21C3 20.4477 3.44772 20 4 20L20 20C20.5523 20 21 20.4477 21 21C21 21.5523 20.5523 22 20 22L4 22C3.44772 22 3 21.5523 3 21Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M18.0401 11.9599C18.4306 12.3504 18.4306 12.9836 18.0401 13.3741L17.333 12.667L16.6259 11.9599C17.0164 11.5694 17.6496 11.5694 18.0401 11.9599ZM11.9996 16.5862L16.6259 11.9599C16.6259 11.9599 16.6259 11.9599 17.333 12.667C18.0401 13.3741 18.0401 13.3741 18.0401 13.3741L12.7067 18.7075C12.3162 19.098 11.683 19.098 11.2925 18.7075L5.95915 13.3741C5.56862 12.9836 5.56862 12.3504 5.95915 11.9599C6.34967 11.5694 6.98284 11.5694 7.37336 11.9599L11.9996 16.5862Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 18.5C11.4477 18.5 11 18.0523 11 17.5L11 3C11 2.44771 11.4477 2 12 2C12.5523 2 13 2.44772 13 3L13 17.5C13 18.0523 12.5523 18.5 12 18.5Z\" fill=\"#25282D\"/></svg>";
var duplicate = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5 8V20C5 20.5523 5.44772 21 6 21H14C14.5523 21 15 20.5523 15 20H9C7.34315 20 6 18.6569 6 17V7C5.44772 7 5 7.44772 5 8ZM14 23H6C4.34315 23 3 21.6569 3 20V8C3 6.34315 4.34315 5 6 5H8V17C8 17.5523 8.44772 18 9 18H17V20C17 21.6569 15.6569 23 14 23Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M18 3H9C8.44772 3 8 3.44772 8 4V17C8 17.5523 8.44772 18 9 18H18C18.5523 18 19 17.5523 19 17V4C19 3.44772 18.5523 3 18 3ZM9 1C7.34315 1 6 2.34315 6 4V17C6 18.6569 7.34315 20 9 20H18C19.6569 20 21 18.6569 21 17V4C21 2.34315 19.6569 1 18 1H9Z\" fill=\"#25282D\"/></svg>";
var guide = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C12.5523 1 13 1.44772 13 2V3H17.9297C18.5984 3.00002 19.2228 3.33424 19.5938 3.89062L20.7227 5.58398C20.9035 5.85525 21 6.17398 21 6.5C21 6.82602 20.9035 7.14475 20.7227 7.41602L19.5938 9.10938C19.2228 9.66576 18.5984 9.99998 17.9297 10H13V11H19C20.1046 11 21 11.8954 21 13V16C21 17.1046 20.1046 18 19 18H13V22C13 22.5523 12.5523 23 12 23C11.4477 23 11 22.5523 11 22V18H6.07031C5.40163 18 4.77717 17.6658 4.40625 17.1094L3.27734 15.416C3.0965 15.1447 3 14.826 3 14.5C3 14.174 3.0965 13.8553 3.27734 13.584L4.40625 11.8906C4.77717 11.3342 5.40163 11 6.07031 11H11V10H5C3.89543 10 3 9.10457 3 8V5C3 3.89543 3.89543 3 5 3H11V2C11 1.44772 11.4477 1 12 1ZM5.07031 14.5L6.07031 16H19V13H6.07031L5.07031 14.5ZM5 8H17.9297L18.9297 6.5L17.9297 5H5V8Z\" fill=\"#25282D\"/></svg>";
var gym = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4 1C4.55228 1 5 1.44772 5 2V3H20C20.5523 3 21 3.44772 21 4C21 4.55228 20.5523 5 20 5H19V6C20.1046 6 21 6.89543 21 8V15C21 16.1046 20.1046 17 19 17H9C7.89543 17 7 16.1046 7 15V8C7 6.89543 7.89543 6 9 6V5H5V22C5 22.5523 4.55228 23 4 23C3.44772 23 3 22.5523 3 22V2C3 1.44772 3.44772 1 4 1ZM11 9C10.7239 9 10.5 9.22386 10.5 9.5V10H10C9.72386 10 9.5 10.2239 9.5 10.5V12.5C9.5 12.7761 9.72386 13 10 13H10.5V13.5C10.5 13.7761 10.7239 14 11 14H12C12.2761 14 12.5 13.7761 12.5 13.5V12.5H15.5V13.5C15.5 13.7761 15.7239 14 16 14H17C17.2761 14 17.5 13.7761 17.5 13.5V13H18C18.2761 13 18.5 12.7761 18.5 12.5V10.5C18.5 10.2239 18.2761 10 18 10H17.5V9.5C17.5 9.22386 17.2761 9 17 9H16C15.7239 9 15.5 9.22386 15.5 9.5V10.5H12.5V9.5C12.5 9.22386 12.2761 9 12 9H11ZM11 6H17V5H11V6Z\" fill=\"#25282D\"/></svg>";
var hamburger = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20 11C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H4C3.44772 13 3 12.5523 3 12C3 11.4477 3.44772 11 4 11H20Z\" fill=\"#25282D\"/><path d=\"M20 4C20.5523 4 21 4.44772 21 5C21 5.55228 20.5523 6 20 6H4C3.44772 6 3 5.55228 3 5C3 4.44772 3.44772 4 4 4H20Z\" fill=\"#25282D\"/><path d=\"M20 18C20.5523 18 21 18.4477 21 19C21 19.5523 20.5523 20 20 20H4C3.44772 20 3 19.5523 3 19C3 18.4477 3.44772 18 4 18H20Z\" fill=\"#25282D\"/></svg>";
var heartFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M22 9.01522C22 14.2787 15.6392 18.7521 12.8703 20.719C12.6118 20.9026 12.3057 21 11.9887 21C11.6857 21 11.3928 20.9114 11.1466 20.7349C9.37882 19.4672 2 13.8839 2 9.01499C2 3.48348 8.19048 0.717718 12 5.32721C15.8095 0.717718 22 3.48349 22 9.01522Z\" fill=\"currentColor\"/></svg>";
var heart = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 7.32721C11.4036 7.32721 10.8383 7.06104 10.4584 6.60131C9.07662 4.92942 7.48573 4.75821 6.31197 5.22607C5.07922 5.71745 4 7.03452 4 9.01499C4 9.74225 4.28337 10.6479 4.90623 11.711C5.52017 12.759 6.38647 13.8281 7.35673 14.8441C9.09158 16.6606 11.0112 18.1551 12.0008 18.8833C13.3939 17.8918 15.3615 16.4614 17.029 14.7201C18.8599 12.8079 20 10.8568 20 9.01522C20 7.0346 18.9207 5.71748 17.688 5.2261C16.5143 4.75822 14.9234 4.92942 13.5416 6.60131C13.1617 7.06104 12.5964 7.32721 12 7.32721ZM10.5279 3.96986C11.0433 4.31979 11.5391 4.76952 12 5.32721C12.4609 4.76952 12.9567 4.31979 13.4721 3.96986C17.2168 1.42745 22 4.15276 22 9.01522C22 14.2349 15.7445 18.6777 12.94 20.6695L12.8703 20.719C12.6118 20.9026 12.3057 21 11.9887 21C11.6857 21 11.3928 20.9114 11.1466 20.7349C9.37882 19.4672 2 13.8839 2 9.01499C2 4.15272 6.78316 1.42744 10.5279 3.96986Z\" fill=\"currentColor\"/></svg>";
var heartStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 7.32721C11.4036 7.32721 10.8383 7.06104 10.4584 6.60131C9.07662 4.92942 7.48573 4.75821 6.31197 5.22607C5.07922 5.71745 4 7.03452 4 9.01499C4 9.74225 4.28337 10.6479 4.90623 11.711C5.52017 12.759 6.38647 13.8281 7.35673 14.8441C9.09158 16.6606 11.0112 18.1551 12.0008 18.8833C13.3939 17.8918 15.3615 16.4614 17.029 14.7201C18.8599 12.8079 20 10.8568 20 9.01522C20 7.0346 18.9207 5.71748 17.688 5.2261C16.5143 4.75822 14.9234 4.92942 13.5416 6.60131C13.1617 7.06104 12.5964 7.32721 12 7.32721ZM10.5279 3.96986C11.0433 4.31979 11.5391 4.76952 12 5.32721C12.4609 4.76952 12.9567 4.31979 13.4721 3.96986C17.2168 1.42745 22 4.15276 22 9.01522C22 14.2349 15.7445 18.6777 12.94 20.6695L12.8703 20.719C12.6118 20.9026 12.3057 21 11.9887 21C11.6857 21 11.3928 20.9114 11.1466 20.7349C9.37882 19.4672 2 13.8839 2 9.01499C2 4.15272 6.78316 1.42744 10.5279 3.96986Z\" fill=\"#25282D\"/></svg>";
var historyFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18 1C19.6569 1 21 2.34315 21 4V20C21 21.6569 19.6569 23 18 23H6C4.34315 23 3 21.6569 3 20V4C3 2.34315 4.34315 1 6 1H18ZM8 14C7.44772 14 7 14.4477 7 15C7 15.5523 7.44772 16 8 16H13C13.5523 16 14 15.5523 14 15C14 14.4477 13.5523 14 13 14H8ZM8 10C7.44772 10 7 10.4477 7 11C7 11.5523 7.44772 12 8 12H16C16.5523 12 17 11.5523 17 11C17 10.4477 16.5523 10 16 10H8ZM8 6C7.44772 6 7 6.44772 7 7C7 7.55228 7.44772 8 8 8H16C16.5523 8 17 7.55228 17 7C17 6.44772 16.5523 6 16 6H8Z\" fill=\"#25282D\"/></svg>";
var historyStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8 6C7.44772 6 7 6.44772 7 7C7 7.55228 7.44772 8 8 8L16 8C16.5523 8 17 7.55228 17 7C17 6.44771 16.5523 6 16 6L8 6Z\" fill=\"#25282D\"/><path d=\"M7 11C7 10.4477 7.44772 10 8 10L16 10C16.5523 10 17 10.4477 17 11C17 11.5523 16.5523 12 16 12L8 12C7.44772 12 7 11.5523 7 11Z\" fill=\"#25282D\"/><path d=\"M8 14C7.44772 14 7 14.4477 7 15C7 15.5523 7.44772 16 8 16H13C13.5523 16 14 15.5523 14 15C14 14.4477 13.5523 14 13 14H8Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3 4C3 2.34315 4.34315 1 6 1H18C19.6569 1 21 2.34315 21 4V20C21 21.6569 19.6569 23 18 23H6C4.34315 23 3 21.6569 3 20V4ZM6 3H18C18.5523 3 19 3.44772 19 4V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V4C5 3.44772 5.44772 3 6 3Z\" fill=\"#25282D\"/></svg>";
var homeFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.137 2.34387L2.62451 10.4084C2.22583 10.7861 2 11.3111 2 11.8603V20C2 21.1046 2.89543 22 4 22H8.5C9.05228 22 9.5 21.5523 9.5 21V17.5C9.5 16.3954 10.3954 15.5 11.5 15.5H12.5C13.6046 15.5 14.5 16.3954 14.5 17.5V21C14.5 21.5523 14.9477 22 15.5 22H20C21.1046 22 22 21.1046 22 20V11.8603C22 11.3111 21.7742 10.7861 21.3755 10.4084L12.863 2.34387C12.6299 2.12307 12.3211 2 12 2C11.6789 2 11.3701 2.12307 11.137 2.34387Z\" fill=\"currentColor\"/></svg>";
var home = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 4.28132L4 11.8603V20H7.5V17.5C7.5 15.2909 9.29086 13.5 11.5 13.5H12.5C14.7091 13.5 16.5 15.2909 16.5 17.5V20H20L20 11.8603L12 4.28132ZM2.62451 10.4084L11.137 2.34387C11.3701 2.12307 11.6789 2 12 2C12.3211 2 12.6299 2.12307 12.863 2.34387L21.3755 10.4084C21.7742 10.7861 22 11.3111 22 11.8603V20C22 21.1046 21.1046 22 20 22H15.5C14.9477 22 14.5 21.5523 14.5 21V17.5C14.5 16.3954 13.6046 15.5 12.5 15.5H11.5C10.3954 15.5 9.5 16.3954 9.5 17.5V21C9.5 21.5523 9.05228 22 8.5 22H4C2.89543 22 2 21.1046 2 20V11.8603C2 11.3111 2.22583 10.7861 2.62451 10.4084Z\" fill=\"currentColor\"/></svg>";
var homeStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 4.28132L4 11.8603V20H7.5V17.5C7.5 15.2909 9.29086 13.5 11.5 13.5H12.5C14.7091 13.5 16.5 15.2909 16.5 17.5V20H20L20 11.8603L12 4.28132ZM2.62451 10.4084L11.137 2.34387C11.3701 2.12307 11.6789 2 12 2C12.3211 2 12.6299 2.12307 12.863 2.34387L21.3755 10.4084C21.7742 10.7861 22 11.3111 22 11.8603V20C22 21.1046 21.1046 22 20 22H15.5C14.9477 22 14.5 21.5523 14.5 21V17.5C14.5 16.3954 13.6046 15.5 12.5 15.5H11.5C10.3954 15.5 9.5 16.3954 9.5 17.5V21C9.5 21.5523 9.05228 22 8.5 22H4C2.89543 22 2 21.1046 2 20V11.8603C2 11.3111 2.22583 10.7861 2.62451 10.4084Z\" fill=\"#25282D\"/></svg>";
var idCardFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1 6.5C1 4.84315 2.34315 3.5 4 3.5H20C21.6569 3.5 23 4.84315 23 6.5V17.5C23 19.1569 21.6569 20.5 20 20.5H4C2.34315 20.5 1 19.1569 1 17.5V6.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5 14C13.5 13.4477 13.9477 13 14.5 13L18.5 13C19.0523 13 19.5 13.4477 19.5 14C19.5 14.5523 19.0523 15 18.5 15L14.5 15C13.9477 15 13.5 14.5523 13.5 14Z\" fill=\"white\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5 10C13.5 9.44772 13.9477 9 14.5 9L16.5 9C17.0523 9 17.5 9.44772 17.5 10C17.5 10.5523 17.0523 11 16.5 11L14.5 11C13.9477 11 13.5 10.5523 13.5 10Z\" fill=\"white\"/><path d=\"M9.5 8H6.5C5.39543 8 4.5 8.89543 4.5 10V14C4.5 15.1046 5.39543 16 6.5 16H9.5C10.6046 16 11.5 15.1046 11.5 14V10C11.5 8.89543 10.6046 8 9.5 8Z\" fill=\"white\"/></svg>";
var idCardStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M20 5.5H4C3.44772 5.5 3 5.94772 3 6.5V17.5C3 18.0523 3.44772 18.5 4 18.5H20C20.5523 18.5 21 18.0523 21 17.5V6.5C21 5.94772 20.5523 5.5 20 5.5ZM4 3.5C2.34315 3.5 1 4.84315 1 6.5V17.5C1 19.1569 2.34315 20.5 4 20.5H20C21.6569 20.5 23 19.1569 23 17.5V6.5C23 4.84315 21.6569 3.5 20 3.5H4Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5 14C13.5 13.4477 13.9477 13 14.5 13L18.5 13C19.0523 13 19.5 13.4477 19.5 14C19.5 14.5523 19.0523 15 18.5 15L14.5 15C13.9477 15 13.5 14.5523 13.5 14Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5 10C13.5 9.44772 13.9477 9 14.5 9L16.5 9C17.0523 9 17.5 9.44772 17.5 10C17.5 10.5523 17.0523 11 16.5 11L14.5 11C13.9477 11 13.5 10.5523 13.5 10Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.5 10C4.5 8.89543 5.39543 8 6.5 8H9.5C10.6046 8 11.5 8.89543 11.5 10V14C11.5 15.1046 10.6046 16 9.5 16H6.5C5.39543 16 4.5 15.1046 4.5 14V10ZM9.5 10H6.5V14H9.5L9.5 10Z\" fill=\"#25282D\"/></svg>";
var image = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 4H5C4.44771 4 4 4.44772 4 5V19C4 19.5523 4.44772 20 5 20H19C19.5523 20 20 19.5523 20 19V5C20 4.44771 19.5523 4 19 4ZM5 2C3.34315 2 2 3.34315 2 5V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V5C22 3.34315 20.6569 2 19 2H5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.70718 12.121C8.31666 11.7305 7.68349 11.7305 7.29297 12.121L3.70718 15.7068L2.29297 14.2926L5.87876 10.7068C7.05033 9.53523 8.94982 9.53523 10.1214 10.7068L19.9572 20.5426L18.543 21.9568L8.70718 12.121Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16.7072 14.121C16.3167 13.7305 15.6835 13.7305 15.293 14.121L13.7072 15.7068L12.293 14.2926L13.8788 12.7068C15.0503 11.5352 16.9498 11.5352 18.1214 12.7068L21.7072 16.2926L20.293 17.7068L16.7072 14.121Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16 10C17.1046 10 18 9.10457 18 8C18 6.89543 17.1046 6 16 6C14.8954 6 14 6.89543 14 8C14 9.10457 14.8954 10 16 10Z\" fill=\"#25282D\"/></svg>";
var infoFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 0.999999 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 9.75C11.4477 9.75 11 10.1977 11 10.75V16.75C11 17.3023 11.4477 17.75 12 17.75C12.5523 17.75 13 17.3023 13 16.75V10.75C13 10.1977 12.5523 9.75 12 9.75ZM12 6.25C11.3096 6.25 10.75 6.80964 10.75 7.5C10.75 8.19036 11.3096 8.75 12 8.75C12.6904 8.75 13.25 8.19035 13.25 7.5C13.25 6.80965 12.6904 6.25 12 6.25Z\" fill=\"#25282D\"/></svg>";
var infoStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.25 7.5C13.25 8.19036 12.6904 8.75 12 8.75C11.3096 8.75 10.75 8.19036 10.75 7.5C10.75 6.80964 11.3096 6.25 12 6.25C12.6904 6.25 13.25 6.80965 13.25 7.5Z\" fill=\"#25282D\"/><path d=\"M12 17.75C12.5523 17.75 13 17.3023 13 16.75L13 10.75C13 10.1977 12.5523 9.75 12 9.75C11.4477 9.75 11 10.1977 11 10.75L11 16.75C11 17.3023 11.4477 17.75 12 17.75Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 1C5.92487 1 1 5.92487 1 12C0.999999 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3Z\" fill=\"#25282D\"/></svg>";
var locationFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C16.9706 1 21 5.02944 21 10C21 16.9264 14.6282 21.6036 12.918 22.7344C12.6449 22.9149 12.3274 23 12 23C11.6726 23 11.3551 22.9149 11.082 22.7344C9.37183 21.6036 3 16.9264 3 10C3 5.02944 7.02944 1 12 1ZM12 6.5C10.067 6.5 8.5 8.067 8.5 10C8.5 11.933 10.067 13.5 12 13.5C13.933 13.5 15.5 11.933 15.5 10C15.5 8.067 13.933 6.5 12 6.5Z\" fill=\"#25282D\"/></svg>";
var locationStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 10C19 6.13401 15.866 3 12 3C8.13401 3 5 6.13401 5 10C5 12.829 6.30152 15.2912 7.93849 17.2633C9.45284 19.0876 11.1484 20.3612 12 20.9421C12.8516 20.3612 14.5472 19.0876 16.0615 17.2633C17.6985 15.2912 19 12.829 19 10ZM12 1C16.9706 1 21 5.02944 21 10C21 16.9264 14.6284 21.6039 12.9182 22.7347C12.6451 22.9152 12.3274 23 12 23C11.6726 23 11.3549 22.9152 11.0818 22.7347C9.37161 21.6039 3 16.9264 3 10C3 5.02944 7.02944 1 12 1Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 12C13.1046 12 14 11.1046 14 10C14 8.89543 13.1046 8 12 8C10.8954 8 10 8.89543 10 10C10 11.1046 10.8954 12 12 12ZM12 14C14.2091 14 16 12.2091 16 10C16 7.79086 14.2091 6 12 6C9.79086 6 8 7.79086 8 10C8 12.2091 9.79086 14 12 14Z\" fill=\"#25282D\"/></svg>";
var logoApple = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.0331 12.6879C18.0641 16.0172 20.9678 17.1251 21 17.1393C20.9754 17.2174 20.536 18.7181 19.4702 20.2683C18.5488 21.6085 17.5925 22.9438 16.0861 22.9714C14.6059 22.9985 14.13 22.0979 12.4377 22.0979C10.7459 22.0979 10.2171 22.9437 8.81591 22.9985C7.36184 23.0533 6.25458 21.5493 5.32554 20.214C3.42717 17.4827 1.97642 12.4959 3.92441 9.12967C4.89213 7.45801 6.62152 6.39945 8.49862 6.3723C9.92648 6.3452 11.2742 7.3283 12.1471 7.3283C13.0194 7.3283 14.6572 6.14603 16.3789 6.31966C17.0997 6.34952 19.1229 6.60942 20.4221 8.50192C20.3174 8.56651 18.0079 9.90449 18.0331 12.6879ZM15.2512 4.51263C16.0232 3.58268 16.5427 2.2881 16.401 1C15.2883 1.04451 13.9427 1.73794 13.1446 2.66738C12.4293 3.49044 11.8028 4.8078 11.9719 6.07041C13.2121 6.16591 14.4792 5.44317 15.2512 4.51263Z\" fill=\"#25282D\"/></svg>";
var logoGoogle = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><mask id=\"mask0_9_640\" style=\"mask-type:luminance\" maskUnits=\"userSpaceOnUse\" x=\"1\" y=\"1\" width=\"22\" height=\"22\"><path d=\"M23 1H1V23H23V1Z\" fill=\"white\"/></mask><g mask=\"url(#mask0_9_640)\"><path d=\"M22.56 12.25C22.56 11.47 22.49 10.7201 22.36 10H12V14.255H17.92C17.665 15.63 16.8901 16.795 15.725 17.575V20.335H19.28C21.36 18.4201 22.56 15.6 22.56 12.25Z\" fill=\"#4285F4\"/><path d=\"M12 23C14.97 23 17.4599 22.0149 19.2799 20.335L15.7249 17.575C14.74 18.235 13.4799 18.6249 12 18.6249C9.1349 18.6249 6.70995 16.6899 5.84491 14.09H2.16992V16.94C3.97997 20.535 7.69995 23 12 23Z\" fill=\"#34A853\"/><path d=\"M5.84495 14.09C5.62495 13.43 5.49999 12.7251 5.49999 12C5.49999 11.275 5.62495 10.57 5.84495 9.91005V7.06006H2.16996C1.42504 8.54506 1 10.2251 1 12C1 13.775 1.42504 15.455 2.16996 16.94L5.84495 14.09Z\" fill=\"#FBBC04\"/><path d=\"M12 5.37503C13.6149 5.37503 15.0649 5.92998 16.2049 7.01997L19.36 3.86495C17.455 2.08999 14.9649 1 12 1C7.69995 1 3.97997 3.46499 2.16992 7.06001L5.84491 9.91C6.70995 7.31004 9.1349 5.37503 12 5.37503Z\" fill=\"#E94235\"/></g></svg>";
var logoKakao = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 2.47122C6.20072 2.47122 1.50002 6.2449 1.50002 10.8991C1.50002 13.7937 3.31816 16.3454 6.0868 17.8631L4.92189 22.2848C4.81897 22.6755 5.249 22.9869 5.57923 22.7605L10.6856 19.2587C11.1165 19.3019 11.5544 19.3271 12 19.3271C17.7989 19.3271 22.4999 15.5536 22.4999 10.8991C22.4999 6.2449 17.7989 2.47122 12 2.47122Z\" fill=\"#25282D\"/></svg>";
var logoNaver = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.5614 13.7033L8.14609 3H2V23H8.43861V12.295L15.8539 23H22V3H15.5614V13.7033Z\" fill=\"#25282D\"/></svg>";
var mailFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1.08484 5.78863L10.9 13.15C11.6111 13.6833 12.5889 13.6833 13.3 13.15L22.9435 5.9174C22.6723 4.5394 21.4575 3.5 20 3.5H4C2.58824 3.5 1.40425 4.47516 1.08484 5.78863Z\" fill=\"#25282D\"/><path d=\"M23 8.375L16.7667 13.05L22.9921 17.719C22.9973 17.6467 23 17.5737 23 17.5V8.375Z\" fill=\"#25282D\"/><path d=\"M22.1527 19.5895L15.1 14.3L14.5 14.75C13.0778 15.8167 11.1222 15.8167 9.7 14.75L9.09996 14.3L1.93353 19.6748C2.47155 20.1862 3.19913 20.5 4 20.5H20C20.8445 20.5 21.6075 20.1511 22.1527 19.5895Z\" fill=\"#25282D\"/><path d=\"M1.02126 17.859L7.4333 13.05L1 8.225V17.5C1 17.6215 1.00722 17.7413 1.02126 17.859Z\" fill=\"#25282D\"/></svg>";
var mailStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M1 6.5C1 4.84315 2.34315 3.5 4 3.5H20C21.6569 3.5 23 4.84315 23 6.5V17.5C23 19.1569 21.6569 20.5 20 20.5H4C2.34315 20.5 1 19.1569 1 17.5V6.5ZM4 5.5H20C20.5523 5.5 21 5.94772 21 6.5V7.37501L13.3 13.15C12.5889 13.6833 11.6111 13.6833 10.9 13.15L3 7.22501V6.5C3 5.94772 3.44772 5.5 4 5.5ZM3 9.72501V16.375L7.4333 13.05L3 9.72501ZM3.6069 18.4198C3.72756 18.4714 3.86044 18.5 4 18.5H20C20.1872 18.5 20.3624 18.4486 20.5122 18.3591L15.1 14.3L14.5 14.75C13.0778 15.8167 11.1222 15.8167 9.7 14.75L9.09996 14.3L3.6069 18.4198ZM21 16.225V9.87501L16.7667 13.05L21 16.225Z\" fill=\"#25282D\"/></svg>";
var microphone = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 16.4C14.5211 16.4 16.5714 14.4255 16.5714 12V5.4C16.5714 2.9734 14.5211 1 12 1C9.47886 1 7.42857 2.9734 7.42857 5.4V12C7.42857 14.4255 9.47886 16.4 12 16.4ZM20 12V9.8C20 9.50826 19.8796 9.22847 19.6653 9.02218C19.4509 8.81589 19.1602 8.7 18.8571 8.7C18.554 8.7 18.2633 8.81589 18.049 9.02218C17.8347 9.22847 17.7143 9.50826 17.7143 9.8V12C17.7143 15.0327 15.1509 17.5 12 17.5C8.84914 17.5 6.28571 15.0327 6.28571 12V9.8C6.28571 9.50826 6.16531 9.22847 5.95098 9.02218C5.73665 8.81589 5.44596 8.7 5.14286 8.7C4.83975 8.7 4.54906 8.81589 4.33474 9.02218C4.12041 9.22847 4 9.50826 4 9.8V12C4 15.872 6.98629 19.0752 10.8571 19.612V20.8H7.42857C7.12547 20.8 6.83478 20.9159 6.62045 21.1222C6.40612 21.3285 6.28571 21.6083 6.28571 21.9C6.28571 22.1917 6.40612 22.4715 6.62045 22.6778C6.83478 22.8841 7.12547 23 7.42857 23H16.5714C16.8745 23 17.1652 22.8841 17.3796 22.6778C17.5939 22.4715 17.7143 22.1917 17.7143 21.9C17.7143 21.6083 17.5939 21.3285 17.3796 21.1222C17.1652 20.9159 16.8745 20.8 16.5714 20.8H13.1429V19.612C17.0137 19.0752 20 15.872 20 12Z\" fill=\"#25282D\"/></svg>";
var minus = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20 11C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H4C3.44772 13 3 12.5523 3 12C3 11.4477 3.44772 11 4 11H20Z\" fill=\"#25282D\"/></svg>";
var minusCircleFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM7.25 11C6.69771 11 6.25 11.4477 6.25 12C6.25 12.5523 6.69771 13 7.25 13H16.75C17.3023 13 17.75 12.5523 17.75 12C17.75 11.4477 17.3023 11 16.75 11H7.25Z\" fill=\"#25282D\"/></svg>";
var minusCircleStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3ZM16.75 11C17.3023 11 17.75 11.4477 17.75 12C17.75 12.5523 17.3023 13 16.75 13H7.25C6.69771 13 6.25 12.5523 6.25 12C6.25 11.4477 6.69771 11 7.25 11H16.75Z\" fill=\"#25282D\"/></svg>";
var modify = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13 2C13.5523 2 14 2.44772 14 3C14 3.55228 13.5523 4 13 4H5C4.44771 4 4 4.44772 4 5V19C4 19.5523 4.44772 20 5 20H19C19.5523 20 20 19.5523 20 19V11C20 10.4477 20.4477 10 21 10C21.5523 10 22 10.4477 22 11V19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V5C2 3.34315 3.34315 2 5 2H13ZM20.8398 5.28223L10.1719 15.9492C9.98435 16.1367 9.73002 16.2422 9.46484 16.2422H8.25781C7.98174 16.2421 7.75781 16.0183 7.75781 15.7422V14.5352C7.75781 14.27 7.86329 14.0157 8.05078 13.8281L18.7178 3.16113L20.8398 5.28223ZM19.4248 2.4541C19.8153 2.0636 20.4483 2.06365 20.8389 2.4541L21.5459 3.16113C21.9364 3.55166 21.9364 4.18467 21.5459 4.5752L21.1924 4.92871L19.0713 2.80762L19.4248 2.4541Z\" fill=\"#25282D\"/></svg>";
var more = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"19.5\" r=\"1.5\" fill=\"#25282D\"/><circle cx=\"12\" cy=\"4.5\" r=\"1.5\" fill=\"#25282D\"/><circle cx=\"12\" cy=\"12\" r=\"1.5\" fill=\"#25282D\"/></svg>";
var myPageFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.25 12C15.0114 12 17.25 9.76142 17.25 7C17.25 4.23858 15.0114 2 12.25 2C9.48858 2 7.25 4.23858 7.25 7C7.25 9.76142 9.48858 12 12.25 12Z\" fill=\"currentColor\"/><path d=\"M9.25 13C5.93629 13 3.25 15.6863 3.25 19V20C3.25 21.1046 4.14543 22 5.25 22H19.25C20.3546 22 21.25 21.1046 21.25 20V19C21.25 15.6863 18.5637 13 15.25 13H9.25Z\" fill=\"currentColor\"/></svg>";
var myPage = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17 7C17 9.76142 14.7614 12 12 12C9.23858 12 7 9.76142 7 7C7 4.23858 9.23858 2 12 2C14.7614 2 17 4.23858 17 7ZM15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z\" fill=\"currentColor\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3 19C3 15.6863 5.68629 13 9 13H15C18.3137 13 21 15.6863 21 19V20C21 21.1046 20.1046 22 19 22H5C3.89543 22 3 21.1046 3 20V19ZM5 19C5 16.7909 6.79086 15 9 15H15C17.2091 15 19 16.7909 19 19V20H5L5 19Z\" fill=\"currentColor\"/></svg>";
var number_0 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M8 11.4214C8 9.71032 8.32889 8.38333 8.98667 7.44048C9.66222 6.48016 10.6578 6 11.9733 6C13.3067 6 14.3111 6.48016 14.9867 7.44048C15.6622 8.38333 16 9.70159 16 11.3952C16 13.0889 15.6622 14.4508 14.9867 15.481C14.3111 16.4937 13.3067 17 11.9733 17C10.6578 17 9.66222 16.5024 8.98667 15.5071C8.32889 14.5119 8 13.15 8 11.4214ZM10.3467 11.4214C10.3467 12.5563 10.4622 13.4119 10.6933 13.9881C10.9422 14.5468 11.3689 14.8262 11.9733 14.8262C12.5956 14.8262 13.0311 14.5294 13.28 13.9357C13.5289 13.3421 13.6533 12.4865 13.6533 11.369C13.6533 10.2516 13.5289 9.44841 13.28 8.95952C13.0489 8.45317 12.6222 8.2 12 8.2C11.3956 8.2 10.9689 8.45317 10.72 8.95952C10.4711 9.46587 10.3467 10.2865 10.3467 11.4214Z\" fill=\"white\"/></svg>";
var number_1 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M12.7222 17C12.3889 17 12.0926 16.8865 11.8333 16.6595C11.5926 16.4325 11.4722 16.1706 11.4722 15.8738V8.93333C11.4722 8.68889 11.3611 8.62778 11.1389 8.75L10.6389 9.0119C10.5648 9.04683 10.4907 9.07302 10.4167 9.09048C10.3426 9.09048 10.2685 9.09048 10.1944 9.09048C9.84259 9.09048 9.55556 8.98571 9.33333 8.77619C9.11111 8.54921 9 8.26984 9 7.9381C9 7.48413 9.25926 7.15238 9.77778 6.94286L11.9167 6.13095C12.1574 6.04365 12.3704 6 12.5556 6C12.9815 6 13.3241 6.12222 13.5833 6.36667C13.8611 6.61111 14 6.93413 14 7.33571L13.9722 15.9262C13.9722 16.2405 13.8519 16.5024 13.6111 16.7119C13.3889 16.904 13.0926 17 12.7222 17Z\" fill=\"white\"/></svg>";
var number_2 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M9.57456 17C9.23114 17 8.93292 16.884 8.67987 16.6521C8.44491 16.4201 8.32742 16.1346 8.32742 15.7956C8.32742 15.3852 8.50817 15.0105 8.86966 14.6715L11.0115 12.7178C11.8067 11.9862 12.358 11.3885 12.6653 10.9246C12.9725 10.4428 13.1262 9.96107 13.1262 9.47932C13.1262 9.06894 12.9997 8.73885 12.7466 8.48905C12.5116 8.23925 12.1863 8.11436 11.7706 8.11436C11.373 8.11436 11.0476 8.23033 10.7946 8.46229C10.5415 8.69424 10.3698 9.00649 10.2795 9.39903C10.2252 9.66667 10.0897 9.8897 9.87278 10.0681C9.67397 10.2287 9.42092 10.309 9.11366 10.309C8.78832 10.309 8.51721 10.2019 8.30031 9.98783C8.08342 9.77372 7.98401 9.515 8.00209 9.21168C8.03823 8.26602 8.4178 7.49878 9.14077 6.90998C9.88182 6.30333 10.8036 6 11.9062 6C13.0268 6 13.9124 6.32117 14.5631 6.9635C15.2318 7.588 15.5662 8.39984 15.5662 9.39903C15.5662 10.0235 15.4035 10.6212 15.0782 11.1922C14.7709 11.7453 14.301 12.3341 13.6684 12.9586L12.1502 14.4574C11.861 14.7429 11.9242 14.8856 12.3399 14.8856L14.8071 14.8321C15.1686 14.8143 15.4578 14.9124 15.6747 15.1265C15.8916 15.3228 16 15.5904 16 15.9294C16 16.2506 15.9006 16.5093 15.7018 16.7056C15.503 16.9019 15.2409 17 14.9155 17H9.57456Z\" fill=\"white\"/></svg>";
var number_3 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M11.92 16.9993C11.0311 16.9819 10.2578 16.816 9.6 16.5017C8.94222 16.1875 8.46222 15.7422 8.16 15.1661C8.05333 14.9566 8 14.7733 8 14.6161C8 14.2844 8.14222 14.0225 8.42667 13.8305C8.71111 13.6384 9.00444 13.5424 9.30667 13.5424C9.50222 13.5424 9.68 13.5773 9.84 13.6471C10 13.717 10.1156 13.8392 10.1867 14.0138C10.5067 14.6947 11.1111 15.0351 12 15.0351C12.4622 15.0351 12.8444 14.8955 13.1467 14.6161C13.4667 14.3193 13.6267 13.9527 13.6267 13.5162C13.6267 12.5036 12.9067 12.0234 11.4667 12.0758C11.1467 12.0933 10.8889 12.0147 10.6933 11.8401C10.4978 11.6481 10.4 11.4036 10.4 11.1068C10.4 10.81 10.4889 10.5743 10.6667 10.3997C10.8622 10.2251 11.1022 10.1378 11.3867 10.1378C12.0267 10.1378 12.4711 10.0505 12.72 9.87595C12.9867 9.70136 13.12 9.39582 13.12 8.95934C13.12 8.61015 13.0044 8.357 12.7733 8.19986C12.5422 8.02527 12.2756 7.93797 11.9733 7.93797C11.6889 7.93797 11.4133 7.99908 11.1467 8.1213C10.88 8.24351 10.6667 8.4181 10.5067 8.64507C10.3822 8.81966 10.24 8.94188 10.08 9.01172C9.92 9.06409 9.75111 9.09028 9.57333 9.09028C9.27111 9.09028 8.99556 9.00299 8.74667 8.82839C8.51556 8.63634 8.4 8.39191 8.4 8.09511C8.4 7.97289 8.42667 7.85068 8.48 7.72846C8.76444 7.16977 9.21778 6.74202 9.84 6.44521C10.48 6.1484 11.1822 6 11.9467 6C12.9956 6 13.84 6.27062 14.48 6.81185C15.12 7.33563 15.44 8.034 15.44 8.90696C15.44 9.72754 15.1111 10.4172 14.4533 10.9759C14.9156 11.2028 15.2889 11.552 15.5733 12.0234C15.8578 12.4774 16 12.9575 16 13.4638C16 14.5288 15.6178 15.3931 14.8533 16.0565C14.1067 16.7025 13.1289 17.0168 11.92 16.9993Z\" fill=\"white\"/></svg>";
var number_4 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M13.2866 17C12.9463 17 12.6687 16.9127 12.4537 16.7381C12.2388 16.581 12.1313 16.3627 12.1313 16.0833V15.219C12.1313 14.9921 12.0149 14.8786 11.7821 14.8786H8.15522C7.79701 14.8786 7.51045 14.7476 7.29552 14.4857C7.09851 14.2238 7 13.9357 7 13.6214C7 13.4992 7.01791 13.377 7.05373 13.2548C7.08955 13.1325 7.14328 13.019 7.21493 12.9143L11.6209 6.60238C11.7642 6.39286 11.9701 6.24444 12.2388 6.15714C12.5254 6.05238 12.794 6 13.0448 6C13.4567 6 13.7881 6.12222 14.0388 6.36667C14.2896 6.59365 14.4239 6.88175 14.4418 7.23095V12.3119C14.4418 12.5389 14.5582 12.6524 14.791 12.6524H14.9522C15.2746 12.6524 15.5254 12.7484 15.7045 12.9405C15.9015 13.1325 16 13.4032 16 13.7524C16 14.0841 15.9015 14.3548 15.7045 14.5643C15.5254 14.7738 15.2746 14.8786 14.9522 14.8786H14.791C14.5582 14.8786 14.4418 14.9921 14.4418 15.219V16.0833C14.4418 16.3627 14.3343 16.581 14.1194 16.7381C13.9224 16.9127 13.6448 17 13.2866 17ZM10.1701 12.6524H11.9164C12.1493 12.6524 12.2657 12.5389 12.2657 12.3119V9.5881C12.2657 9.43095 12.194 9.35238 12.0507 9.35238C11.9791 9.35238 11.9164 9.39603 11.8627 9.48333L10.009 12.3381C9.97313 12.4079 9.95522 12.4603 9.95522 12.4952C9.95522 12.6 10.0269 12.6524 10.1701 12.6524Z\" fill=\"white\"/></svg>";
var number_5 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M11.531 17C11.0713 17 10.6023 16.9382 10.1241 16.8145C9.64598 16.6908 9.1954 16.4964 8.77241 16.2313C8.25747 15.9663 8 15.5775 8 15.0651C8 14.7647 8.11954 14.4908 8.35862 14.2434C8.5977 13.9783 8.86437 13.8458 9.15862 13.8458C9.45287 13.8458 9.71954 13.943 9.95862 14.1373C10.2529 14.3671 10.5563 14.5349 10.869 14.641C11.2 14.747 11.5126 14.8 11.8069 14.8C12.2851 14.8 12.6897 14.6675 13.0207 14.4024C13.3701 14.1197 13.5448 13.7133 13.5448 13.1831C13.5448 12.6177 13.3609 12.2289 12.9931 12.0169C12.6253 11.7871 12.1747 11.6723 11.6414 11.6723C11.3103 11.6723 10.9609 11.7076 10.5931 11.7783C10.2253 11.849 9.85747 11.9285 9.48966 12.0169C9.23218 12.0169 9.02069 11.9462 8.85517 11.8048C8.68966 11.6635 8.62529 11.4337 8.66207 11.1157L9.15862 7.35181C9.21379 6.89237 9.34253 6.5743 9.54483 6.39759C9.74713 6.20321 9.95862 6.08835 10.1793 6.05301C10.4184 6.01767 10.6391 6 10.8414 6C10.8598 6 10.869 6 10.869 6H14.2897C14.6575 6 14.9425 6.09719 15.1448 6.29157C15.3655 6.46827 15.4759 6.71566 15.4759 7.03374C15.4759 7.36948 15.3655 7.64337 15.1448 7.85542C14.9241 8.0498 14.6391 8.14699 14.2897 8.14699H11.7793C11.5034 8.14699 11.3379 8.27952 11.2828 8.54458L11.0621 9.92289C11.4299 9.7992 11.8345 9.73735 12.2759 9.73735C12.9195 9.73735 13.5172 9.87872 14.069 10.1614C14.6391 10.4442 15.0989 10.8329 15.4483 11.3277C15.8161 11.8225 16 12.3968 16 13.0506C16 13.8811 15.7885 14.5968 15.3655 15.1976C14.9425 15.7807 14.3908 16.2313 13.7103 16.5494C13.0299 16.8498 12.3034 17 11.531 17Z\" fill=\"white\"/></svg>";
var number_6 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M12 17C10.8089 17 9.84 16.6376 9.09333 15.9129C8.36444 15.171 8 14.2306 8 13.0918C8 12.0737 8.22222 11.0988 8.66667 10.1671C9.11111 9.23529 9.67111 8.41569 10.3467 7.70824C11.04 7.00078 11.7244 6.48314 12.4 6.15529C12.6133 6.05176 12.8178 6 13.0133 6C13.3511 6 13.6267 6.11216 13.84 6.33647C14.0533 6.56078 14.16 6.81098 14.16 7.08706C14.16 7.4149 14 7.68235 13.68 7.88941C13.4667 8.0102 13.1378 8.22588 12.6933 8.53647C12.2667 8.8298 11.8489 9.25255 11.44 9.80471C11.4222 9.82196 11.4222 9.84784 11.44 9.88235C11.4578 9.91686 11.4844 9.93412 11.52 9.93412C11.68 9.89961 11.8311 9.87373 11.9733 9.85647C12.1156 9.82196 12.2489 9.80471 12.3733 9.80471C13.0667 9.80471 13.6889 9.96 14.24 10.2706C14.7911 10.5812 15.2178 11.0039 15.52 11.5388C15.84 12.0737 16 12.6776 16 13.3506C16 14.4204 15.6178 15.3004 14.8533 15.9906C14.1067 16.6635 13.1556 17 12 17ZM11.9467 14.9294C12.48 14.9294 12.8978 14.7827 13.2 14.4894C13.52 14.1961 13.68 13.8078 13.68 13.3247C13.68 12.8243 13.52 12.4361 13.2 12.16C12.8978 11.8667 12.48 11.72 11.9467 11.72C11.4489 11.72 11.0489 11.8667 10.7467 12.16C10.4622 12.4361 10.32 12.8243 10.32 13.3247C10.32 13.8078 10.4622 14.1961 10.7467 14.4894C11.0489 14.7827 11.4489 14.9294 11.9467 14.9294Z\" fill=\"white\"/></svg>";
var number_7 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M10.7932 17C10.4859 17 10.1966 16.9028 9.92542 16.7084C9.67232 16.4964 9.54576 16.2225 9.54576 15.8867C9.54576 15.71 9.58192 15.551 9.65424 15.4096L13.0712 8.75663C13.1073 8.68594 13.1254 8.59759 13.1254 8.49157C13.1254 8.29719 12.9898 8.2 12.7186 8.2H9.22034C8.87684 8.2 8.58757 8.10281 8.35254 7.90843C8.11751 7.69639 8 7.43133 8 7.11325C8 6.77751 8.11751 6.51245 8.35254 6.31807C8.58757 6.10602 8.87684 6 9.22034 6H14.2102C14.7525 6 15.1864 6.14137 15.5119 6.4241C15.8373 6.70683 16 7.09558 16 7.59036C16 7.89076 15.9277 8.22651 15.7831 8.59759L11.9051 16.2313C11.7966 16.4964 11.6339 16.6908 11.4169 16.8145C11.2181 16.9382 11.0102 17 10.7932 17Z\" fill=\"white\"/></svg>";
var number_8 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M11.9869 17C10.7628 17 9.79235 16.6944 9.07541 16.0833C8.35847 15.4548 8 14.6254 8 13.5952C8 13.054 8.11366 12.5651 8.34098 12.1286C8.58579 11.6921 8.91803 11.3341 9.3377 11.0548C8.77814 10.496 8.49836 9.82381 8.49836 9.0381C8.49836 8.13016 8.82186 7.39683 9.46885 6.8381C10.1158 6.27937 10.9464 6 11.9607 6C12.9923 6 13.8404 6.2881 14.5049 6.86429C15.1694 7.44048 15.5016 8.16508 15.5016 9.0381C15.5016 9.84127 15.2131 10.5135 14.6361 11.0548C15.5454 11.6659 16 12.5127 16 13.5952C16 14.6254 15.6415 15.4548 14.9246 16.0833C14.2076 16.6944 13.2284 17 11.9869 17ZM11.9869 14.9833C12.529 14.9833 12.9574 14.8524 13.2721 14.5905C13.5869 14.3286 13.7443 13.9794 13.7443 13.5429C13.7443 13.0889 13.5869 12.731 13.2721 12.469C12.9574 12.2071 12.529 12.0762 11.9869 12.0762C11.4623 12.0762 11.0426 12.2071 10.7279 12.469C10.4131 12.731 10.2557 13.0889 10.2557 13.5429C10.2557 13.9794 10.4131 14.3286 10.7279 14.5905C11.0426 14.8524 11.4623 14.9833 11.9869 14.9833ZM11.9607 10.2167C12.3104 10.2167 12.6077 10.1032 12.8525 9.87619C13.1148 9.63175 13.2459 9.35238 13.2459 9.0381C13.2459 8.67143 13.1235 8.38333 12.8787 8.17381C12.6514 7.94683 12.3454 7.83333 11.9607 7.83333C11.5934 7.83333 11.2874 7.9381 11.0426 8.14762C10.8153 8.35714 10.7016 8.65397 10.7016 9.0381C10.7016 9.35238 10.824 9.63175 11.0689 9.87619C11.3137 10.1032 11.6109 10.2167 11.9607 10.2167Z\" fill=\"white\"/></svg>";
var number_9 = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#25282D\"/><path d=\"M10.9867 17C10.6489 17 10.3733 16.8878 10.16 16.6635C9.94667 16.4392 9.84 16.189 9.84 15.9129C9.84 15.5851 10 15.3176 10.32 15.1106C10.5156 14.9898 10.8444 14.7655 11.3067 14.4376C11.7867 14.1098 12.2222 13.7043 12.6133 13.2212C12.6489 13.1867 12.6489 13.1522 12.6133 13.1176C12.5956 13.0831 12.56 13.0745 12.5067 13.0918C12.2933 13.1435 12.1156 13.178 11.9733 13.1953C11.8311 13.1953 11.7156 13.1953 11.6267 13.1953C10.9333 13.1953 10.3111 13.04 9.76 12.7294C9.22667 12.4188 8.8 11.9961 8.48 11.4612C8.16 10.9263 8 10.3224 8 9.64941C8 8.57961 8.38222 7.70824 9.14667 7.03529C9.91111 6.3451 10.8622 6 12 6C13.2089 6 14.1778 6.37098 14.9067 7.11294C15.6356 7.83765 16 8.76941 16 9.90824C16 10.909 15.7778 11.8753 15.3333 12.8071C14.8889 13.7388 14.3289 14.5584 13.6533 15.2659C12.9778 15.9733 12.2933 16.4996 11.6 16.8447C11.3867 16.9482 11.1822 17 10.9867 17ZM12.0533 11.28C12.5689 11.28 12.9689 11.1333 13.2533 10.84C13.5378 10.5467 13.68 10.1584 13.68 9.67529C13.68 9.1749 13.5378 8.78667 13.2533 8.51059C12.9689 8.21726 12.5689 8.07059 12.0533 8.07059C11.52 8.07059 11.0933 8.21726 10.7733 8.51059C10.4711 8.78667 10.32 9.1749 10.32 9.67529C10.32 10.1584 10.4711 10.5467 10.7733 10.84C11.0933 11.1333 11.52 11.28 12.0533 11.28Z\" fill=\"white\"/></svg>";
var parcel = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5 11C8.94772 11 8.5 11.4477 8.5 12C8.5 12.5523 8.94772 13 9.5 13H14.5C15.0523 13 15.5 12.5523 15.5 12C15.5 11.4477 15.0523 11 14.5 11H9.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M22 8.48683C22 8.16439 21.948 7.84405 21.8461 7.53815L20.6838 4.05132C20.2754 2.82629 19.129 2 17.8377 2H6.16228C4.87099 2 3.72457 2.82629 3.31623 4.05132L2.15395 7.53815C2.05198 7.84405 2 8.16439 2 8.48683V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V8.48683ZM13 4H17.8377C18.2682 4 18.6503 4.27543 18.7864 4.68377L19.5585 7H13V4ZM4 9H20V19C20 19.5523 19.5523 20 19 20H5C4.44772 20 4 19.5523 4 19V9ZM11 7H4.44152L5.21359 4.68377C5.34971 4.27543 5.73185 4 6.16228 4H11V7Z\" fill=\"#25282D\"/></svg>";
var paymenrFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M23 17.5C23 19.1569 21.6569 20.5 20 20.5H4C2.34315 20.5 1 19.1569 1 17.5V10.5H23V17.5ZM15 14.5C14.4477 14.5 14 14.9477 14 15.5C14 16.0523 14.4477 16.5 15 16.5H18C18.5523 16.5 19 16.0523 19 15.5C19 14.9477 18.5523 14.5 18 14.5H15ZM20 3.5C21.6569 3.5 23 4.84315 23 6.5V8.5H1V6.5C1 4.84315 2.34315 3.5 4 3.5H20Z\" fill=\"#25282D\"/></svg>";
var paymentStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M20 5.5H4C3.44772 5.5 3 5.94772 3 6.5V17.5C3 18.0523 3.44772 18.5 4 18.5H20C20.5523 18.5 21 18.0523 21 17.5V6.5C21 5.94772 20.5523 5.5 20 5.5ZM4 3.5C2.34315 3.5 1 4.84315 1 6.5V17.5C1 19.1569 2.34315 20.5 4 20.5H20C21.6569 20.5 23 19.1569 23 17.5V6.5C23 4.84315 21.6569 3.5 20 3.5H4Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M1 9.5C1 8.94772 1.44772 8.5 2 8.5H22C22.5523 8.5 23 8.94772 23 9.5C23 10.0523 22.5523 10.5 22 10.5H2C1.44772 10.5 1 10.0523 1 9.5Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14 15.5C14 14.9477 14.4477 14.5 15 14.5L18 14.5C18.5523 14.5 19 14.9477 19 15.5C19 16.0523 18.5523 16.5 18 16.5L15 16.5C14.4477 16.5 14 16.0523 14 15.5Z\" fill=\"#25282D\"/></svg>";
var personFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.25 12C15.0114 12 17.25 9.76142 17.25 7C17.25 4.23858 15.0114 2 12.25 2C9.48858 2 7.25 4.23858 7.25 7C7.25 9.76142 9.48858 12 12.25 12Z\" fill=\"#25282D\"/><path d=\"M9.25 13C5.93629 13 3.25 15.6863 3.25 19V20C3.25 21.1046 4.14543 22 5.25 22H19.25C20.3546 22 21.25 21.1046 21.25 20V19C21.25 15.6863 18.5637 13 15.25 13H9.25Z\" fill=\"#25282D\"/></svg>";
var personStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17 7C17 9.76142 14.7614 12 12 12C9.23858 12 7 9.76142 7 7C7 4.23858 9.23858 2 12 2C14.7614 2 17 4.23858 17 7ZM15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3 19C3 15.6863 5.68629 13 9 13H15C18.3137 13 21 15.6863 21 19V20C21 21.1046 20.1046 22 19 22H5C3.89543 22 3 21.1046 3 20V19ZM5 19C5 16.7909 6.79086 15 9 15H15C17.2091 15 19 16.7909 19 19V20H5L5 19Z\" fill=\"#25282D\"/></svg>";
var print = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M21.8974 3H2.10264C1.49267 3 1 3.50133 1 4.12202V14.1963C1 14.817 1.49267 15.3183 2.10264 15.3183H5.41056V21H18.607V15.3183H21.8974C22.5073 15.3183 23 14.817 23 14.1963V4.11605C22.9941 3.50133 22.5015 3 21.8974 3ZM16.4076 18.75H7.60997V14.1844H16.4076V18.75ZM18.5953 11.9702H5.39883V9.7321H18.5953V11.9702ZM19.6979 7.47613C19.088 7.47613 18.5953 6.9748 18.5953 6.35411C18.5953 5.73342 19.088 5.2321 19.6979 5.2321C20.3079 5.2321 20.8006 5.73342 20.8006 6.35411C20.8006 6.9748 20.3021 7.47613 19.6979 7.47613Z\" fill=\"#25282D\"/></svg>";
var profileFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM5 17.5C5 18.2702 5.19348 18.9951 5.53448 19.629C6.19622 20.1903 6.93195 20.6672 7.72498 21.0427C7.84599 21.1001 7.96834 21.155 8.09196 21.2075C9.2925 21.7177 10.6133 22 12 22C13.5295 22 14.9788 21.6566 16.275 21.0427C17.0681 20.6672 17.8038 20.1904 18.4655 19.629C18.8065 18.9951 19 18.2702 19 17.5C19 15.0147 16.9853 13 14.5 13H9.5C7.01472 13 5 15.0147 5 17.5ZM16 8C16 10.2091 14.2091 12 12 12C9.79086 12 8 10.2091 8 8C8 5.79086 9.79086 4 12 4C14.2091 4 16 5.79086 16 8Z\" fill=\"#25282D\"/></svg>";
var profileStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 11C13.1046 11 14 10.1046 14 9C14 7.89543 13.1046 7 12 7C10.8954 7 10 7.89543 10 9C10 10.1046 10.8954 11 12 11ZM12 13C14.2091 13 16 11.2091 16 9C16 6.79086 14.2091 5 12 5C9.79086 5 8 6.79086 8 9C8 11.2091 9.79086 13 12 13Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21ZM12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.05317 18.5H5V20.4857C5.00579 20.4905 5.01158 20.4952 5.01738 20.5C6.91673 22.0621 9.34884 23 12 23C14.6512 23 17.0833 22.0621 18.9826 20.5C18.9884 20.4952 18.9942 20.4905 19 20.4857V18.5H18.9468C18.5829 15.9558 16.3949 14 13.75 14H10.25C7.60515 14 5.41709 15.9558 5.05317 18.5ZM17 19.014L16.967 18.7832C16.742 17.2101 15.3856 16 13.75 16H10.25C8.61443 16 7.25803 17.2101 7.03302 18.7832L7 19.014V19.4847C8.43 20.4424 10.148 21 12 21C13.852 21 15.57 20.4424 17 19.4847V19.014Z\" fill=\"#25282D\"/></svg>";
var qr = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><g clip-path=\"url(#clip0_118_1722)\"><path d=\"M19.9825 3.3079C20.1658 3.3079 20.3416 3.38083 20.4711 3.51066C20.6007 3.6405 20.6735 3.81658 20.6735 4.00019V8.23358C20.6735 8.41719 20.7463 8.59328 20.8759 8.72311C21.0055 8.85294 21.1813 8.92588 21.3646 8.92588H22.2859C22.4692 8.92588 22.645 8.85294 22.7746 8.72311C22.9042 8.59328 22.977 8.41719 22.977 8.23358V4.00019C22.977 3.20456 22.6615 2.44151 22.0999 1.87891C21.5383 1.31631 20.7767 1.00024 19.9825 1.00024H15.7569C15.5736 1.00024 15.3978 1.07318 15.2683 1.20301C15.1387 1.33284 15.0659 1.50893 15.0659 1.69254V2.6156C15.0659 2.79921 15.1387 2.9753 15.2683 3.10513C15.3978 3.23496 15.5736 3.3079 15.7569 3.3079H19.9825ZM3.99445 3.31251C3.81118 3.31251 3.63541 3.38545 3.50582 3.51528C3.37623 3.64511 3.30342 3.8212 3.30342 4.00481V8.23819C3.30342 8.4218 3.23062 8.59789 3.10103 8.72772C2.97143 8.85755 2.79567 8.93049 2.6124 8.93049H1.69103C1.50776 8.93049 1.33199 8.85755 1.2024 8.72772C1.0728 8.59789 1 8.4218 1 8.23819V4.00481C1 3.20917 1.31549 2.44612 1.87705 1.88352C2.43862 1.32092 3.20027 1.00486 3.99445 1.00486H8.22008C8.40335 1.00486 8.57912 1.0778 8.70871 1.20763C8.8383 1.33746 8.91111 1.51355 8.91111 1.69716V2.62022C8.91111 2.80382 8.8383 2.97991 8.70871 3.10974C8.57912 3.23957 8.40335 3.31251 8.22008 3.31251H3.99445ZM10.755 7.47205C10.755 7.28845 10.6822 7.11236 10.5526 6.98253C10.423 6.8527 10.2472 6.77976 10.064 6.77976H7.20773C7.02446 6.77976 6.84869 6.8527 6.7191 6.98253C6.5895 7.11236 6.5167 7.28845 6.5167 7.47205V10.3324C6.5167 10.516 6.5895 10.6921 6.7191 10.8219C6.84869 10.9517 7.02446 11.0247 7.20773 11.0247H10.064C10.2472 11.0247 10.423 10.9517 10.5526 10.8219C10.6822 10.6921 10.755 10.516 10.755 10.3324V7.47205ZM10.755 13.6404C10.755 13.4568 10.6822 13.2807 10.5526 13.1509C10.423 13.0211 10.2472 12.9481 10.064 12.9481H7.20773C7.02446 12.9481 6.84869 13.0211 6.7191 13.1509C6.5895 13.2807 6.5167 13.4568 6.5167 13.6404V16.5019C6.5167 16.6855 6.5895 16.8616 6.7191 16.9914C6.84869 17.1213 7.02446 17.1942 7.20773 17.1942H10.064C10.2472 17.1942 10.423 17.1213 10.5526 16.9914C10.6822 16.8616 10.755 16.6855 10.755 16.5019V13.6404ZM17.1827 7.47205C17.1827 7.28845 17.1099 7.11236 16.9803 6.98253C16.8507 6.8527 16.6749 6.77976 16.4917 6.77976H13.6377C13.4545 6.77976 13.2787 6.8527 13.1491 6.98253C13.0195 7.11236 12.9467 7.28845 12.9467 7.47205V10.3324C12.9467 10.516 13.0195 10.6921 13.1491 10.8219C13.2787 10.9517 13.4545 11.0247 13.6377 11.0247H16.4917C16.6749 11.0247 16.8507 10.9517 16.9803 10.8219C17.1099 10.6921 17.1827 10.516 17.1827 10.3324V7.47205ZM17.1827 13.6404C17.1827 13.4568 17.1099 13.2807 16.9803 13.1509C16.8507 13.0211 16.6749 12.9481 16.4917 12.9481H13.6377C13.4545 12.9481 13.2787 13.0211 13.1491 13.1509C13.0195 13.2807 12.9467 13.4568 12.9467 13.6404V16.5019C12.9467 16.6855 13.0195 16.8616 13.1491 16.9914C13.2787 17.1213 13.4545 17.1942 13.6377 17.1942H16.4917C16.6749 17.1942 16.8507 17.1213 16.9803 16.9914C17.1099 16.8616 17.1827 16.6855 17.1827 16.5019V13.6404ZM20.6966 20.0003C20.6966 20.1839 20.6238 20.36 20.4942 20.4898C20.3646 20.6197 20.1888 20.6926 20.0055 20.6926H15.7799C15.5966 20.6926 15.4209 20.7655 15.2913 20.8954C15.1617 21.0252 15.0889 21.2013 15.0889 21.3849V22.308C15.0889 22.4916 15.1617 22.6676 15.2913 22.7975C15.4209 22.9273 15.5966 23.0002 15.7799 23.0002H20.0055C20.3988 23.0002 20.7882 22.9227 21.1515 22.7719C21.5148 22.6211 21.8449 22.4002 22.1229 22.1216C22.401 21.843 22.6216 21.5123 22.7721 21.1483C22.9225 20.7844 23 20.3943 23 20.0003V15.7669C23 15.5833 22.9272 15.4072 22.7976 15.2774C22.668 15.1476 22.4922 15.0746 22.309 15.0746H21.3876C21.2043 15.0746 21.0286 15.1476 20.899 15.2774C20.7694 15.4072 20.6966 15.5833 20.6966 15.7669V20.0003ZM3.34373 20.0003C3.34373 20.1839 3.41654 20.36 3.54613 20.4898C3.67572 20.6197 3.85149 20.6926 4.03476 20.6926H8.26039C8.44366 20.6926 8.61943 20.7655 8.74902 20.8954C8.87861 21.0252 8.95142 21.2013 8.95142 21.3849V22.308C8.95142 22.4916 8.87861 22.6676 8.74902 22.7975C8.61943 22.9273 8.44366 23.0002 8.26039 23.0002H4.03476C3.64152 23.0002 3.25214 22.9227 2.88883 22.7719C2.52553 22.6211 2.19542 22.4002 1.91736 22.1216C1.6393 21.843 1.41873 21.5123 1.26825 21.1483C1.11776 20.7844 1.04031 20.3943 1.04031 20.0003V15.7669C1.04031 15.5833 1.11311 15.4072 1.24271 15.2774C1.3723 15.1476 1.54807 15.0746 1.73134 15.0746H2.65271C2.83598 15.0746 3.01174 15.1476 3.14134 15.2774C3.27093 15.4072 3.34373 15.5833 3.34373 15.7669V20.0003Z\" fill=\"#25282D\"/></g><defs><clipPath id=\"clip0_118_1722\"><rect width=\"24\" height=\"24\" fill=\"white\"/></clipPath></defs></svg>";
var questionFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 15.25C11.3096 15.25 10.75 15.8096 10.75 16.5C10.75 17.1904 11.3096 17.75 12 17.75C12.6904 17.75 13.25 17.1904 13.25 16.5C13.25 15.8096 12.6904 15.25 12 15.25ZM12 6.25C10.0184 6.25004 8.50098 7.62968 8.50098 9.5C8.50098 10.0523 8.94869 10.5 9.50098 10.5C10.0533 10.5 10.501 10.0523 10.501 9.5C10.501 8.87036 10.9818 8.25003 12 8.25C13.0166 8.25 13.5 8.87587 13.5 9.5C13.5 9.82293 13.3374 10.0541 12.834 10.5039C12.6724 10.6483 12.5157 10.7604 12.3408 10.8818C12.3265 10.8918 12.3114 10.9024 12.2959 10.9131C12.1422 11.0194 11.936 11.1623 11.7559 11.3291C11.535 11.5336 11.3282 11.793 11.1875 12.1445C11.0518 12.4839 11 12.8529 11 13.25C11 13.8023 11.4478 14.25 12 14.25C12.5523 14.25 13 13.8023 13 13.25C13 13.0223 13.0307 12.9222 13.0449 12.8867C13.0542 12.8635 13.0654 12.8411 13.1143 12.7959C13.1858 12.7296 13.2784 12.6654 13.4814 12.5244C13.6665 12.3959 13.908 12.2266 14.166 11.9961C14.6624 11.5527 15.5 10.7887 15.5 9.5C15.5 7.63817 13.9832 6.25 12 6.25Z\" fill=\"#25282D\"/></svg>";
var questionStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.0001 8.25C10.9818 8.25 10.501 8.87034 10.501 9.5C10.501 10.0523 10.0533 10.5 9.50098 10.5C8.94869 10.5 8.50098 10.0523 8.50098 9.5C8.50098 7.62966 10.0185 6.25 12.0001 6.25C13.9833 6.25 15.5001 7.63817 15.5001 9.5C15.5001 10.7887 14.6626 11.5524 14.1662 11.9958C13.9081 12.2264 13.667 12.3959 13.4819 12.5245C13.2786 12.6656 13.1862 12.73 13.1146 12.7963C13.0654 12.8418 13.0542 12.8638 13.0448 12.8871C13.0306 12.9226 13.0001 13.0223 13.0001 13.25C13.0001 13.8023 12.5524 14.25 12.0001 14.25C11.4478 14.25 11.0001 13.8023 11.0001 13.25C11.0001 12.8527 11.0521 12.4837 11.188 12.1441C11.3287 11.7925 11.535 11.5332 11.7559 11.3287C11.936 11.1619 12.1423 11.0192 12.296 10.913L12.341 10.8818C12.5159 10.7603 12.6722 10.6486 12.8338 10.5042C13.3374 10.0543 13.5001 9.82299 13.5001 9.5C13.5001 8.87587 13.0167 8.25 12.0001 8.25Z\" fill=\"#25282D\"/><path d=\"M12 15.25C11.3096 15.25 10.75 15.8096 10.75 16.5C10.75 17.1904 11.3096 17.75 12 17.75C12.6904 17.75 13.25 17.1904 13.25 16.5C13.25 15.8096 12.6904 15.25 12 15.25Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z\" fill=\"#25282D\"/></svg>";
var radioResting = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 21.5C17.2467 21.5 21.5 17.2467 21.5 12C21.5 6.75329 17.2467 2.5 12 2.5C6.75329 2.5 2.5 6.75329 2.5 12C2.5 17.2467 6.75329 21.5 12 21.5ZM12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23Z\" fill=\"#25282D\"/></svg>";
var radioSelected = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 21.5C17.2467 21.5 21.5 17.2467 21.5 12C21.5 6.75329 17.2467 2.5 12 2.5C6.75329 2.5 2.5 6.75329 2.5 12C2.5 17.2467 6.75329 21.5 12 21.5ZM12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23Z\" fill=\"#25282D\"/><path d=\"M19 12C19 15.866 15.866 19 12 19C8.13401 19 5 15.866 5 12C5 8.13401 8.13401 5 12 5C15.866 5 19 8.13401 19 12Z\" fill=\"#25282D\"/></svg>";
var receipt = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8 6C7.44772 6 7 6.44772 7 7C7 7.55228 7.44772 8 8 8L16 8C16.5523 8 17 7.55228 17 7C17 6.44771 16.5523 6 16 6L8 6Z\" fill=\"#25282D\"/><path d=\"M7 11C7 10.4477 7.44772 10 8 10L16 10C16.5523 10 17 10.4477 17 11C17 11.5523 16.5523 12 16 12L8 12C7.44772 12 7 11.5523 7 11Z\" fill=\"#25282D\"/><path d=\"M8 14C7.44772 14 7 14.4477 7 15C7 15.5523 7.44772 16 8 16H13C13.5523 16 14 15.5523 14 15C14 14.4477 13.5523 14 13 14H8Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M18 23C18.0756 23 18.1505 22.9972 18.2247 22.9917C18.3157 22.9972 18.4075 23 18.5 23C20.9853 23 23 20.9853 23 18.5C23 16.9398 22.206 15.565 21 14.7578V4C21 2.34315 19.6569 1 18 1H6C4.34315 1 3 2.34315 3 4V20C3 21.6569 4.34315 23 6 23H18ZM14 18.5C14 19.4251 14.2791 20.285 14.7578 21H6C5.44772 21 5 20.5523 5 20V4C5 3.44772 5.44772 3 6 3H18C18.5523 3 19 3.44772 19 4V14.0275C18.8358 14.0093 18.669 14 18.5 14C16.0147 14 14 16.0147 14 18.5ZM18.5 16C19.8402 16 20.9341 17.0545 20.9971 18.3791C20.999 18.4191 21 18.4595 21 18.5C21 19.8807 19.8807 21 18.5 21C17.1193 21 16 19.8807 16 18.5C16 17.1193 17.1193 16 18.5 16Z\" fill=\"#25282D\"/></svg>";
var reload = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M21 11C20.4 11 20 11.4 20 12C20 14.9 18.5 17.5 16 18.9C12.2 21.1 7.3 19.8 5.1 16C2.9 12.2 4.2 7.3 8 5.1C11.3 3.2 15.3 3.9 17.8 6.5H15.4C14.8 6.5 14.4 6.9 14.4 7.5C14.4 8.1 14.8 8.5 15.4 8.5H19.9C20.5 8.5 20.9 8.1 20.9 7.5V3C20.9 2.4 20.5 2 19.9 2C19.3 2 18.9 2.4 18.9 3V4.8C17 3 14.6 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12C22 11.4 21.6 11 21 11Z\" fill=\"#25282D\"/></svg>";
var reset = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.91 15.51H15.38C15.1148 15.51 14.8604 15.6154 14.6729 15.8029C14.4854 15.9904 14.38 16.2448 14.38 16.51C14.38 16.7752 14.4854 17.0296 14.6729 17.2171C14.8604 17.4046 15.1148 17.51 15.38 17.51H17.78C16.6769 18.6627 15.2544 19.4593 13.6952 19.7974C12.1359 20.1355 10.5112 19.9996 9.02978 19.4072C7.54834 18.8149 6.27787 17.7931 5.38159 16.4732C4.48531 15.1532 4.00418 13.5955 4 12C4 11.7348 3.89464 11.4804 3.70711 11.2929C3.51957 11.1054 3.26522 11 3 11C2.73478 11 2.48043 11.1054 2.29289 11.2929C2.10536 11.4804 2 11.7348 2 12C2.00529 13.9528 2.58222 15.8613 3.6596 17.49C4.73699 19.1187 6.26767 20.3964 8.06274 21.1652C9.85782 21.9341 11.8387 22.1605 13.761 21.8166C15.6833 21.4727 17.4628 20.5735 18.88 19.23V21C18.88 21.2652 18.9854 21.5196 19.1729 21.7071C19.3604 21.8946 19.6148 22 19.88 22C20.1452 22 20.3996 21.8946 20.5871 21.7071C20.7746 21.5196 20.88 21.2652 20.88 21V16.5C20.8775 16.2416 20.7752 15.9943 20.5943 15.8097C20.4135 15.6251 20.1683 15.5177 19.91 15.51ZM12 2C9.43639 2.00731 6.97349 2.99891 5.12 4.77V3C5.12 2.73478 5.01464 2.48043 4.82711 2.29289C4.63957 2.10536 4.38522 2 4.12 2C3.85478 2 3.60043 2.10536 3.41289 2.29289C3.22536 2.48043 3.12 2.73478 3.12 3V7.5C3.12 7.76522 3.22536 8.01957 3.41289 8.20711C3.60043 8.39464 3.85478 8.5 4.12 8.5H8.62C8.88522 8.5 9.13957 8.39464 9.32711 8.20711C9.51464 8.01957 9.62 7.76522 9.62 7.5C9.62 7.23478 9.51464 6.98043 9.32711 6.79289C9.13957 6.60536 8.88522 6.5 8.62 6.5H6.22C7.32247 5.34787 8.74409 4.5515 10.3024 4.21311C11.8607 3.87472 13.4846 4.00975 14.9656 4.60086C16.4466 5.19198 17.7172 6.21221 18.6142 7.5306C19.5113 8.849 19.9938 10.4054 20 12C20 12.2652 20.1054 12.5196 20.2929 12.7071C20.4804 12.8946 20.7348 13 21 13C21.2652 13 21.5196 12.8946 21.7071 12.7071C21.8946 12.5196 22 12.2652 22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7362 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2Z\" fill=\"#25282D\"/></svg>";
var search = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.9057 16.3198C13.551 17.3729 11.8488 18 10 18C5.58172 18 2 14.4183 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 11.8487 17.3729 13.5509 16.3199 14.9056L21.7071 20.2927C22.0976 20.6833 22.0976 21.3164 21.7071 21.707C21.3166 22.0975 20.6834 22.0975 20.2929 21.707L14.9057 16.3198ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z\" fill=\"#25282D\"/></svg>";
var settingsFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.0491 2.63648C10.5187 0.557371 13.4813 0.557371 13.9509 2.63648L14.0071 2.8855C14.3115 4.23284 15.8577 4.87336 17.0256 4.13599L17.2415 3.99976C19.0437 2.86169 21.1383 4.95631 20.0003 6.75855L19.864 6.97437C19.1267 8.14235 19.7672 9.68851 21.1145 9.99293L21.3635 10.0491C23.4426 10.5187 23.4426 13.4813 21.3635 13.9509L21.1145 14.0071C19.7672 14.3115 19.1267 15.8577 19.864 17.0256L20.0003 17.2415C21.1383 19.0437 19.0437 21.1383 17.2415 20.0003L17.0256 19.864C15.8577 19.1267 14.3115 19.7672 14.0071 21.1145L13.9509 21.3635C13.4813 23.4426 10.5187 23.4426 10.0491 21.3635L9.99293 21.1145C9.68851 19.7672 8.14235 19.1267 6.97437 19.864L6.75855 20.0003C4.95631 21.1383 2.86169 19.0437 3.99976 17.2415L4.13599 17.0256C4.87336 15.8577 4.23284 14.3115 2.8855 14.0071L2.63648 13.9509C0.557371 13.4813 0.557371 10.5187 2.63648 10.0491L2.8855 9.99293C4.23284 9.68852 4.87337 8.14236 4.13599 6.97437L3.99976 6.75855C2.86169 4.95631 4.95631 2.86169 6.75855 3.99976L6.97437 4.13599C8.14236 4.87337 9.68852 4.23284 9.99293 2.8855L10.0491 2.63648ZM12.0003 8.00025C9.79111 8.00025 8.00025 9.79111 8.00025 12.0003C8.00038 14.2093 9.79119 16.0003 12.0003 16.0003C14.2092 16.0001 16.0001 14.2092 16.0003 12.0003C16.0003 9.79119 14.2093 8.00038 12.0003 8.00025Z\" fill=\"#25282D\"/></svg>";
var settingsStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17 12C17 14.7614 14.7614 17 12 17C9.23858 17 7 14.7614 7 12C7 9.23858 9.23858 7 12 7C14.7614 7 17 9.23858 17 12ZM15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.8026 3.36917C14.1279 0.382149 9.87183 0.382152 9.19711 3.36917C9.06419 3.95759 8.38895 4.23729 7.87889 3.9152C5.28964 2.28015 2.28016 5.28964 3.9152 7.87889C4.23729 8.38895 3.95759 9.06419 3.36917 9.19711C0.382149 9.87183 0.382152 14.1279 3.36917 14.8026C3.95759 14.9355 4.23729 15.6108 3.9152 16.1208C2.28016 18.7101 5.28964 21.7196 7.87889 20.0845C8.38895 19.7624 9.06419 20.0421 9.19711 20.6305C9.87183 23.6176 14.1279 23.6176 14.8026 20.6305C14.9355 20.0421 15.6108 19.7624 16.1208 20.0845C18.7101 21.7196 21.7196 18.7101 20.0845 16.1208C19.7624 15.6108 20.0421 14.9355 20.6305 14.8026C23.6176 14.1279 23.6176 9.87183 20.6305 9.19711C20.0421 9.06419 19.7624 8.38895 20.0845 7.87889C21.7196 5.28964 18.7101 2.28016 16.1208 3.9152C15.6108 4.23729 14.9355 3.95759 14.8026 3.36917ZM11.148 3.80984C11.353 2.90193 12.6467 2.90193 12.8518 3.80984C13.289 5.74573 15.5106 6.66593 17.1887 5.60626C17.9757 5.10928 18.8904 6.02402 18.3935 6.81103C17.3338 8.48912 18.254 10.7107 20.1899 11.148C21.0978 11.353 21.0978 12.6467 20.1899 12.8518C18.254 13.289 17.3338 15.5106 18.3935 17.1887C18.8904 17.9757 17.9757 18.8904 17.1887 18.3935C15.5106 17.3338 13.289 18.254 12.8518 20.1899C12.6467 21.0978 11.353 21.0978 11.148 20.1899C10.7107 18.254 8.48912 17.3338 6.81103 18.3935C6.02402 18.8904 5.10928 17.9757 5.60626 17.1887C6.66593 15.5106 5.74573 13.289 3.80984 12.8518C2.90193 12.6467 2.90193 11.353 3.80984 11.148C5.74573 10.7107 6.66593 8.48912 5.60626 6.81103C5.10928 6.02402 6.02402 5.10928 6.81103 5.60626C8.48912 6.66593 10.7107 5.74574 11.148 3.80984Z\" fill=\"#25282D\"/></svg>";
var shareIos = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 10C15 10.5523 15.4477 11 16 11H18C18.5523 11 19 11.4477 19 12V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V12C5 11.4477 5.44772 11 6 11H8C8.55228 11 9 10.5523 9 10C9 9.44772 8.55228 9 8 9H6C4.34315 9 3 10.3431 3 12V20C3 21.6569 4.34315 23 6 23H18C19.6569 23 21 21.6569 21 20V12C21 10.3431 19.6569 9 18 9H16C15.4477 9 15 9.44772 15 10Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.2929 1.29289C11.6834 0.902369 12.3166 0.902369 12.7071 1.29289L16.7071 5.29289C17.0976 5.68342 17.0976 6.31658 16.7071 6.70711C16.3166 7.09763 15.6834 7.09763 15.2929 6.70711L13 4.41421V14.5C13 15.0523 12.5523 15.5 12 15.5C11.4477 15.5 11 15.0523 11 14.5V4.41421L8.70711 6.70711C8.31658 7.09763 7.68342 7.09763 7.29289 6.70711C6.90237 6.31658 6.90237 5.68342 7.29289 5.29289L11.2929 1.29289Z\" fill=\"#25282D\"/></svg>";
var sound = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.4999 16.0956C16.3476 16.0954 16.1991 16.0488 16.0739 15.9621C15.9488 15.8754 15.853 15.7527 15.7992 15.6102C15.7455 15.4678 15.7364 15.3124 15.7731 15.1646C15.8099 15.0169 15.8907 14.8838 16.0049 14.7831C16.394 14.4315 16.7051 14.0022 16.918 13.5229C17.1309 13.0436 17.2409 12.525 17.2409 12.0006C17.2409 11.4761 17.1309 10.9575 16.918 10.4782C16.7051 9.99896 16.394 9.56967 16.0049 9.21808C15.931 9.15258 15.8708 9.07318 15.8276 8.9844C15.7844 8.89562 15.7592 8.7992 15.7532 8.70066C15.7413 8.50164 15.8089 8.30601 15.9411 8.15683C16.0734 8.00765 16.2595 7.91712 16.4586 7.90516C16.6576 7.89321 16.8532 7.9608 17.0024 8.09308C17.5511 8.58545 17.99 9.18787 18.2904 9.86112C18.5909 10.5344 18.7461 11.2633 18.7461 12.0006C18.7461 12.7378 18.5909 13.4668 18.2904 14.14C17.99 14.8133 17.5511 15.4157 17.0024 15.9081C16.8637 16.0304 16.6848 16.0972 16.4999 16.0956Z\" fill=\"#25282D\"/><path d=\"M19.1627 18.7503C19.0125 18.7498 18.8659 18.7042 18.7419 18.6194C18.6179 18.5346 18.5222 18.4145 18.4673 18.2747C18.4123 18.1349 18.4006 17.9818 18.4337 17.8352C18.4667 17.6887 18.543 17.5555 18.6527 17.4528C19.3949 16.7518 19.9862 15.9066 20.3904 14.969C20.7945 14.0315 21.0029 13.0213 21.0029 12.0003C21.0029 10.9794 20.7945 9.96915 20.3904 9.03158C19.9862 8.09402 19.3949 7.24883 18.6527 6.54781C18.5808 6.48034 18.5229 6.39937 18.4823 6.30953C18.4417 6.21968 18.4192 6.12272 18.416 6.02417C18.4129 5.92563 18.4292 5.82743 18.464 5.73518C18.4988 5.64294 18.5515 5.55846 18.619 5.48656C18.6864 5.41466 18.7674 5.35675 18.8572 5.31615C18.9471 5.27554 19.044 5.25303 19.1426 5.24989C19.2411 5.24676 19.3393 5.26306 19.4316 5.29788C19.5238 5.3327 19.6083 5.38534 19.6802 5.45281C20.5723 6.29415 21.2831 7.30891 21.7689 8.43483C22.2546 9.56075 22.5052 10.7741 22.5052 12.0003C22.5052 13.2266 22.2546 14.4399 21.7689 15.5658C21.2831 16.6917 20.5723 17.7065 19.6802 18.5478C19.54 18.6791 19.3548 18.7516 19.1627 18.7503Z\" fill=\"#25282D\"/><path d=\"M11.7942 4.57573C12.9942 3.87692 14.5 4.74256 14.5 6.1312V17.8688C14.5 19.2574 12.9942 20.1231 11.7942 19.4242L5.39417 15.6972C4.84053 15.3748 4.5 14.7824 4.5 14.1417V9.85826C4.5 9.21759 4.84054 8.6252 5.39417 8.30279L11.7942 4.57573Z\" fill=\"#25282D\"/><path d=\"M1.5 9.5C1.5 8.39543 2.39543 7.5 3.5 7.5H7.5C8.60457 7.5 9.5 8.39543 9.5 9.5V14.5C9.5 15.6046 8.60457 16.5 7.5 16.5H3.5C2.39543 16.5 1.5 15.6046 1.5 14.5V9.5Z\" fill=\"#25282D\"/></svg>";
var switchCircleFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C9.82441 1 7.69767 1.64514 5.88873 2.85383C4.07979 4.06253 2.66989 5.7805 1.83733 7.79048C1.00477 9.80047 0.786929 12.0122 1.21137 14.146C1.6358 16.2798 2.68345 18.2398 4.22183 19.7782C5.76021 21.3166 7.72022 22.3642 9.85401 22.7886C11.9878 23.2131 14.1995 22.9952 16.2095 22.1627C18.2195 21.3301 19.9375 19.9202 21.1462 18.1113C22.3549 16.3023 23 14.1756 23 12C23 9.08262 21.8411 6.28473 19.7782 4.22183C17.7153 2.15893 14.9174 1 12 1ZM12 16H8.41L9.71 17.29C9.80373 17.383 9.87813 17.4936 9.9289 17.6154C9.97966 17.7373 10.0058 17.868 10.0058 18C10.0058 18.132 9.97966 18.2627 9.9289 18.3846C9.87813 18.5064 9.80373 18.617 9.71 18.71C9.61704 18.8037 9.50644 18.8781 9.38458 18.9289C9.26272 18.9797 9.13202 19.0058 9 19.0058C8.86799 19.0058 8.73729 18.9797 8.61543 18.9289C8.49357 18.8781 8.38297 18.8037 8.29 18.71L5.29 15.71C5.20626 15.6245 5.14151 15.5223 5.10001 15.41C5.03274 15.2839 4.99834 15.1429 5 15V14.9C5.00594 14.8149 5.02274 14.7309 5.05 14.65C5.04441 14.6169 5.04441 14.5831 5.05 14.55C5.09493 14.4395 5.15928 14.3379 5.24 14.25L8.24 11.25C8.42831 11.0617 8.6837 10.9559 8.95 10.9559C9.21631 10.9559 9.4717 11.0617 9.66 11.25C9.84831 11.4383 9.9541 11.6937 9.9541 11.96C9.9541 12.2263 9.84831 12.4817 9.66 12.67L8.41 14H12C12.2652 14 12.5196 14.1054 12.7071 14.2929C12.8946 14.4804 13 14.7348 13 15C13 15.2652 12.8946 15.5196 12.7071 15.7071C12.5196 15.8946 12.2652 16 12 16ZM19 9.06C19.0105 9.14301 19.0105 9.227 19 9.31C19.0056 9.3431 19.0056 9.3769 19 9.41C18.9551 9.52053 18.8907 9.62214 18.81 9.71L15.81 12.71C15.717 12.8037 15.6064 12.8781 15.4846 12.9289C15.3627 12.9797 15.232 13.0058 15.1 13.0058C14.968 13.0058 14.8373 12.9797 14.7154 12.9289C14.5936 12.8781 14.483 12.8037 14.39 12.71C14.2963 12.617 14.2219 12.5064 14.1711 12.3846C14.1203 12.2627 14.0942 12.132 14.0942 12C14.0942 11.868 14.1203 11.7373 14.1711 11.6154C14.2219 11.4936 14.2963 11.383 14.39 11.29L15.59 10H12C11.7348 10 11.4804 9.89464 11.2929 9.70711C11.1054 9.51957 11 9.26522 11 9C11 8.73478 11.1054 8.48043 11.2929 8.29289C11.4804 8.10536 11.7348 8 12 8H15.59L14.29 6.71C14.1968 6.61676 14.1228 6.50607 14.0723 6.38425C14.0219 6.26243 13.9959 6.13186 13.9959 6C13.9959 5.7337 14.1017 5.4783 14.29 5.29C14.4783 5.1017 14.7337 4.99591 15 4.99591C15.1319 4.99591 15.2624 5.02188 15.3843 5.07234C15.5061 5.1228 15.6168 5.19676 15.71 5.29L18.71 8.29C18.7938 8.37551 18.8585 8.47774 18.9 8.59C18.9673 8.71609 19.0017 8.8571 19 9V9.06Z\" fill=\"#25282D\"/></svg>";
var switchCircleStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C9.82441 1 7.69767 1.64514 5.88873 2.85383C4.07979 4.06253 2.66989 5.7805 1.83733 7.79048C1.00477 9.80047 0.786929 12.0122 1.21137 14.146C1.6358 16.2798 2.68345 18.2398 4.22183 19.7782C5.76021 21.3166 7.72022 22.3642 9.85401 22.7886C11.9878 23.2131 14.1995 22.9952 16.2095 22.1627C18.2195 21.3301 19.9375 19.9202 21.1462 18.1113C22.3549 16.3023 23 14.1756 23 12C23 9.08262 21.8411 6.28473 19.7782 4.22183C17.7153 2.15893 14.9174 1 12 1ZM12 21C10.22 21 8.47991 20.4722 6.99987 19.4832C5.51983 18.4943 4.36628 17.0887 3.68509 15.4442C3.0039 13.7996 2.82567 11.99 3.17294 10.2442C3.5202 8.49836 4.37737 6.89471 5.63604 5.63604C6.89472 4.37737 8.49836 3.5202 10.2442 3.17293C11.99 2.82567 13.7996 3.0039 15.4442 3.68508C17.0887 4.36627 18.4943 5.51982 19.4832 6.99987C20.4722 8.47991 21 10.22 21 12C21 14.3869 20.0518 16.6761 18.364 18.364C16.6761 20.0518 14.387 21 12 21Z\" fill=\"#25282D\"/><path d=\"M18.94 9.31004C18.9505 9.22703 18.9505 9.14304 18.94 9.06004V9.00004C18.9396 8.89387 18.9192 8.78872 18.88 8.69004C18.8385 8.57778 18.7738 8.47555 18.69 8.39004L15.69 5.39004C15.5968 5.2968 15.4861 5.22284 15.3643 5.17238C15.2425 5.12192 15.1119 5.09595 14.98 5.09595C14.8482 5.09595 14.7176 5.12192 14.5958 5.17238C14.474 5.22284 14.3633 5.2968 14.27 5.39004C14.1768 5.48328 14.1028 5.59397 14.0524 5.71579C14.0019 5.83761 13.976 5.96818 13.976 6.10004C13.976 6.2319 14.0019 6.36247 14.0524 6.48429C14.1028 6.60611 14.1768 6.7168 14.27 6.81004L15.59 8.00004H12C11.7348 8.00004 11.4805 8.1054 11.2929 8.29293C11.1054 8.48047 11 8.73482 11 9.00004C11 9.26526 11.1054 9.51961 11.2929 9.70715C11.4805 9.89468 11.7348 10 12 10H15.59L14.29 11.29C14.1963 11.383 14.1219 11.4936 14.0712 11.6155C14.0204 11.7373 13.9943 11.868 13.9943 12C13.9943 12.1321 14.0204 12.2628 14.0712 12.3846C14.1219 12.5065 14.1963 12.6171 14.29 12.71C14.383 12.8038 14.4936 12.8782 14.6155 12.9289C14.7373 12.9797 14.868 13.0058 15 13.0058C15.1321 13.0058 15.2628 12.9797 15.3846 12.9289C15.5065 12.8782 15.6171 12.8038 15.71 12.71L18.71 9.71004C18.7908 9.62218 18.8551 9.52057 18.9 9.41004C18.9193 9.37939 18.9329 9.34551 18.94 9.31004ZM12 14H8.41005L9.71005 12.71C9.89835 12.5217 10.0041 12.2663 10.0041 12C10.0041 11.7337 9.89835 11.4783 9.71005 11.29C9.52174 11.1017 9.26635 10.9959 9.00005 10.9959C8.73375 10.9959 8.47835 11.1017 8.29005 11.29L5.29005 14.29C5.20932 14.3779 5.14498 14.4795 5.10005 14.59C5.09445 14.6231 5.09445 14.6569 5.10005 14.69C5.07278 14.7709 5.05598 14.8549 5.05005 14.94V15C5.05051 15.1062 5.07086 15.2114 5.11005 15.31C5.15155 15.4223 5.2163 15.5245 5.30005 15.61L8.30005 18.61C8.39301 18.7038 8.50361 18.7782 8.62547 18.8289C8.74733 18.8797 8.87804 18.9058 9.01005 18.9058C9.14206 18.9058 9.27277 18.8797 9.39463 18.8289C9.51648 18.7782 9.62709 18.7038 9.72005 18.61C9.81378 18.5171 9.88817 18.4065 9.93894 18.2846C9.98971 18.1628 10.0158 18.0321 10.0158 17.9C10.0158 17.768 9.98971 17.6373 9.93894 17.5155C9.88817 17.3936 9.81378 17.283 9.72005 17.19L8.41005 16H12C12.2653 16 12.5196 15.8947 12.7072 15.7071C12.8947 15.5196 13 15.2653 13 15C13 14.7348 12.8947 14.4805 12.7072 14.2929C12.5196 14.1054 12.2653 14 12 14Z\" fill=\"#25282D\"/></svg>";
var timeFilled = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM12 6.25C11.4477 6.25 11 6.69772 11 7.25V12C11 12.2652 11.1054 12.5195 11.293 12.707L14.6514 16.0654C15.0419 16.4559 15.6759 16.456 16.0664 16.0654C16.4566 15.675 16.4566 15.0418 16.0664 14.6514L13 11.5859V7.25C13 6.69772 12.5523 6.25 12 6.25Z\" fill=\"#25282D\"/></svg>";
var timeStroke = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21ZM12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 6.25C12.5523 6.25 13 6.69772 13 7.25L13 12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12L11 7.25C11 6.69772 11.4477 6.25 12 6.25Z\" fill=\"#25282D\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16.0663 16.0655C15.6758 16.456 15.0426 16.456 14.6521 16.0655L11.2934 12.7067C10.9028 12.3162 10.9028 11.6831 11.2934 11.2925C11.6839 10.902 12.317 10.902 12.7076 11.2925L16.0663 14.6513C16.4569 15.0418 16.4569 15.675 16.0663 16.0655Z\" fill=\"#25282D\"/></svg>";
var iconMap = {
  lock: Lock,
  new: New,
  truncation: Truncation,
  add: add,
  'add-circle-filled': addCircleFilled,
  'add-circle-stroke': addCircleStroke,
  'arrow-down': arrowDown,
  'arrow-left': arrowLeft,
  'arrow-right': arrowRight,
  'arrow-up': arrowUp,
  'bell-filled': bellFilled,
  'bell-stroke': bellStroke,
  'bookmark-filled': bookmarkFilled,
  'bookmark-stroke': bookmarkStroke,
  'calendar-filled': calendarFilled,
  calendar: calendar,
  'calendar-stroke': calendarStroke,
  'call-filled': callFilled,
  'call-stroke': callStroke,
  'camera-filled': cameraFilled,
  'camera-stroke': cameraStorke,
  'cancel-filled': cancelFilled,
  'cancel-stroke': cancelStroke,
  'caution-filled': cautionFilled,
  'caution-stroke': cautionStroke,
  check: check,
  'check-circle-filled': checkCircleFilled,
  'check-circle-stroke': checkCircleStroke,
  'checkbox-resting': checkboxResting,
  'checkbox-selected-filled': checkboxSelectedFilled,
  'checkbox-selected-stroke': checkboxSelectedStroke,
  'chevron-down': chevronDown,
  'chevron-left': chevronLeft,
  'chevron-right': chevronRight,
  'chevron-up': chevronUp,
  close: close,
  'customer-service': customerService,
  'dashboard-filled': dashboardFilled,
  'dashboard-stroke': dashboardStroke,
  'delete-filled': deleteFilled,
  'delete-stroke': deleteStroke,
  dialog: dialog,
  download: download,
  duplicate: duplicate,
  guide: guide,
  gym: gym,
  hamburger: hamburger,
  'heart-filled': heartFilled,
  heart: heart,
  'heart-stroke': heartStroke,
  'history-filled': historyFilled,
  'history-stroke': historyStroke,
  'home-filled': homeFilled,
  home: home,
  'home-stroke': homeStroke,
  'id-card-filled': idCardFilled,
  'id-card-stroke': idCardStroke,
  image: image,
  'info-filled': infoFilled,
  'info-stroke': infoStroke,
  'location-filled': locationFilled,
  'location-stroke': locationStroke,
  'logo-apple': logoApple,
  'logo-google': logoGoogle,
  'logo-kakao': logoKakao,
  'logo-naver': logoNaver,
  'mail-filled': mailFilled,
  'mail-stroke': mailStroke,
  microphone: microphone,
  minus: minus,
  'minus-circle-filled': minusCircleFilled,
  'minus-circle-stroke': minusCircleStroke,
  modify: modify,
  more: more,
  'my-page-filled': myPageFilled,
  'my-page': myPage,
  'number-0': number_0,
  'number-1': number_1,
  'number-2': number_2,
  'number-3': number_3,
  'number-4': number_4,
  'number-5': number_5,
  'number-6': number_6,
  'number-7': number_7,
  'number-8': number_8,
  'number-9': number_9,
  parcel: parcel,
  'payment-filled': paymenrFilled,
  'payment-stroke': paymentStroke,
  'person-filled': personFilled,
  'person-stroke': personStroke,
  print: print,
  'profile-filled': profileFilled,
  'profile-stroke': profileStroke,
  qr: qr,
  'question-filled': questionFilled,
  'question-stroke': questionStroke,
  'radio-resting': radioResting,
  'radio-selected': radioSelected,
  receipt: receipt,
  reload: reload,
  reset: reset,
  search: search,
  'settings-filled': settingsFilled,
  'settings-stroke': settingsStroke,
  'share-ios': shareIos,
  sound: sound,
  'switch-circle-filled': switchCircleFilled,
  'switch-circle-stroke': switchCircleStroke,
  'time-filled': timeFilled,
  'time-stroke': timeStroke
};

var Icon = function (_a) {
  var type = _a.type,
    _b = _a.size,
    size = _b === void 0 ? 24 : _b,
    _c = _a.color,
    color = _c === void 0 ? colors.primary.coolGray[800] : _c,
    onClick = _a.onClick,
    _d = _a.className,
    className = _d === void 0 ? '' : _d,
    _e = _a.style,
    style = _e === void 0 ? {} : _e;
  var svgContent = iconMap[type];
  var iconStyle = __assign({
    width: size,
    height: size,
    color: color,
    cursor: 'inherit',
    transition: 'all 0.2s ease',
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center'
  }, style);
  var handleClick = function () {
    if (onClick) {
      onClick();
    }
  };
  var handleKeyDown = function (e) {
    if (onClick && (e.key === 'Enter' || e.key === ' ')) {
      e.preventDefault();
      onClick();
    }
  };
  if (!svgContent) {
    console.warn("Icon type \"".concat(type, "\" not found"));
    return jsx("div", {
      className: "icon icon--".concat(type, " ").concat(className),
      style: iconStyle,
      onClick: handleClick,
      role: onClick ? 'button' : 'img',
      tabIndex: onClick ? 0 : undefined,
      onKeyDown: handleKeyDown,
      children: jsx("svg", {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        fill: "none",
        children: jsx("circle", {
          cx: "12",
          cy: "12",
          r: "1",
          fill: color
        })
      })
    });
  }
  // SVG 내용에서 색상을 동적으로 변경
  var processedSvg = svgContent.replace(/fill="[^"]*"/g, "fill=\"".concat(color, "\"")).replace(/stroke="[^"]*"/g, "stroke=\"".concat(color, "\"")).replace(/width="[^"]*"/g, "width=\"".concat(size, "\"")).replace(/height="[^"]*"/g, "height=\"".concat(size, "\""));
  return jsx("div", {
    className: "icon icon--".concat(type, " ").concat(className),
    style: iconStyle,
    onClick: handleClick,
    role: onClick ? 'button' : 'img',
    tabIndex: onClick ? 0 : undefined,
    onKeyDown: handleKeyDown,
    dangerouslySetInnerHTML: {
      __html: processedSvg
    }
  });
};

var emptySvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M19 1H5C3.89543 1 3 1.89543 3 3V21C3 22.1046 3.89543 23 5 23H13L17 19L21 15V3C21 1.89543 20.1046 1 19 1Z\" fill=\"#F3F5F6\"/>\n<path d=\"M21 15L13 23V15H21Z\" fill=\"#E8EAED\"/>\n</svg>\n";
var manSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#4785FF\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6.70173 7.54579C7.22887 7.38105 7.78975 7.67485 7.95448 8.20199L8.51644 10.0003H10.4836L11.0455 8.20199C11.176 7.78452 11.5626 7.50027 12 7.50027C12.4374 7.50027 12.824 7.78452 12.9545 8.20199L13.5164 10.0003H15.4836L16.0455 8.20199C16.2103 7.67485 16.7711 7.38105 17.2983 7.54579C17.8254 7.71052 18.1192 8.2714 17.9545 8.79854L17.5789 10.0003H18C18.5523 10.0003 19 10.448 19 11.0003C19 11.5526 18.5523 12.0003 18 12.0003H16.9539L15.4545 16.7985C15.324 17.216 14.9374 17.5003 14.5 17.5003C14.0626 17.5003 13.676 17.216 13.5455 16.7985L12.0461 12.0003H11.9539L10.4545 16.7985C10.324 17.216 9.93739 17.5003 9.5 17.5003C9.06261 17.5003 8.67598 17.216 8.54552 16.7985L7.04606 12.0003H6C5.44772 12.0003 5 11.5526 5 11.0003C5 10.448 5.44772 10.0003 6 10.0003H6.42106L6.04552 8.79854C5.88079 8.2714 6.17458 7.71052 6.70173 7.54579ZM9.14144 12.0003L9.5 13.5L9.85856 12.0003H9.14144ZM14.1414 12.0003L14.5 13.5L14.8586 12.0003H14.1414Z\" fill=\"white\"/>\n</svg>\n";
var muscleSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M23 18.069C23 19.2069 19.5862 23 14.2759 23C10.6117 23 7.74793 21.9897 6.5 21.25C6.1684 21.7862 5.99039 22.3696 6 23H1V11.2414C3.09 11.2414 6.13965 10.9228 8.38896 14.1014C9.46595 13.4189 10.7262 13.0826 12 13.1379C13.2242 13.0888 14.4364 13.3958 15.4897 14.0217C15.8558 12.8424 16.336 11.7016 16.9234 10.6155C16.9234 7.80862 16.1686 6.65552 16.1686 6.65552C15.5664 6.90188 14.926 7.04177 14.2759 7.06897C13.3999 7.03319 12.5332 6.87618 11.7003 6.60241C11.5953 6.56947 11.4986 6.51408 11.4171 6.44008C11.3356 6.36608 11.2711 6.27524 11.2282 6.17386C11.1853 6.07247 11.1649 5.96296 11.1685 5.85292C11.172 5.74288 11.1995 5.63493 11.249 5.53655L11.6207 4.8L11.0972 3.48448C11.0316 3.31908 11.026 3.13589 11.0814 2.96679C11.1369 2.79769 11.2498 2.65337 11.4007 2.55897L13.3428 1.34517C13.705 1.1204 14.1227 1.00088 14.549 1H17.4848C17.9074 0.999509 18.3218 1.1167 18.6816 1.33846C19.0414 1.56021 19.3323 1.87775 19.5217 2.25552C20.709 4.61862 23 10.1983 23 18.069Z\" fill=\"#FFDAC4\"/>\n<path d=\"M16.1695 6.65C16.4111 7.09116 16.6288 7.79784 16.7195 8.29259C17.3091 7.72868 17.9325 6.56312 17.9995 5.75C17.9995 5.75 17.0995 6.40224 16.7495 6.5C16.4358 6.59466 16.1695 6.65 16.1695 6.65ZM11.6193 4.8L11.3193 5.39655H13.5857C13.8874 5.39622 14.1767 5.27623 14.39 5.0629C14.6033 4.84956 14.7233 4.56032 14.7237 4.25862V3.87931C14.7237 3.77871 14.6837 3.68223 14.6126 3.6111C14.5414 3.53996 14.445 3.5 14.3444 3.5C14.2438 3.5 14.1473 3.53996 14.0761 3.6111C14.005 3.68223 13.965 3.77871 13.965 3.87931V4.25862C13.965 4.3592 13.925 4.45564 13.8539 4.52676C13.7828 4.59788 13.6863 4.63786 13.5857 4.63793H11.5581L11.6193 4.8Z\" fill=\"#F9B995\"/>\n</svg>\n";
var womanSvg = "<svg width=\"14\" height=\"22\" viewBox=\"0 0 14 22\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5.5 13.5C5.5 12.6716 6.17157 12 7 12C7.82843 12 8.5 12.6716 8.5 13.5V20.5C8.5 21.3284 7.82843 22 7 22C6.17157 22 5.5 21.3284 5.5 20.5V13.5Z\" fill=\"#FF8F8F\"/>\n<path d=\"M10 15.5C10.8284 15.5 11.5 16.1716 11.5 17C11.5 17.8284 10.8284 18.5 10 18.5L4 18.5C3.17157 18.5 2.5 17.8284 2.5 17C2.5 16.1716 3.17157 15.5 4 15.5L10 15.5Z\" fill=\"#FF8F8F\"/>\n<path d=\"M5.5 12.5H8.5V15.5H5.5V12.5Z\" fill=\"#D36666\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 11C9.20914 11 11 9.20914 11 7C11 4.79086 9.20914 3 7 3C4.79086 3 3 4.79086 3 7C3 9.20914 4.79086 11 7 11ZM7 14C10.866 14 14 10.866 14 7C14 3.13401 10.866 0 7 0C3.13401 0 0 3.13401 0 7C0 10.866 3.13401 14 7 14Z\" fill=\"#FF8F8F\"/>\n</svg>\n";
var moneySvg = "<svg width=\"19\" height=\"19\" viewBox=\"0 0 19 19\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M17 0.125C18.0355 0.125 18.875 0.964466 18.875 2V8C18.875 8.75939 18.2594 9.375 17.5 9.375C16.7406 9.375 16.125 8.75939 16.125 8V4.99609L13.0664 8.05371C14.8051 10.7633 14.4917 14.4086 12.122 16.7783C9.38851 19.5118 4.95631 19.5115 2.22262 16.7783C-0.511054 14.0447 -0.511054 9.6116 2.22262 6.87793C4.59198 4.50898 8.236 4.1949 10.9453 5.93262L14.0039 2.875H11C10.2406 2.875 9.62496 2.25939 9.62496 1.5C9.62496 0.740608 10.2406 0.125 11 0.125H17ZM9.99996 9C8.43786 7.43794 5.90579 7.43792 4.34371 9C2.78167 10.5621 2.78167 13.0942 4.34371 14.6562C5.90579 16.2183 8.43786 16.2183 9.99996 14.6562C11.5621 13.0942 11.5621 10.5621 9.99996 9Z\" fill=\"#93D8CC\"/>\n</svg>\n";
var idCardSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M20.4792 3.75H3.52083C2.85242 3.75049 2.21151 4.01623 1.73887 4.48887C1.26623 4.96151 1.00049 5.60242 1 6.27083L1 17.7292C1.00049 18.3976 1.26623 19.0385 1.73887 19.5111C2.21151 19.9838 2.85242 20.2495 3.52083 20.25H20.4792C21.1476 20.2495 21.7885 19.9838 22.2611 19.5111C22.7338 19.0385 22.9995 18.3976 23 17.7292V6.27083C22.9995 5.60242 22.7338 4.96151 22.2611 4.48887C21.7885 4.01623 21.1476 3.75049 20.4792 3.75Z\" fill=\"#F1F2F4\"/>\n<path d=\"M7.87467 12.0003C9.14033 12.0003 10.1663 10.9743 10.1663 9.70866C10.1663 8.44301 9.14033 7.41699 7.87467 7.41699C6.60902 7.41699 5.58301 8.44301 5.58301 9.70866C5.58301 10.9743 6.60902 12.0003 7.87467 12.0003Z\" fill=\"#4785FF\"/>\n<path d=\"M12 15.8962C12 16.0785 11.9276 16.2534 11.7986 16.3823C11.6697 16.5112 11.4948 16.5837 11.3125 16.5837H4.4375C4.25516 16.5837 4.0803 16.5112 3.95136 16.3823C3.82243 16.2534 3.75 16.0785 3.75 15.8962V15.4378C3.75049 14.7694 4.01623 14.1285 4.48887 13.6559C4.96151 13.1832 5.60242 12.9175 6.27083 12.917H9.47917C10.1476 12.9175 10.7885 13.1832 11.2611 13.6559C11.7338 14.1285 11.9995 14.7694 12 15.4378V15.8962Z\" fill=\"#4785FF\"/>\n<path d=\"M19.5622 16.5833H14.5205C14.3382 16.5833 14.1633 16.5109 14.0344 16.382C13.9054 16.253 13.833 16.0782 13.833 15.8958C13.833 15.7135 13.9054 15.5386 14.0344 15.4097C14.1633 15.2808 14.3382 15.2083 14.5205 15.2083H19.5622C19.7445 15.2083 19.9194 15.2808 20.0483 15.4097C20.1772 15.5386 20.2497 15.7135 20.2497 15.8958C20.2497 16.0782 20.1772 16.253 20.0483 16.382C19.9194 16.5109 19.7445 16.5833 19.5622 16.5833ZM19.5622 12.9167H14.5205C14.3382 12.9167 14.1633 12.8442 14.0344 12.7153C13.9054 12.5864 13.833 12.4115 13.833 12.2292C13.833 12.0468 13.9054 11.872 14.0344 11.743C14.1633 11.6141 14.3382 11.5417 14.5205 11.5417H19.5622C19.7445 11.5417 19.9194 11.6141 20.0483 11.743C20.1772 11.872 20.2497 12.0468 20.2497 12.2292C20.2497 12.4115 20.1772 12.5864 20.0483 12.7153C19.9194 12.8442 19.7445 12.9167 19.5622 12.9167ZM19.5622 9.25H14.5205C14.3382 9.25 14.1633 9.17757 14.0344 9.04864C13.9054 8.9197 13.833 8.74484 13.833 8.5625C13.833 8.38016 13.9054 8.2053 14.0344 8.07636C14.1633 7.94743 14.3382 7.875 14.5205 7.875H19.5622C19.7445 7.875 19.9194 7.94743 20.0483 8.07636C20.1772 8.2053 20.2497 8.38016 20.2497 8.5625C20.2497 8.74484 20.1772 8.9197 20.0483 9.04864C19.9194 9.17757 19.7445 9.25 19.5622 9.25Z\" fill=\"#686B73\"/>\n</svg>\n";
var thumbupSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M15.5416 2.31131C14.0743 0.857441 11.5756 1.44185 10.9194 3.39243L10.2204 5.46997C10.1227 5.76038 9.95956 6.02446 9.7436 6.24182L7.64664 8.35241C7.55278 8.44688 7.42511 8.5 7.29194 8.5H5.93053C5.41662 8.5 5 8.94929 5 9.45845V20.5219C5 21.0311 5.41662 21.5 5.93053 21.5H18.7057C20.0141 21.5 21.147 20.5435 21.4309 19.278L22.9174 12.6504C23.3908 10.5392 21.7695 8.5365 19.5867 8.5365H16.4001C16.0798 8.5365 15.8421 8.23959 15.9122 7.92708L16.5429 5.11486C16.75 4.19173 16.4666 3.22778 15.7918 2.55911L15.5416 2.31131Z\" fill=\"#FBC9AD\"/>\n<path d=\"M1 9.5C1 8.94772 1.44772 8.5 2 8.5H7V21.5H2C1.44772 21.5 1 21.0523 1 20.5V9.5Z\" fill=\"#2F6EFF\"/>\n</svg>\n";
var thumbdownSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M15.5416 21.6887C14.0743 23.1426 11.5756 22.5582 10.9194 20.6076L10.2204 18.53C10.1227 18.2396 9.95956 17.9755 9.7436 17.7582L7.64664 15.6476C7.55278 15.5531 7.42511 15.5 7.29194 15.5H5.93053C5.41662 15.5 5 15.0507 5 14.5415V3.47811C5 2.96894 5.41662 2.5 5.93053 2.5H18.7057C20.0141 2.5 21.147 3.45647 21.4309 4.72201L22.9174 11.3496C23.3908 13.4608 21.7695 15.4635 19.5867 15.4635H16.4001C16.0798 15.4635 15.8421 15.7604 15.9122 16.0729L16.5429 18.8851C16.75 19.8083 16.4666 20.7722 15.7918 21.4409L15.5416 21.6887Z\" fill=\"#FBC9AD\"/>\n<path d=\"M1 3.5C1 2.94772 1.44772 2.5 2 2.5H7V15.5H2C1.44772 15.5 1 15.0523 1 14.5V3.5Z\" fill=\"#474A52\"/>\n</svg>\n";
var couponSvg = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M3 6.5C3 5.39543 3.89543 4.5 5 4.5H21C22.1046 4.5 23 5.39543 23 6.5V14.5C23 15.6046 22.1046 16.5 21 16.5H5C3.89543 16.5 3 15.6046 3 14.5V6.5Z\" fill=\"#FFE066\"/>\n<path d=\"M3 6.5C1.89543 6.5 1 7.39543 1 8.5V10C1 10.2761 1.22733 10.4936 1.49494 10.5617C2.36012 10.782 3 11.5663 3 12.5C3 13.4337 2.36012 14.218 1.49494 14.4383C1.22733 14.5064 1 14.7239 1 15V16.5C1 17.6046 1.89543 18.5 3 18.5H19C20.1046 18.5 21 17.6046 21 16.5V8.5C21 7.39543 20.1046 6.5 19 6.5H3Z\" fill=\"#FFB200\"/>\n<path d=\"M15.5 6.5H16.5V8.5C16.5 8.77614 16.2761 9 16 9C15.7239 9 15.5 8.77614 15.5 8.5V6.5Z\" fill=\"white\"/>\n<path d=\"M15.5 16.5C15.5 16.2239 15.7239 16 16 16C16.2761 16 16.5 16.2239 16.5 16.5V18.5H15.5V16.5Z\" fill=\"white\"/>\n<path d=\"M15.5 10.5C15.5 10.2239 15.7239 10 16 10C16.2761 10 16.5 10.2239 16.5 10.5V11.5C16.5 11.7761 16.2761 12 16 12C15.7239 12 15.5 11.7761 15.5 11.5V10.5Z\" fill=\"white\"/>\n<path d=\"M15.5 13.5C15.5 13.2239 15.7239 13 16 13C16.2761 13 16.5 13.2239 16.5 13.5V14.5C16.5 14.7761 16.2761 15 16 15C15.7239 15 15.5 14.7761 15.5 14.5V13.5Z\" fill=\"white\"/>\n<path d=\"M6 10C6 9.72386 6.22386 9.5 6.5 9.5H13C13.2761 9.5 13.5 9.72386 13.5 10C13.5 10.2761 13.2761 10.5 13 10.5H6.5C6.22386 10.5 6 10.2761 6 10Z\" fill=\"white\"/>\n<path d=\"M6 12.5C6 12.2239 6.22386 12 6.5 12H13C13.2761 12 13.5 12.2239 13.5 12.5C13.5 12.7761 13.2761 13 13 13H6.5C6.22386 13 6 12.7761 6 12.5Z\" fill=\"white\"/>\n<path d=\"M6 15C6 14.7239 6.22386 14.5 6.5 14.5H13C13.2761 14.5 13.5 14.7239 13.5 15C13.5 15.2761 13.2761 15.5 13 15.5H6.5C6.22386 15.5 6 15.2761 6 15Z\" fill=\"white\"/>\n</svg>\n";
// 일러스트 맵 - 실제 일러스트 파일들을 추가할 때 여기에 등록
var illustMap = {
  empty: emptySvg,
  man: manSvg,
  woman: womanSvg,
  muscle: muscleSvg,
  money: moneySvg,
  idCard: idCardSvg,
  thumbup: thumbupSvg,
  thumbdown: thumbdownSvg,
  coupon: couponSvg
};

var Illust = function (_a) {
  var type = _a.type,
    _b = _a.size,
    size = _b === void 0 ? 24 : _b,
    onClick = _a.onClick,
    _c = _a.className,
    className = _c === void 0 ? '' : _c,
    _d = _a.style,
    style = _d === void 0 ? {} : _d;
  var svgContent = illustMap[type];
  var illustStyle = __assign({
    width: size,
    height: size,
    cursor: 'inherit',
    transition: 'all 0.2s ease',
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center'
  }, style);
  var handleClick = function () {
    if (onClick) {
      onClick();
    }
  };
  var handleKeyDown = function (e) {
    if (onClick && (e.key === 'Enter' || e.key === ' ')) {
      e.preventDefault();
      onClick();
    }
  };
  if (!svgContent) {
    console.warn("Illust type \"".concat(type, "\" not found"));
    return jsx("div", {
      className: "illust illust--".concat(type, " ").concat(className),
      style: illustStyle,
      onClick: handleClick,
      role: onClick ? 'button' : 'img',
      tabIndex: onClick ? 0 : undefined,
      onKeyDown: handleKeyDown,
      children: jsx("svg", {
        width: size,
        height: size,
        viewBox: "0 0 24 24",
        fill: "none",
        children: jsx("circle", {
          cx: "12",
          cy: "12",
          r: "1",
          fill: "currentColor"
        })
      })
    });
  }
  // SVG 내용에서 크기를 동적으로 변경 (color는 변경하지 않음)
  var processedSvg = svgContent.replace(/width="[^"]*"/g, "width=\"".concat(size, "\"")).replace(/height="[^"]*"/g, "height=\"".concat(size, "\""));
  return jsx("div", {
    className: "illust illust--".concat(type, " ").concat(className),
    style: illustStyle,
    onClick: handleClick,
    role: onClick ? 'button' : 'img',
    tabIndex: onClick ? 0 : undefined,
    onKeyDown: handleKeyDown,
    dangerouslySetInnerHTML: {
      __html: processedSvg
    }
  });
};

var Label = function (_a) {
  var _b = _a.size,
    size = _b === void 0 ? 'm' : _b,
    _c = _a.type,
    type = _c === void 0 ? 'square' : _c,
    _d = _a.color,
    color = _d === void 0 ? 'grey' : _d,
    leadingIcon = _a.leadingIcon,
    trailingIcon = _a.trailingIcon,
    children = _a.children,
    _e = _a.className,
    className = _e === void 0 ? '' : _e;
  // Size configurations
  var sizeConfig = {
    m: {
      padding: type === 'square' ? '3px 8px' : '3px 10px',
      paddingWithLeadingIcon: type === 'square' ? '3px 8px 3px 6px' : '3px 10px 3px 8px',
      paddingWithTrailingIcon: type === 'square' ? '3px 6px 3px 8px' : '3px 8px 3px 10px',
      borderRadius: type === 'square' ? '4px' : '16px',
      height: '24px',
      iconSize: '14px',
      gap: '2px',
      fontSize: 'body2'
    },
    s: {
      padding: type === 'square' ? '2px 6px' : '2px 8px',
      paddingWithLeadingIcon: type === 'square' ? '2px 6px 2px 4px' : '2px 8px 2px 6px',
      paddingWithTrailingIcon: type === 'square' ? '2px 4px 2px 6px' : '2px 6px 2px 8px',
      borderRadius: type === 'square' ? '4px' : '12px',
      height: '22px',
      iconSize: '12px',
      gap: '2px',
      fontSize: 'caption'
    }
  };
  // Color configurations
  var colorConfig = {
    grey: {
      backgroundColor: colors.primary.coolGray[100],
      textColor: colors.primary.coolGray[600],
      iconColor: colors.primary.coolGray[700]
    },
    dark: {
      backgroundColor: colors.primary.coolGray[600],
      textColor: colors.primary.gray.white,
      iconColor: colors.primary.gray.white
    },
    violet: {
      backgroundColor: colors.primary.tint.violet[50],
      textColor: colors.primary.tint.violet[500],
      iconColor: colors.primary.tint.violet[500]
    },
    accent: {
      backgroundColor: colors.primary.tint.violet[500],
      textColor: colors.primary.gray.white,
      iconColor: colors.primary.gray.white
    },
    red: {
      backgroundColor: colors.primary.tint.red[500],
      textColor: colors.primary.gray.white,
      iconColor: colors.primary.gray.white
    },
    green: {
      backgroundColor: colors.primary.tint.green[500],
      textColor: colors.primary.gray.white,
      iconColor: colors.primary.gray.white
    },
    yellow: {
      backgroundColor: colors.primary.tint.yellow[500],
      textColor: colors.primary.gray.white,
      iconColor: colors.primary.gray.white
    }
  };
  var config = sizeConfig[size];
  var colorStyle = colorConfig[color];
  // Determine padding based on icon presence
  var getPadding = function () {
    if (leadingIcon && trailingIcon) {
      return config.paddingWithLeadingIcon; // Use leading icon padding style
    } else if (leadingIcon) {
      return config.paddingWithLeadingIcon;
    } else if (trailingIcon) {
      return config.paddingWithTrailingIcon;
    }
    return config.padding;
  };
  var getStyles = function () {
    return {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: getPadding(),
      borderRadius: config.borderRadius,
      backgroundColor: colorStyle.backgroundColor,
      height: config.height,
      gap: config.gap,
      whiteSpace: 'nowrap',
      boxSizing: 'border-box'
    };
  };
  var getIconStyles = function () {
    return {
      width: config.iconSize,
      height: config.iconSize,
      color: colorStyle.iconColor,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      flexShrink: 0
    };
  };
  return jsxs("div", {
    className: "label label--".concat(size, " label--").concat(type, " label--").concat(color, " ").concat(className),
    style: getStyles(),
    children: [leadingIcon && jsx("span", {
      className: "label__leading-icon",
      style: getIconStyles(),
      children: leadingIcon
    }), children && jsx(Font, {
      type: config.fontSize,
      fontWeight: "medium",
      color: colorStyle.textColor,
      children: children
    }), trailingIcon && jsx("span", {
      className: "label__trailing-icon",
      style: getIconStyles(),
      children: trailingIcon
    })]
  });
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var index_umd = {exports: {}};

var lottie = {exports: {}};

var hasRequiredLottie;

function requireLottie () {
	if (hasRequiredLottie) return lottie.exports;
	hasRequiredLottie = 1;
	(function (module, exports) {
		(typeof document !== "undefined") && (typeof navigator !== "undefined") && (function (global, factory) {
		  module.exports = factory() ;
		})(commonjsGlobal, (function () {
		  var svgNS = 'http://www.w3.org/2000/svg';
		  var locationHref = '';
		  var _useWebWorker = false;
		  var initialDefaultFrame = -999999;
		  var setWebWorker = function setWebWorker(flag) {
		    _useWebWorker = !!flag;
		  };
		  var getWebWorker = function getWebWorker() {
		    return _useWebWorker;
		  };
		  var setLocationHref = function setLocationHref(value) {
		    locationHref = value;
		  };
		  var getLocationHref = function getLocationHref() {
		    return locationHref;
		  };

		  function createTag(type) {
		    // return {appendChild:function(){},setAttribute:function(){},style:{}}
		    return document.createElement(type);
		  }

		  function extendPrototype(sources, destination) {
		    var i;
		    var len = sources.length;
		    var sourcePrototype;
		    for (i = 0; i < len; i += 1) {
		      sourcePrototype = sources[i].prototype;
		      for (var attr in sourcePrototype) {
		        if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
		      }
		    }
		  }
		  function getDescriptor(object, prop) {
		    return Object.getOwnPropertyDescriptor(object, prop);
		  }
		  function createProxyFunction(prototype) {
		    function ProxyFunction() {}
		    ProxyFunction.prototype = prototype;
		    return ProxyFunction;
		  }

		  // import Howl from '../../3rd_party/howler';

		  var audioControllerFactory = function () {
		    function AudioController(audioFactory) {
		      this.audios = [];
		      this.audioFactory = audioFactory;
		      this._volume = 1;
		      this._isMuted = false;
		    }
		    AudioController.prototype = {
		      addAudio: function addAudio(audio) {
		        this.audios.push(audio);
		      },
		      pause: function pause() {
		        var i;
		        var len = this.audios.length;
		        for (i = 0; i < len; i += 1) {
		          this.audios[i].pause();
		        }
		      },
		      resume: function resume() {
		        var i;
		        var len = this.audios.length;
		        for (i = 0; i < len; i += 1) {
		          this.audios[i].resume();
		        }
		      },
		      setRate: function setRate(rateValue) {
		        var i;
		        var len = this.audios.length;
		        for (i = 0; i < len; i += 1) {
		          this.audios[i].setRate(rateValue);
		        }
		      },
		      createAudio: function createAudio(assetPath) {
		        if (this.audioFactory) {
		          return this.audioFactory(assetPath);
		        }
		        if (window.Howl) {
		          return new window.Howl({
		            src: [assetPath]
		          });
		        }
		        return {
		          isPlaying: false,
		          play: function play() {
		            this.isPlaying = true;
		          },
		          seek: function seek() {
		            this.isPlaying = false;
		          },
		          playing: function playing() {},
		          rate: function rate() {},
		          setVolume: function setVolume() {}
		        };
		      },
		      setAudioFactory: function setAudioFactory(audioFactory) {
		        this.audioFactory = audioFactory;
		      },
		      setVolume: function setVolume(value) {
		        this._volume = value;
		        this._updateVolume();
		      },
		      mute: function mute() {
		        this._isMuted = true;
		        this._updateVolume();
		      },
		      unmute: function unmute() {
		        this._isMuted = false;
		        this._updateVolume();
		      },
		      getVolume: function getVolume() {
		        return this._volume;
		      },
		      _updateVolume: function _updateVolume() {
		        var i;
		        var len = this.audios.length;
		        for (i = 0; i < len; i += 1) {
		          this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
		        }
		      }
		    };
		    return function () {
		      return new AudioController();
		    };
		  }();

		  var createTypedArray = function () {
		    function createRegularArray(type, len) {
		      var i = 0;
		      var arr = [];
		      var value;
		      switch (type) {
		        case 'int16':
		        case 'uint8c':
		          value = 1;
		          break;
		        default:
		          value = 1.1;
		          break;
		      }
		      for (i = 0; i < len; i += 1) {
		        arr.push(value);
		      }
		      return arr;
		    }
		    function createTypedArrayFactory(type, len) {
		      if (type === 'float32') {
		        return new Float32Array(len);
		      }
		      if (type === 'int16') {
		        return new Int16Array(len);
		      }
		      if (type === 'uint8c') {
		        return new Uint8ClampedArray(len);
		      }
		      return createRegularArray(type, len);
		    }
		    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
		      return createTypedArrayFactory;
		    }
		    return createRegularArray;
		  }();
		  function createSizedArray(len) {
		    return Array.apply(null, {
		      length: len
		    });
		  }

		  function _typeof$6(o) { "@babel/helpers - typeof"; return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$6(o); }
		  var subframeEnabled = true;
		  var expressionsPlugin = null;
		  var expressionsInterfaces = null;
		  var idPrefix$1 = '';
		  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
		  var bmPow = Math.pow;
		  var bmSqrt = Math.sqrt;
		  var bmFloor = Math.floor;
		  var bmMax = Math.max;
		  var bmMin = Math.min;
		  var BMMath = {};
		  (function () {
		    var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
		    var i;
		    var len = propertyNames.length;
		    for (i = 0; i < len; i += 1) {
		      BMMath[propertyNames[i]] = Math[propertyNames[i]];
		    }
		  })();
		  BMMath.random = Math.random;
		  BMMath.abs = function (val) {
		    var tOfVal = _typeof$6(val);
		    if (tOfVal === 'object' && val.length) {
		      var absArr = createSizedArray(val.length);
		      var i;
		      var len = val.length;
		      for (i = 0; i < len; i += 1) {
		        absArr[i] = Math.abs(val[i]);
		      }
		      return absArr;
		    }
		    return Math.abs(val);
		  };
		  var defaultCurveSegments = 150;
		  var degToRads = Math.PI / 180;
		  var roundCorner = 0.5519;
		  function styleDiv(element) {
		    element.style.position = 'absolute';
		    element.style.top = 0;
		    element.style.left = 0;
		    element.style.display = 'block';
		    element.style.transformOrigin = '0 0';
		    element.style.webkitTransformOrigin = '0 0';
		    element.style.backfaceVisibility = 'visible';
		    element.style.webkitBackfaceVisibility = 'visible';
		    element.style.transformStyle = 'preserve-3d';
		    element.style.webkitTransformStyle = 'preserve-3d';
		    element.style.mozTransformStyle = 'preserve-3d';
		  }
		  function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
		    this.type = type;
		    this.currentTime = currentTime;
		    this.totalTime = totalTime;
		    this.direction = frameMultiplier < 0 ? -1 : 1;
		  }
		  function BMCompleteEvent(type, frameMultiplier) {
		    this.type = type;
		    this.direction = frameMultiplier < 0 ? -1 : 1;
		  }
		  function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
		    this.type = type;
		    this.currentLoop = currentLoop;
		    this.totalLoops = totalLoops;
		    this.direction = frameMultiplier < 0 ? -1 : 1;
		  }
		  function BMSegmentStartEvent(type, firstFrame, totalFrames) {
		    this.type = type;
		    this.firstFrame = firstFrame;
		    this.totalFrames = totalFrames;
		  }
		  function BMDestroyEvent(type, target) {
		    this.type = type;
		    this.target = target;
		  }
		  function BMRenderFrameErrorEvent(nativeError, currentTime) {
		    this.type = 'renderFrameError';
		    this.nativeError = nativeError;
		    this.currentTime = currentTime;
		  }
		  function BMConfigErrorEvent(nativeError) {
		    this.type = 'configError';
		    this.nativeError = nativeError;
		  }
		  var createElementID = function () {
		    var _count = 0;
		    return function createID() {
		      _count += 1;
		      return idPrefix$1 + '__lottie_element_' + _count;
		    };
		  }();
		  function HSVtoRGB(h, s, v) {
		    var r;
		    var g;
		    var b;
		    var i;
		    var f;
		    var p;
		    var q;
		    var t;
		    i = Math.floor(h * 6);
		    f = h * 6 - i;
		    p = v * (1 - s);
		    q = v * (1 - f * s);
		    t = v * (1 - (1 - f) * s);
		    switch (i % 6) {
		      case 0:
		        r = v;
		        g = t;
		        b = p;
		        break;
		      case 1:
		        r = q;
		        g = v;
		        b = p;
		        break;
		      case 2:
		        r = p;
		        g = v;
		        b = t;
		        break;
		      case 3:
		        r = p;
		        g = q;
		        b = v;
		        break;
		      case 4:
		        r = t;
		        g = p;
		        b = v;
		        break;
		      case 5:
		        r = v;
		        g = p;
		        b = q;
		        break;
		    }
		    return [r, g, b];
		  }
		  function RGBtoHSV(r, g, b) {
		    var max = Math.max(r, g, b);
		    var min = Math.min(r, g, b);
		    var d = max - min;
		    var h;
		    var s = max === 0 ? 0 : d / max;
		    var v = max / 255;
		    switch (max) {
		      case min:
		        h = 0;
		        break;
		      case r:
		        h = g - b + d * (g < b ? 6 : 0);
		        h /= 6 * d;
		        break;
		      case g:
		        h = b - r + d * 2;
		        h /= 6 * d;
		        break;
		      case b:
		        h = r - g + d * 4;
		        h /= 6 * d;
		        break;
		    }
		    return [h, s, v];
		  }
		  function addSaturationToRGB(color, offset) {
		    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
		    hsv[1] += offset;
		    if (hsv[1] > 1) {
		      hsv[1] = 1;
		    } else if (hsv[1] <= 0) {
		      hsv[1] = 0;
		    }
		    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
		  }
		  function addBrightnessToRGB(color, offset) {
		    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
		    hsv[2] += offset;
		    if (hsv[2] > 1) {
		      hsv[2] = 1;
		    } else if (hsv[2] < 0) {
		      hsv[2] = 0;
		    }
		    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
		  }
		  function addHueToRGB(color, offset) {
		    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
		    hsv[0] += offset / 360;
		    if (hsv[0] > 1) {
		      hsv[0] -= 1;
		    } else if (hsv[0] < 0) {
		      hsv[0] += 1;
		    }
		    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
		  }
		  var rgbToHex = function () {
		    var colorMap = [];
		    var i;
		    var hex;
		    for (i = 0; i < 256; i += 1) {
		      hex = i.toString(16);
		      colorMap[i] = hex.length === 1 ? '0' + hex : hex;
		    }
		    return function (r, g, b) {
		      if (r < 0) {
		        r = 0;
		      }
		      if (g < 0) {
		        g = 0;
		      }
		      if (b < 0) {
		        b = 0;
		      }
		      return '#' + colorMap[r] + colorMap[g] + colorMap[b];
		    };
		  }();
		  var setSubframeEnabled = function setSubframeEnabled(flag) {
		    subframeEnabled = !!flag;
		  };
		  var getSubframeEnabled = function getSubframeEnabled() {
		    return subframeEnabled;
		  };
		  var setExpressionsPlugin = function setExpressionsPlugin(value) {
		    expressionsPlugin = value;
		  };
		  var getExpressionsPlugin = function getExpressionsPlugin() {
		    return expressionsPlugin;
		  };
		  var setExpressionInterfaces = function setExpressionInterfaces(value) {
		    expressionsInterfaces = value;
		  };
		  var getExpressionInterfaces = function getExpressionInterfaces() {
		    return expressionsInterfaces;
		  };
		  var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
		    defaultCurveSegments = value;
		  };
		  var getDefaultCurveSegments = function getDefaultCurveSegments() {
		    return defaultCurveSegments;
		  };
		  var setIdPrefix = function setIdPrefix(value) {
		    idPrefix$1 = value;
		  };

		  function createNS(type) {
		    // return {appendChild:function(){},setAttribute:function(){},style:{}}
		    return document.createElementNS(svgNS, type);
		  }

		  function _typeof$5(o) { "@babel/helpers - typeof"; return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$5(o); }
		  var dataManager = function () {
		    var _counterId = 1;
		    var processes = [];
		    var workerFn;
		    var workerInstance;
		    var workerProxy = {
		      onmessage: function onmessage() {},
		      postMessage: function postMessage(path) {
		        workerFn({
		          data: path
		        });
		      }
		    };
		    var _workerSelf = {
		      postMessage: function postMessage(data) {
		        workerProxy.onmessage({
		          data: data
		        });
		      }
		    };
		    function createWorker(fn) {
		      if (window.Worker && window.Blob && getWebWorker()) {
		        var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {
		          type: 'text/javascript'
		        });
		        // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });
		        var url = URL.createObjectURL(blob);
		        return new Worker(url);
		      }
		      workerFn = fn;
		      return workerProxy;
		    }
		    function setupWorker() {
		      if (!workerInstance) {
		        workerInstance = createWorker(function workerStart(e) {
		          function dataFunctionManager() {
		            function completeLayers(layers, comps) {
		              var layerData;
		              var i;
		              var len = layers.length;
		              var j;
		              var jLen;
		              var k;
		              var kLen;
		              for (i = 0; i < len; i += 1) {
		                layerData = layers[i];
		                if ('ks' in layerData && !layerData.completed) {
		                  layerData.completed = true;
		                  if (layerData.hasMask) {
		                    var maskProps = layerData.masksProperties;
		                    jLen = maskProps.length;
		                    for (j = 0; j < jLen; j += 1) {
		                      if (maskProps[j].pt.k.i) {
		                        convertPathsToAbsoluteValues(maskProps[j].pt.k);
		                      } else {
		                        kLen = maskProps[j].pt.k.length;
		                        for (k = 0; k < kLen; k += 1) {
		                          if (maskProps[j].pt.k[k].s) {
		                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
		                          }
		                          if (maskProps[j].pt.k[k].e) {
		                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
		                          }
		                        }
		                      }
		                    }
		                  }
		                  if (layerData.ty === 0) {
		                    layerData.layers = findCompLayers(layerData.refId, comps);
		                    completeLayers(layerData.layers, comps);
		                  } else if (layerData.ty === 4) {
		                    completeShapes(layerData.shapes);
		                  } else if (layerData.ty === 5) {
		                    completeText(layerData);
		                  }
		                }
		              }
		            }
		            function completeChars(chars, assets) {
		              if (chars) {
		                var i = 0;
		                var len = chars.length;
		                for (i = 0; i < len; i += 1) {
		                  if (chars[i].t === 1) {
		                    // var compData = findComp(chars[i].data.refId, assets);
		                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);
		                    // chars[i].data.ip = 0;
		                    // chars[i].data.op = 99999;
		                    // chars[i].data.st = 0;
		                    // chars[i].data.sr = 1;
		                    // chars[i].w = compData.w;
		                    // chars[i].data.ks = {
		                    //   a: { k: [0, 0, 0], a: 0 },
		                    //   p: { k: [0, -compData.h, 0], a: 0 },
		                    //   r: { k: 0, a: 0 },
		                    //   s: { k: [100, 100], a: 0 },
		                    //   o: { k: 100, a: 0 },
		                    // };
		                    completeLayers(chars[i].data.layers, assets);
		                  }
		                }
		              }
		            }
		            function findComp(id, comps) {
		              var i = 0;
		              var len = comps.length;
		              while (i < len) {
		                if (comps[i].id === id) {
		                  return comps[i];
		                }
		                i += 1;
		              }
		              return null;
		            }
		            function findCompLayers(id, comps) {
		              var comp = findComp(id, comps);
		              if (comp) {
		                if (!comp.layers.__used) {
		                  comp.layers.__used = true;
		                  return comp.layers;
		                }
		                return JSON.parse(JSON.stringify(comp.layers));
		              }
		              return null;
		            }
		            function completeShapes(arr) {
		              var i;
		              var len = arr.length;
		              var j;
		              var jLen;
		              for (i = len - 1; i >= 0; i -= 1) {
		                if (arr[i].ty === 'sh') {
		                  if (arr[i].ks.k.i) {
		                    convertPathsToAbsoluteValues(arr[i].ks.k);
		                  } else {
		                    jLen = arr[i].ks.k.length;
		                    for (j = 0; j < jLen; j += 1) {
		                      if (arr[i].ks.k[j].s) {
		                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
		                      }
		                      if (arr[i].ks.k[j].e) {
		                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
		                      }
		                    }
		                  }
		                } else if (arr[i].ty === 'gr') {
		                  completeShapes(arr[i].it);
		                }
		              }
		            }
		            function convertPathsToAbsoluteValues(path) {
		              var i;
		              var len = path.i.length;
		              for (i = 0; i < len; i += 1) {
		                path.i[i][0] += path.v[i][0];
		                path.i[i][1] += path.v[i][1];
		                path.o[i][0] += path.v[i][0];
		                path.o[i][1] += path.v[i][1];
		              }
		            }
		            function checkVersion(minimum, animVersionString) {
		              var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
		              if (minimum[0] > animVersion[0]) {
		                return true;
		              }
		              if (animVersion[0] > minimum[0]) {
		                return false;
		              }
		              if (minimum[1] > animVersion[1]) {
		                return true;
		              }
		              if (animVersion[1] > minimum[1]) {
		                return false;
		              }
		              if (minimum[2] > animVersion[2]) {
		                return true;
		              }
		              if (animVersion[2] > minimum[2]) {
		                return false;
		              }
		              return null;
		            }
		            var checkText = function () {
		              var minimumVersion = [4, 4, 14];
		              function updateTextLayer(textLayer) {
		                var documentData = textLayer.t.d;
		                textLayer.t.d = {
		                  k: [{
		                    s: documentData,
		                    t: 0
		                  }]
		                };
		              }
		              function iterateLayers(layers) {
		                var i;
		                var len = layers.length;
		                for (i = 0; i < len; i += 1) {
		                  if (layers[i].ty === 5) {
		                    updateTextLayer(layers[i]);
		                  }
		                }
		              }
		              return function (animationData) {
		                if (checkVersion(minimumVersion, animationData.v)) {
		                  iterateLayers(animationData.layers);
		                  if (animationData.assets) {
		                    var i;
		                    var len = animationData.assets.length;
		                    for (i = 0; i < len; i += 1) {
		                      if (animationData.assets[i].layers) {
		                        iterateLayers(animationData.assets[i].layers);
		                      }
		                    }
		                  }
		                }
		              };
		            }();
		            var checkChars = function () {
		              var minimumVersion = [4, 7, 99];
		              return function (animationData) {
		                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
		                  var i;
		                  var len = animationData.chars.length;
		                  for (i = 0; i < len; i += 1) {
		                    var charData = animationData.chars[i];
		                    if (charData.data && charData.data.shapes) {
		                      completeShapes(charData.data.shapes);
		                      charData.data.ip = 0;
		                      charData.data.op = 99999;
		                      charData.data.st = 0;
		                      charData.data.sr = 1;
		                      charData.data.ks = {
		                        p: {
		                          k: [0, 0],
		                          a: 0
		                        },
		                        s: {
		                          k: [100, 100],
		                          a: 0
		                        },
		                        a: {
		                          k: [0, 0],
		                          a: 0
		                        },
		                        r: {
		                          k: 0,
		                          a: 0
		                        },
		                        o: {
		                          k: 100,
		                          a: 0
		                        }
		                      };
		                      if (!animationData.chars[i].t) {
		                        charData.data.shapes.push({
		                          ty: 'no'
		                        });
		                        charData.data.shapes[0].it.push({
		                          p: {
		                            k: [0, 0],
		                            a: 0
		                          },
		                          s: {
		                            k: [100, 100],
		                            a: 0
		                          },
		                          a: {
		                            k: [0, 0],
		                            a: 0
		                          },
		                          r: {
		                            k: 0,
		                            a: 0
		                          },
		                          o: {
		                            k: 100,
		                            a: 0
		                          },
		                          sk: {
		                            k: 0,
		                            a: 0
		                          },
		                          sa: {
		                            k: 0,
		                            a: 0
		                          },
		                          ty: 'tr'
		                        });
		                      }
		                    }
		                  }
		                }
		              };
		            }();
		            var checkPathProperties = function () {
		              var minimumVersion = [5, 7, 15];
		              function updateTextLayer(textLayer) {
		                var pathData = textLayer.t.p;
		                if (typeof pathData.a === 'number') {
		                  pathData.a = {
		                    a: 0,
		                    k: pathData.a
		                  };
		                }
		                if (typeof pathData.p === 'number') {
		                  pathData.p = {
		                    a: 0,
		                    k: pathData.p
		                  };
		                }
		                if (typeof pathData.r === 'number') {
		                  pathData.r = {
		                    a: 0,
		                    k: pathData.r
		                  };
		                }
		              }
		              function iterateLayers(layers) {
		                var i;
		                var len = layers.length;
		                for (i = 0; i < len; i += 1) {
		                  if (layers[i].ty === 5) {
		                    updateTextLayer(layers[i]);
		                  }
		                }
		              }
		              return function (animationData) {
		                if (checkVersion(minimumVersion, animationData.v)) {
		                  iterateLayers(animationData.layers);
		                  if (animationData.assets) {
		                    var i;
		                    var len = animationData.assets.length;
		                    for (i = 0; i < len; i += 1) {
		                      if (animationData.assets[i].layers) {
		                        iterateLayers(animationData.assets[i].layers);
		                      }
		                    }
		                  }
		                }
		              };
		            }();
		            var checkColors = function () {
		              var minimumVersion = [4, 1, 9];
		              function iterateShapes(shapes) {
		                var i;
		                var len = shapes.length;
		                var j;
		                var jLen;
		                for (i = 0; i < len; i += 1) {
		                  if (shapes[i].ty === 'gr') {
		                    iterateShapes(shapes[i].it);
		                  } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
		                    if (shapes[i].c.k && shapes[i].c.k[0].i) {
		                      jLen = shapes[i].c.k.length;
		                      for (j = 0; j < jLen; j += 1) {
		                        if (shapes[i].c.k[j].s) {
		                          shapes[i].c.k[j].s[0] /= 255;
		                          shapes[i].c.k[j].s[1] /= 255;
		                          shapes[i].c.k[j].s[2] /= 255;
		                          shapes[i].c.k[j].s[3] /= 255;
		                        }
		                        if (shapes[i].c.k[j].e) {
		                          shapes[i].c.k[j].e[0] /= 255;
		                          shapes[i].c.k[j].e[1] /= 255;
		                          shapes[i].c.k[j].e[2] /= 255;
		                          shapes[i].c.k[j].e[3] /= 255;
		                        }
		                      }
		                    } else {
		                      shapes[i].c.k[0] /= 255;
		                      shapes[i].c.k[1] /= 255;
		                      shapes[i].c.k[2] /= 255;
		                      shapes[i].c.k[3] /= 255;
		                    }
		                  }
		                }
		              }
		              function iterateLayers(layers) {
		                var i;
		                var len = layers.length;
		                for (i = 0; i < len; i += 1) {
		                  if (layers[i].ty === 4) {
		                    iterateShapes(layers[i].shapes);
		                  }
		                }
		              }
		              return function (animationData) {
		                if (checkVersion(minimumVersion, animationData.v)) {
		                  iterateLayers(animationData.layers);
		                  if (animationData.assets) {
		                    var i;
		                    var len = animationData.assets.length;
		                    for (i = 0; i < len; i += 1) {
		                      if (animationData.assets[i].layers) {
		                        iterateLayers(animationData.assets[i].layers);
		                      }
		                    }
		                  }
		                }
		              };
		            }();
		            var checkShapes = function () {
		              var minimumVersion = [4, 4, 18];
		              function completeClosingShapes(arr) {
		                var i;
		                var len = arr.length;
		                var j;
		                var jLen;
		                for (i = len - 1; i >= 0; i -= 1) {
		                  if (arr[i].ty === 'sh') {
		                    if (arr[i].ks.k.i) {
		                      arr[i].ks.k.c = arr[i].closed;
		                    } else {
		                      jLen = arr[i].ks.k.length;
		                      for (j = 0; j < jLen; j += 1) {
		                        if (arr[i].ks.k[j].s) {
		                          arr[i].ks.k[j].s[0].c = arr[i].closed;
		                        }
		                        if (arr[i].ks.k[j].e) {
		                          arr[i].ks.k[j].e[0].c = arr[i].closed;
		                        }
		                      }
		                    }
		                  } else if (arr[i].ty === 'gr') {
		                    completeClosingShapes(arr[i].it);
		                  }
		                }
		              }
		              function iterateLayers(layers) {
		                var layerData;
		                var i;
		                var len = layers.length;
		                var j;
		                var jLen;
		                var k;
		                var kLen;
		                for (i = 0; i < len; i += 1) {
		                  layerData = layers[i];
		                  if (layerData.hasMask) {
		                    var maskProps = layerData.masksProperties;
		                    jLen = maskProps.length;
		                    for (j = 0; j < jLen; j += 1) {
		                      if (maskProps[j].pt.k.i) {
		                        maskProps[j].pt.k.c = maskProps[j].cl;
		                      } else {
		                        kLen = maskProps[j].pt.k.length;
		                        for (k = 0; k < kLen; k += 1) {
		                          if (maskProps[j].pt.k[k].s) {
		                            maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
		                          }
		                          if (maskProps[j].pt.k[k].e) {
		                            maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
		                          }
		                        }
		                      }
		                    }
		                  }
		                  if (layerData.ty === 4) {
		                    completeClosingShapes(layerData.shapes);
		                  }
		                }
		              }
		              return function (animationData) {
		                if (checkVersion(minimumVersion, animationData.v)) {
		                  iterateLayers(animationData.layers);
		                  if (animationData.assets) {
		                    var i;
		                    var len = animationData.assets.length;
		                    for (i = 0; i < len; i += 1) {
		                      if (animationData.assets[i].layers) {
		                        iterateLayers(animationData.assets[i].layers);
		                      }
		                    }
		                  }
		                }
		              };
		            }();
		            function completeData(animationData) {
		              if (animationData.__complete) {
		                return;
		              }
		              checkColors(animationData);
		              checkText(animationData);
		              checkChars(animationData);
		              checkPathProperties(animationData);
		              checkShapes(animationData);
		              completeLayers(animationData.layers, animationData.assets);
		              completeChars(animationData.chars, animationData.assets);
		              animationData.__complete = true;
		            }
		            function completeText(data) {
		              if (data.t.a.length === 0 && !('m' in data.t.p)) ;
		            }
		            var moduleOb = {};
		            moduleOb.completeData = completeData;
		            moduleOb.checkColors = checkColors;
		            moduleOb.checkChars = checkChars;
		            moduleOb.checkPathProperties = checkPathProperties;
		            moduleOb.checkShapes = checkShapes;
		            moduleOb.completeLayers = completeLayers;
		            return moduleOb;
		          }
		          if (!_workerSelf.dataManager) {
		            _workerSelf.dataManager = dataFunctionManager();
		          }
		          if (!_workerSelf.assetLoader) {
		            _workerSelf.assetLoader = function () {
		              function formatResponse(xhr) {
		                // using typeof doubles the time of execution of this method,
		                // so if available, it's better to use the header to validate the type
		                var contentTypeHeader = xhr.getResponseHeader('content-type');
		                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
		                  return xhr.response;
		                }
		                if (xhr.response && _typeof$5(xhr.response) === 'object') {
		                  return xhr.response;
		                }
		                if (xhr.response && typeof xhr.response === 'string') {
		                  return JSON.parse(xhr.response);
		                }
		                if (xhr.responseText) {
		                  return JSON.parse(xhr.responseText);
		                }
		                return null;
		              }
		              function loadAsset(path, fullPath, callback, errorCallback) {
		                var response;
		                var xhr = new XMLHttpRequest();
		                // set responseType after calling open or IE will break.
		                try {
		                  // This crashes on Android WebView prior to KitKat
		                  xhr.responseType = 'json';
		                } catch (err) {} // eslint-disable-line no-empty
		                xhr.onreadystatechange = function () {
		                  if (xhr.readyState === 4) {
		                    if (xhr.status === 200) {
		                      response = formatResponse(xhr);
		                      callback(response);
		                    } else {
		                      try {
		                        response = formatResponse(xhr);
		                        callback(response);
		                      } catch (err) {
		                        if (errorCallback) {
		                          errorCallback(err);
		                        }
		                      }
		                    }
		                  }
		                };
		                try {
		                  // Hack to workaround banner validation
		                  xhr.open(['G', 'E', 'T'].join(''), path, true);
		                } catch (error) {
		                  // Hack to workaround banner validation
		                  xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);
		                }
		                xhr.send();
		              }
		              return {
		                load: loadAsset
		              };
		            }();
		          }
		          if (e.data.type === 'loadAnimation') {
		            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
		              _workerSelf.dataManager.completeData(data);
		              _workerSelf.postMessage({
		                id: e.data.id,
		                payload: data,
		                status: 'success'
		              });
		            }, function () {
		              _workerSelf.postMessage({
		                id: e.data.id,
		                status: 'error'
		              });
		            });
		          } else if (e.data.type === 'complete') {
		            var animation = e.data.animation;
		            _workerSelf.dataManager.completeData(animation);
		            _workerSelf.postMessage({
		              id: e.data.id,
		              payload: animation,
		              status: 'success'
		            });
		          } else if (e.data.type === 'loadData') {
		            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
		              _workerSelf.postMessage({
		                id: e.data.id,
		                payload: data,
		                status: 'success'
		              });
		            }, function () {
		              _workerSelf.postMessage({
		                id: e.data.id,
		                status: 'error'
		              });
		            });
		          }
		        });
		        workerInstance.onmessage = function (event) {
		          var data = event.data;
		          var id = data.id;
		          var process = processes[id];
		          processes[id] = null;
		          if (data.status === 'success') {
		            process.onComplete(data.payload);
		          } else if (process.onError) {
		            process.onError();
		          }
		        };
		      }
		    }
		    function createProcess(onComplete, onError) {
		      _counterId += 1;
		      var id = 'processId_' + _counterId;
		      processes[id] = {
		        onComplete: onComplete,
		        onError: onError
		      };
		      return id;
		    }
		    function loadAnimation(path, onComplete, onError) {
		      setupWorker();
		      var processId = createProcess(onComplete, onError);
		      workerInstance.postMessage({
		        type: 'loadAnimation',
		        path: path,
		        fullPath: window.location.origin + window.location.pathname,
		        id: processId
		      });
		    }
		    function loadData(path, onComplete, onError) {
		      setupWorker();
		      var processId = createProcess(onComplete, onError);
		      workerInstance.postMessage({
		        type: 'loadData',
		        path: path,
		        fullPath: window.location.origin + window.location.pathname,
		        id: processId
		      });
		    }
		    function completeAnimation(anim, onComplete, onError) {
		      setupWorker();
		      var processId = createProcess(onComplete, onError);
		      workerInstance.postMessage({
		        type: 'complete',
		        animation: anim,
		        id: processId
		      });
		    }
		    return {
		      loadAnimation: loadAnimation,
		      loadData: loadData,
		      completeAnimation: completeAnimation
		    };
		  }();

		  var ImagePreloader = function () {
		    var proxyImage = function () {
		      var canvas = createTag('canvas');
		      canvas.width = 1;
		      canvas.height = 1;
		      var ctx = canvas.getContext('2d');
		      ctx.fillStyle = 'rgba(0,0,0,0)';
		      ctx.fillRect(0, 0, 1, 1);
		      return canvas;
		    }();
		    function imageLoaded() {
		      this.loadedAssets += 1;
		      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
		        if (this.imagesLoadedCb) {
		          this.imagesLoadedCb(null);
		        }
		      }
		    }
		    function footageLoaded() {
		      this.loadedFootagesCount += 1;
		      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
		        if (this.imagesLoadedCb) {
		          this.imagesLoadedCb(null);
		        }
		      }
		    }
		    function getAssetsPath(assetData, assetsPath, originalPath) {
		      var path = '';
		      if (assetData.e) {
		        path = assetData.p;
		      } else if (assetsPath) {
		        var imagePath = assetData.p;
		        if (imagePath.indexOf('images/') !== -1) {
		          imagePath = imagePath.split('/')[1];
		        }
		        path = assetsPath + imagePath;
		      } else {
		        path = originalPath;
		        path += assetData.u ? assetData.u : '';
		        path += assetData.p;
		      }
		      return path;
		    }
		    function testImageLoaded(img) {
		      var _count = 0;
		      var intervalId = setInterval(function () {
		        var box = img.getBBox();
		        if (box.width || _count > 500) {
		          this._imageLoaded();
		          clearInterval(intervalId);
		        }
		        _count += 1;
		      }.bind(this), 50);
		    }
		    function createImageData(assetData) {
		      var path = getAssetsPath(assetData, this.assetsPath, this.path);
		      var img = createNS('image');
		      if (isSafari) {
		        this.testImageLoaded(img);
		      } else {
		        img.addEventListener('load', this._imageLoaded, false);
		      }
		      img.addEventListener('error', function () {
		        ob.img = proxyImage;
		        this._imageLoaded();
		      }.bind(this), false);
		      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
		      if (this._elementHelper.append) {
		        this._elementHelper.append(img);
		      } else {
		        this._elementHelper.appendChild(img);
		      }
		      var ob = {
		        img: img,
		        assetData: assetData
		      };
		      return ob;
		    }
		    function createImgData(assetData) {
		      var path = getAssetsPath(assetData, this.assetsPath, this.path);
		      var img = createTag('img');
		      img.crossOrigin = 'anonymous';
		      img.addEventListener('load', this._imageLoaded, false);
		      img.addEventListener('error', function () {
		        ob.img = proxyImage;
		        this._imageLoaded();
		      }.bind(this), false);
		      img.src = path;
		      var ob = {
		        img: img,
		        assetData: assetData
		      };
		      return ob;
		    }
		    function createFootageData(data) {
		      var ob = {
		        assetData: data
		      };
		      var path = getAssetsPath(data, this.assetsPath, this.path);
		      dataManager.loadData(path, function (footageData) {
		        ob.img = footageData;
		        this._footageLoaded();
		      }.bind(this), function () {
		        ob.img = {};
		        this._footageLoaded();
		      }.bind(this));
		      return ob;
		    }
		    function loadAssets(assets, cb) {
		      this.imagesLoadedCb = cb;
		      var i;
		      var len = assets.length;
		      for (i = 0; i < len; i += 1) {
		        if (!assets[i].layers) {
		          if (!assets[i].t || assets[i].t === 'seq') {
		            this.totalImages += 1;
		            this.images.push(this._createImageData(assets[i]));
		          } else if (assets[i].t === 3) {
		            this.totalFootages += 1;
		            this.images.push(this.createFootageData(assets[i]));
		          }
		        }
		      }
		    }
		    function setPath(path) {
		      this.path = path || '';
		    }
		    function setAssetsPath(path) {
		      this.assetsPath = path || '';
		    }
		    function getAsset(assetData) {
		      var i = 0;
		      var len = this.images.length;
		      while (i < len) {
		        if (this.images[i].assetData === assetData) {
		          return this.images[i].img;
		        }
		        i += 1;
		      }
		      return null;
		    }
		    function destroy() {
		      this.imagesLoadedCb = null;
		      this.images.length = 0;
		    }
		    function loadedImages() {
		      return this.totalImages === this.loadedAssets;
		    }
		    function loadedFootages() {
		      return this.totalFootages === this.loadedFootagesCount;
		    }
		    function setCacheType(type, elementHelper) {
		      if (type === 'svg') {
		        this._elementHelper = elementHelper;
		        this._createImageData = this.createImageData.bind(this);
		      } else {
		        this._createImageData = this.createImgData.bind(this);
		      }
		    }
		    function ImagePreloaderFactory() {
		      this._imageLoaded = imageLoaded.bind(this);
		      this._footageLoaded = footageLoaded.bind(this);
		      this.testImageLoaded = testImageLoaded.bind(this);
		      this.createFootageData = createFootageData.bind(this);
		      this.assetsPath = '';
		      this.path = '';
		      this.totalImages = 0;
		      this.totalFootages = 0;
		      this.loadedAssets = 0;
		      this.loadedFootagesCount = 0;
		      this.imagesLoadedCb = null;
		      this.images = [];
		    }
		    ImagePreloaderFactory.prototype = {
		      loadAssets: loadAssets,
		      setAssetsPath: setAssetsPath,
		      setPath: setPath,
		      loadedImages: loadedImages,
		      loadedFootages: loadedFootages,
		      destroy: destroy,
		      getAsset: getAsset,
		      createImgData: createImgData,
		      createImageData: createImageData,
		      imageLoaded: imageLoaded,
		      footageLoaded: footageLoaded,
		      setCacheType: setCacheType
		    };
		    return ImagePreloaderFactory;
		  }();

		  function BaseEvent() {}
		  BaseEvent.prototype = {
		    triggerEvent: function triggerEvent(eventName, args) {
		      if (this._cbs[eventName]) {
		        var callbacks = this._cbs[eventName];
		        for (var i = 0; i < callbacks.length; i += 1) {
		          callbacks[i](args);
		        }
		      }
		    },
		    addEventListener: function addEventListener(eventName, callback) {
		      if (!this._cbs[eventName]) {
		        this._cbs[eventName] = [];
		      }
		      this._cbs[eventName].push(callback);
		      return function () {
		        this.removeEventListener(eventName, callback);
		      }.bind(this);
		    },
		    removeEventListener: function removeEventListener(eventName, callback) {
		      if (!callback) {
		        this._cbs[eventName] = null;
		      } else if (this._cbs[eventName]) {
		        var i = 0;
		        var len = this._cbs[eventName].length;
		        while (i < len) {
		          if (this._cbs[eventName][i] === callback) {
		            this._cbs[eventName].splice(i, 1);
		            i -= 1;
		            len -= 1;
		          }
		          i += 1;
		        }
		        if (!this._cbs[eventName].length) {
		          this._cbs[eventName] = null;
		        }
		      }
		    }
		  };

		  var markerParser = function () {
		    function parsePayloadLines(payload) {
		      var lines = payload.split('\r\n');
		      var keys = {};
		      var line;
		      var keysCount = 0;
		      for (var i = 0; i < lines.length; i += 1) {
		        line = lines[i].split(':');
		        if (line.length === 2) {
		          keys[line[0]] = line[1].trim();
		          keysCount += 1;
		        }
		      }
		      if (keysCount === 0) {
		        throw new Error();
		      }
		      return keys;
		    }
		    return function (_markers) {
		      var markers = [];
		      for (var i = 0; i < _markers.length; i += 1) {
		        var _marker = _markers[i];
		        var markerData = {
		          time: _marker.tm,
		          duration: _marker.dr
		        };
		        try {
		          markerData.payload = JSON.parse(_markers[i].cm);
		        } catch (_) {
		          try {
		            markerData.payload = parsePayloadLines(_markers[i].cm);
		          } catch (__) {
		            markerData.payload = {
		              name: _markers[i].cm
		            };
		          }
		        }
		        markers.push(markerData);
		      }
		      return markers;
		    };
		  }();

		  var ProjectInterface = function () {
		    function registerComposition(comp) {
		      this.compositions.push(comp);
		    }
		    return function () {
		      function _thisProjectFunction(name) {
		        var i = 0;
		        var len = this.compositions.length;
		        while (i < len) {
		          if (this.compositions[i].data && this.compositions[i].data.nm === name) {
		            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
		              this.compositions[i].prepareFrame(this.currentFrame);
		            }
		            return this.compositions[i].compInterface;
		          }
		          i += 1;
		        }
		        return null;
		      }
		      _thisProjectFunction.compositions = [];
		      _thisProjectFunction.currentFrame = 0;
		      _thisProjectFunction.registerComposition = registerComposition;
		      return _thisProjectFunction;
		    };
		  }();

		  var renderers = {};
		  var registerRenderer = function registerRenderer(key, value) {
		    renderers[key] = value;
		  };
		  function getRenderer(key) {
		    return renderers[key];
		  }
		  function getRegisteredRenderer() {
		    // Returns canvas by default for compatibility
		    if (renderers.canvas) {
		      return 'canvas';
		    }
		    // Returns any renderer that is registered
		    for (var key in renderers) {
		      if (renderers[key]) {
		        return key;
		      }
		    }
		    return '';
		  }

		  function _typeof$4(o) { "@babel/helpers - typeof"; return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$4(o); }
		  var AnimationItem = function AnimationItem() {
		    this._cbs = [];
		    this.name = '';
		    this.path = '';
		    this.isLoaded = false;
		    this.currentFrame = 0;
		    this.currentRawFrame = 0;
		    this.firstFrame = 0;
		    this.totalFrames = 0;
		    this.frameRate = 0;
		    this.frameMult = 0;
		    this.playSpeed = 1;
		    this.playDirection = 1;
		    this.playCount = 0;
		    this.animationData = {};
		    this.assets = [];
		    this.isPaused = true;
		    this.autoplay = false;
		    this.loop = true;
		    this.renderer = null;
		    this.animationID = createElementID();
		    this.assetsPath = '';
		    this.timeCompleted = 0;
		    this.segmentPos = 0;
		    this.isSubframeEnabled = getSubframeEnabled();
		    this.segments = [];
		    this._idle = true;
		    this._completedLoop = false;
		    this.projectInterface = ProjectInterface();
		    this.imagePreloader = new ImagePreloader();
		    this.audioController = audioControllerFactory();
		    this.markers = [];
		    this.configAnimation = this.configAnimation.bind(this);
		    this.onSetupError = this.onSetupError.bind(this);
		    this.onSegmentComplete = this.onSegmentComplete.bind(this);
		    this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);
		    this.expressionsPlugin = getExpressionsPlugin();
		  };
		  extendPrototype([BaseEvent], AnimationItem);
		  AnimationItem.prototype.setParams = function (params) {
		    if (params.wrapper || params.container) {
		      this.wrapper = params.wrapper || params.container;
		    }
		    var animType = 'svg';
		    if (params.animType) {
		      animType = params.animType;
		    } else if (params.renderer) {
		      animType = params.renderer;
		    }
		    var RendererClass = getRenderer(animType);
		    this.renderer = new RendererClass(this, params.rendererSettings);
		    this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
		    this.renderer.setProjectInterface(this.projectInterface);
		    this.animType = animType;
		    if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {
		      this.loop = true;
		    } else if (params.loop === false) {
		      this.loop = false;
		    } else {
		      this.loop = parseInt(params.loop, 10);
		    }
		    this.autoplay = 'autoplay' in params ? params.autoplay : true;
		    this.name = params.name ? params.name : '';
		    this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
		    this.assetsPath = params.assetsPath;
		    this.initialSegment = params.initialSegment;
		    if (params.audioFactory) {
		      this.audioController.setAudioFactory(params.audioFactory);
		    }
		    if (params.animationData) {
		      this.setupAnimation(params.animationData);
		    } else if (params.path) {
		      if (params.path.lastIndexOf('\\') !== -1) {
		        this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
		      } else {
		        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
		      }
		      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
		      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
		      dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
		    }
		  };
		  AnimationItem.prototype.onSetupError = function () {
		    this.trigger('data_failed');
		  };
		  AnimationItem.prototype.setupAnimation = function (data) {
		    dataManager.completeAnimation(data, this.configAnimation);
		  };
		  AnimationItem.prototype.setData = function (wrapper, animationData) {
		    if (animationData) {
		      if (_typeof$4(animationData) !== 'object') {
		        animationData = JSON.parse(animationData);
		      }
		    }
		    var params = {
		      wrapper: wrapper,
		      animationData: animationData
		    };
		    var wrapperAttributes = wrapper.attributes;
		    params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
		    params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';
		    var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
		    if (loop === 'false') {
		      params.loop = false;
		    } else if (loop === 'true') {
		      params.loop = true;
		    } else if (loop !== '') {
		      params.loop = parseInt(loop, 10);
		    }
		    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
		    params.autoplay = autoplay !== 'false';
		    params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
		    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
		    ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';
		    if (prerender === 'false') {
		      params.prerender = false;
		    }
		    if (!params.path) {
		      this.trigger('destroy');
		    } else {
		      this.setParams(params);
		    }
		  };
		  AnimationItem.prototype.includeLayers = function (data) {
		    if (data.op > this.animationData.op) {
		      this.animationData.op = data.op;
		      this.totalFrames = Math.floor(data.op - this.animationData.ip);
		    }
		    var layers = this.animationData.layers;
		    var i;
		    var len = layers.length;
		    var newLayers = data.layers;
		    var j;
		    var jLen = newLayers.length;
		    for (j = 0; j < jLen; j += 1) {
		      i = 0;
		      while (i < len) {
		        if (layers[i].id === newLayers[j].id) {
		          layers[i] = newLayers[j];
		          break;
		        }
		        i += 1;
		      }
		    }
		    if (data.chars || data.fonts) {
		      this.renderer.globalData.fontManager.addChars(data.chars);
		      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
		    }
		    if (data.assets) {
		      len = data.assets.length;
		      for (i = 0; i < len; i += 1) {
		        this.animationData.assets.push(data.assets[i]);
		      }
		    }
		    this.animationData.__complete = false;
		    dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
		  };
		  AnimationItem.prototype.onSegmentComplete = function (data) {
		    this.animationData = data;
		    var expressionsPlugin = getExpressionsPlugin();
		    if (expressionsPlugin) {
		      expressionsPlugin.initExpressions(this);
		    }
		    this.loadNextSegment();
		  };
		  AnimationItem.prototype.loadNextSegment = function () {
		    var segments = this.animationData.segments;
		    if (!segments || segments.length === 0 || !this.autoloadSegments) {
		      this.trigger('data_ready');
		      this.timeCompleted = this.totalFrames;
		      return;
		    }
		    var segment = segments.shift();
		    this.timeCompleted = segment.time * this.frameRate;
		    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
		    this.segmentPos += 1;
		    dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
		      this.trigger('data_failed');
		    }.bind(this));
		  };
		  AnimationItem.prototype.loadSegments = function () {
		    var segments = this.animationData.segments;
		    if (!segments) {
		      this.timeCompleted = this.totalFrames;
		    }
		    this.loadNextSegment();
		  };
		  AnimationItem.prototype.imagesLoaded = function () {
		    this.trigger('loaded_images');
		    this.checkLoaded();
		  };
		  AnimationItem.prototype.preloadImages = function () {
		    this.imagePreloader.setAssetsPath(this.assetsPath);
		    this.imagePreloader.setPath(this.path);
		    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
		  };
		  AnimationItem.prototype.configAnimation = function (animData) {
		    if (!this.renderer) {
		      return;
		    }
		    try {
		      this.animationData = animData;
		      if (this.initialSegment) {
		        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
		        this.firstFrame = Math.round(this.initialSegment[0]);
		      } else {
		        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
		        this.firstFrame = Math.round(this.animationData.ip);
		      }
		      this.renderer.configAnimation(animData);
		      if (!animData.assets) {
		        animData.assets = [];
		      }
		      this.assets = this.animationData.assets;
		      this.frameRate = this.animationData.fr;
		      this.frameMult = this.animationData.fr / 1000;
		      this.renderer.searchExtraCompositions(animData.assets);
		      this.markers = markerParser(animData.markers || []);
		      this.trigger('config_ready');
		      this.preloadImages();
		      this.loadSegments();
		      this.updaFrameModifier();
		      this.waitForFontsLoaded();
		      if (this.isPaused) {
		        this.audioController.pause();
		      }
		    } catch (error) {
		      this.triggerConfigError(error);
		    }
		  };
		  AnimationItem.prototype.waitForFontsLoaded = function () {
		    if (!this.renderer) {
		      return;
		    }
		    if (this.renderer.globalData.fontManager.isLoaded) {
		      this.checkLoaded();
		    } else {
		      setTimeout(this.waitForFontsLoaded.bind(this), 20);
		    }
		  };
		  AnimationItem.prototype.checkLoaded = function () {
		    if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {
		      this.isLoaded = true;
		      var expressionsPlugin = getExpressionsPlugin();
		      if (expressionsPlugin) {
		        expressionsPlugin.initExpressions(this);
		      }
		      this.renderer.initItems();
		      setTimeout(function () {
		        this.trigger('DOMLoaded');
		      }.bind(this), 0);
		      this.gotoFrame();
		      if (this.autoplay) {
		        this.play();
		      }
		    }
		  };
		  AnimationItem.prototype.resize = function (width, height) {
		    // Adding this validation for backwards compatibility in case an event object was being passed down
		    var _width = typeof width === 'number' ? width : undefined;
		    var _height = typeof height === 'number' ? height : undefined;
		    this.renderer.updateContainerSize(_width, _height);
		  };
		  AnimationItem.prototype.setSubframe = function (flag) {
		    this.isSubframeEnabled = !!flag;
		  };
		  AnimationItem.prototype.gotoFrame = function () {
		    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

		    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
		      this.currentFrame = this.timeCompleted;
		    }
		    this.trigger('enterFrame');
		    this.renderFrame();
		    this.trigger('drawnFrame');
		  };
		  AnimationItem.prototype.renderFrame = function () {
		    if (this.isLoaded === false || !this.renderer) {
		      return;
		    }
		    try {
		      if (this.expressionsPlugin) {
		        this.expressionsPlugin.resetFrame();
		      }
		      this.renderer.renderFrame(this.currentFrame + this.firstFrame);
		    } catch (error) {
		      this.triggerRenderFrameError(error);
		    }
		  };
		  AnimationItem.prototype.play = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    if (this.isPaused === true) {
		      this.isPaused = false;
		      this.trigger('_play');
		      this.audioController.resume();
		      if (this._idle) {
		        this._idle = false;
		        this.trigger('_active');
		      }
		    }
		  };
		  AnimationItem.prototype.pause = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    if (this.isPaused === false) {
		      this.isPaused = true;
		      this.trigger('_pause');
		      this._idle = true;
		      this.trigger('_idle');
		      this.audioController.pause();
		    }
		  };
		  AnimationItem.prototype.togglePause = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    if (this.isPaused === true) {
		      this.play();
		    } else {
		      this.pause();
		    }
		  };
		  AnimationItem.prototype.stop = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    this.pause();
		    this.playCount = 0;
		    this._completedLoop = false;
		    this.setCurrentRawFrameValue(0);
		  };
		  AnimationItem.prototype.getMarkerData = function (markerName) {
		    var marker;
		    for (var i = 0; i < this.markers.length; i += 1) {
		      marker = this.markers[i];
		      if (marker.payload && marker.payload.name === markerName) {
		        return marker;
		      }
		    }
		    return null;
		  };
		  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    var numValue = Number(value);
		    if (isNaN(numValue)) {
		      var marker = this.getMarkerData(value);
		      if (marker) {
		        this.goToAndStop(marker.time, true);
		      }
		    } else if (isFrame) {
		      this.setCurrentRawFrameValue(value);
		    } else {
		      this.setCurrentRawFrameValue(value * this.frameModifier);
		    }
		    this.pause();
		  };
		  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    var numValue = Number(value);
		    if (isNaN(numValue)) {
		      var marker = this.getMarkerData(value);
		      if (marker) {
		        if (!marker.duration) {
		          this.goToAndStop(marker.time, true);
		        } else {
		          this.playSegments([marker.time, marker.time + marker.duration], true);
		        }
		      }
		    } else {
		      this.goToAndStop(numValue, isFrame, name);
		    }
		    this.play();
		  };
		  AnimationItem.prototype.advanceTime = function (value) {
		    if (this.isPaused === true || this.isLoaded === false) {
		      return;
		    }
		    var nextValue = this.currentRawFrame + value * this.frameModifier;
		    var _isComplete = false;
		    // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
		    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
		    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
		      if (!this.loop || this.playCount === this.loop) {
		        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
		          _isComplete = true;
		          nextValue = this.totalFrames - 1;
		        }
		      } else if (nextValue >= this.totalFrames) {
		        this.playCount += 1;
		        if (!this.checkSegments(nextValue % this.totalFrames)) {
		          this.setCurrentRawFrameValue(nextValue % this.totalFrames);
		          this._completedLoop = true;
		          this.trigger('loopComplete');
		        }
		      } else {
		        this.setCurrentRawFrameValue(nextValue);
		      }
		    } else if (nextValue < 0) {
		      if (!this.checkSegments(nextValue % this.totalFrames)) {
		        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
		          // eslint-disable-line no-plusplus
		          this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
		          if (!this._completedLoop) {
		            this._completedLoop = true;
		          } else {
		            this.trigger('loopComplete');
		          }
		        } else {
		          _isComplete = true;
		          nextValue = 0;
		        }
		      }
		    } else {
		      this.setCurrentRawFrameValue(nextValue);
		    }
		    if (_isComplete) {
		      this.setCurrentRawFrameValue(nextValue);
		      this.pause();
		      this.trigger('complete');
		    }
		  };
		  AnimationItem.prototype.adjustSegment = function (arr, offset) {
		    this.playCount = 0;
		    if (arr[1] < arr[0]) {
		      if (this.frameModifier > 0) {
		        if (this.playSpeed < 0) {
		          this.setSpeed(-this.playSpeed);
		        } else {
		          this.setDirection(-1);
		        }
		      }
		      this.totalFrames = arr[0] - arr[1];
		      this.timeCompleted = this.totalFrames;
		      this.firstFrame = arr[1];
		      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
		    } else if (arr[1] > arr[0]) {
		      if (this.frameModifier < 0) {
		        if (this.playSpeed < 0) {
		          this.setSpeed(-this.playSpeed);
		        } else {
		          this.setDirection(1);
		        }
		      }
		      this.totalFrames = arr[1] - arr[0];
		      this.timeCompleted = this.totalFrames;
		      this.firstFrame = arr[0];
		      this.setCurrentRawFrameValue(0.001 + offset);
		    }
		    this.trigger('segmentStart');
		  };
		  AnimationItem.prototype.setSegment = function (init, end) {
		    var pendingFrame = -1;
		    if (this.isPaused) {
		      if (this.currentRawFrame + this.firstFrame < init) {
		        pendingFrame = init;
		      } else if (this.currentRawFrame + this.firstFrame > end) {
		        pendingFrame = end - init;
		      }
		    }
		    this.firstFrame = init;
		    this.totalFrames = end - init;
		    this.timeCompleted = this.totalFrames;
		    if (pendingFrame !== -1) {
		      this.goToAndStop(pendingFrame, true);
		    }
		  };
		  AnimationItem.prototype.playSegments = function (arr, forceFlag) {
		    if (forceFlag) {
		      this.segments.length = 0;
		    }
		    if (_typeof$4(arr[0]) === 'object') {
		      var i;
		      var len = arr.length;
		      for (i = 0; i < len; i += 1) {
		        this.segments.push(arr[i]);
		      }
		    } else {
		      this.segments.push(arr);
		    }
		    if (this.segments.length && forceFlag) {
		      this.adjustSegment(this.segments.shift(), 0);
		    }
		    if (this.isPaused) {
		      this.play();
		    }
		  };
		  AnimationItem.prototype.resetSegments = function (forceFlag) {
		    this.segments.length = 0;
		    this.segments.push([this.animationData.ip, this.animationData.op]);
		    if (forceFlag) {
		      this.checkSegments(0);
		    }
		  };
		  AnimationItem.prototype.checkSegments = function (offset) {
		    if (this.segments.length) {
		      this.adjustSegment(this.segments.shift(), offset);
		      return true;
		    }
		    return false;
		  };
		  AnimationItem.prototype.destroy = function (name) {
		    if (name && this.name !== name || !this.renderer) {
		      return;
		    }
		    this.renderer.destroy();
		    this.imagePreloader.destroy();
		    this.trigger('destroy');
		    this._cbs = null;
		    this.onEnterFrame = null;
		    this.onLoopComplete = null;
		    this.onComplete = null;
		    this.onSegmentStart = null;
		    this.onDestroy = null;
		    this.renderer = null;
		    this.expressionsPlugin = null;
		    this.imagePreloader = null;
		    this.projectInterface = null;
		  };
		  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
		    this.currentRawFrame = value;
		    this.gotoFrame();
		  };
		  AnimationItem.prototype.setSpeed = function (val) {
		    this.playSpeed = val;
		    this.updaFrameModifier();
		  };
		  AnimationItem.prototype.setDirection = function (val) {
		    this.playDirection = val < 0 ? -1 : 1;
		    this.updaFrameModifier();
		  };
		  AnimationItem.prototype.setLoop = function (isLooping) {
		    this.loop = isLooping;
		  };
		  AnimationItem.prototype.setVolume = function (val, name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    this.audioController.setVolume(val);
		  };
		  AnimationItem.prototype.getVolume = function () {
		    return this.audioController.getVolume();
		  };
		  AnimationItem.prototype.mute = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    this.audioController.mute();
		  };
		  AnimationItem.prototype.unmute = function (name) {
		    if (name && this.name !== name) {
		      return;
		    }
		    this.audioController.unmute();
		  };
		  AnimationItem.prototype.updaFrameModifier = function () {
		    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
		    this.audioController.setRate(this.playSpeed * this.playDirection);
		  };
		  AnimationItem.prototype.getPath = function () {
		    return this.path;
		  };
		  AnimationItem.prototype.getAssetsPath = function (assetData) {
		    var path = '';
		    if (assetData.e) {
		      path = assetData.p;
		    } else if (this.assetsPath) {
		      var imagePath = assetData.p;
		      if (imagePath.indexOf('images/') !== -1) {
		        imagePath = imagePath.split('/')[1];
		      }
		      path = this.assetsPath + imagePath;
		    } else {
		      path = this.path;
		      path += assetData.u ? assetData.u : '';
		      path += assetData.p;
		    }
		    return path;
		  };
		  AnimationItem.prototype.getAssetData = function (id) {
		    var i = 0;
		    var len = this.assets.length;
		    while (i < len) {
		      if (id === this.assets[i].id) {
		        return this.assets[i];
		      }
		      i += 1;
		    }
		    return null;
		  };
		  AnimationItem.prototype.hide = function () {
		    this.renderer.hide();
		  };
		  AnimationItem.prototype.show = function () {
		    this.renderer.show();
		  };
		  AnimationItem.prototype.getDuration = function (isFrame) {
		    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
		  };
		  AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {
		    try {
		      var element = this.renderer.getElementByPath(path);
		      element.updateDocumentData(documentData, index);
		    } catch (error) {
		      // TODO: decide how to handle catch case
		    }
		  };
		  AnimationItem.prototype.trigger = function (name) {
		    if (this._cbs && this._cbs[name]) {
		      switch (name) {
		        case 'enterFrame':
		          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
		          break;
		        case 'drawnFrame':
		          this.drawnFrameEvent.currentTime = this.currentFrame;
		          this.drawnFrameEvent.totalTime = this.totalFrames;
		          this.drawnFrameEvent.direction = this.frameModifier;
		          this.triggerEvent(name, this.drawnFrameEvent);
		          break;
		        case 'loopComplete':
		          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
		          break;
		        case 'complete':
		          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
		          break;
		        case 'segmentStart':
		          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
		          break;
		        case 'destroy':
		          this.triggerEvent(name, new BMDestroyEvent(name, this));
		          break;
		        default:
		          this.triggerEvent(name);
		      }
		    }
		    if (name === 'enterFrame' && this.onEnterFrame) {
		      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
		    }
		    if (name === 'loopComplete' && this.onLoopComplete) {
		      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
		    }
		    if (name === 'complete' && this.onComplete) {
		      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
		    }
		    if (name === 'segmentStart' && this.onSegmentStart) {
		      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
		    }
		    if (name === 'destroy' && this.onDestroy) {
		      this.onDestroy.call(this, new BMDestroyEvent(name, this));
		    }
		  };
		  AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
		    var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
		    this.triggerEvent('error', error);
		    if (this.onError) {
		      this.onError.call(this, error);
		    }
		  };
		  AnimationItem.prototype.triggerConfigError = function (nativeError) {
		    var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
		    this.triggerEvent('error', error);
		    if (this.onError) {
		      this.onError.call(this, error);
		    }
		  };

		  var animationManager = function () {
		    var moduleOb = {};
		    var registeredAnimations = [];
		    var initTime = 0;
		    var len = 0;
		    var playingAnimationsNum = 0;
		    var _stopped = true;
		    var _isFrozen = false;
		    function removeElement(ev) {
		      var i = 0;
		      var animItem = ev.target;
		      while (i < len) {
		        if (registeredAnimations[i].animation === animItem) {
		          registeredAnimations.splice(i, 1);
		          i -= 1;
		          len -= 1;
		          if (!animItem.isPaused) {
		            subtractPlayingCount();
		          }
		        }
		        i += 1;
		      }
		    }
		    function registerAnimation(element, animationData) {
		      if (!element) {
		        return null;
		      }
		      var i = 0;
		      while (i < len) {
		        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
		          return registeredAnimations[i].animation;
		        }
		        i += 1;
		      }
		      var animItem = new AnimationItem();
		      setupAnimation(animItem, element);
		      animItem.setData(element, animationData);
		      return animItem;
		    }
		    function getRegisteredAnimations() {
		      var i;
		      var lenAnims = registeredAnimations.length;
		      var animations = [];
		      for (i = 0; i < lenAnims; i += 1) {
		        animations.push(registeredAnimations[i].animation);
		      }
		      return animations;
		    }
		    function addPlayingCount() {
		      playingAnimationsNum += 1;
		      activate();
		    }
		    function subtractPlayingCount() {
		      playingAnimationsNum -= 1;
		    }
		    function setupAnimation(animItem, element) {
		      animItem.addEventListener('destroy', removeElement);
		      animItem.addEventListener('_active', addPlayingCount);
		      animItem.addEventListener('_idle', subtractPlayingCount);
		      registeredAnimations.push({
		        elem: element,
		        animation: animItem
		      });
		      len += 1;
		    }
		    function loadAnimation(params) {
		      var animItem = new AnimationItem();
		      setupAnimation(animItem, null);
		      animItem.setParams(params);
		      return animItem;
		    }
		    function setSpeed(val, animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.setSpeed(val, animation);
		      }
		    }
		    function setDirection(val, animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.setDirection(val, animation);
		      }
		    }
		    function play(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.play(animation);
		      }
		    }
		    function resume(nowTime) {
		      var elapsedTime = nowTime - initTime;
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.advanceTime(elapsedTime);
		      }
		      initTime = nowTime;
		      if (playingAnimationsNum && !_isFrozen) {
		        window.requestAnimationFrame(resume);
		      } else {
		        _stopped = true;
		      }
		    }
		    function first(nowTime) {
		      initTime = nowTime;
		      window.requestAnimationFrame(resume);
		    }
		    function pause(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.pause(animation);
		      }
		    }
		    function goToAndStop(value, isFrame, animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
		      }
		    }
		    function stop(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.stop(animation);
		      }
		    }
		    function togglePause(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.togglePause(animation);
		      }
		    }
		    function destroy(animation) {
		      var i;
		      for (i = len - 1; i >= 0; i -= 1) {
		        registeredAnimations[i].animation.destroy(animation);
		      }
		    }
		    function searchAnimations(animationData, standalone, renderer) {
		      var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
		      var i;
		      var lenAnims = animElements.length;
		      for (i = 0; i < lenAnims; i += 1) {
		        if (renderer) {
		          animElements[i].setAttribute('data-bm-type', renderer);
		        }
		        registerAnimation(animElements[i], animationData);
		      }
		      if (standalone && lenAnims === 0) {
		        if (!renderer) {
		          renderer = 'svg';
		        }
		        var body = document.getElementsByTagName('body')[0];
		        body.innerText = '';
		        var div = createTag('div');
		        div.style.width = '100%';
		        div.style.height = '100%';
		        div.setAttribute('data-bm-type', renderer);
		        body.appendChild(div);
		        registerAnimation(div, animationData);
		      }
		    }
		    function resize() {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.resize();
		      }
		    }
		    function activate() {
		      if (!_isFrozen && playingAnimationsNum) {
		        if (_stopped) {
		          window.requestAnimationFrame(first);
		          _stopped = false;
		        }
		      }
		    }
		    function freeze() {
		      _isFrozen = true;
		    }
		    function unfreeze() {
		      _isFrozen = false;
		      activate();
		    }
		    function setVolume(val, animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.setVolume(val, animation);
		      }
		    }
		    function mute(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.mute(animation);
		      }
		    }
		    function unmute(animation) {
		      var i;
		      for (i = 0; i < len; i += 1) {
		        registeredAnimations[i].animation.unmute(animation);
		      }
		    }
		    moduleOb.registerAnimation = registerAnimation;
		    moduleOb.loadAnimation = loadAnimation;
		    moduleOb.setSpeed = setSpeed;
		    moduleOb.setDirection = setDirection;
		    moduleOb.play = play;
		    moduleOb.pause = pause;
		    moduleOb.stop = stop;
		    moduleOb.togglePause = togglePause;
		    moduleOb.searchAnimations = searchAnimations;
		    moduleOb.resize = resize;
		    // moduleOb.start = start;
		    moduleOb.goToAndStop = goToAndStop;
		    moduleOb.destroy = destroy;
		    moduleOb.freeze = freeze;
		    moduleOb.unfreeze = unfreeze;
		    moduleOb.setVolume = setVolume;
		    moduleOb.mute = mute;
		    moduleOb.unmute = unmute;
		    moduleOb.getRegisteredAnimations = getRegisteredAnimations;
		    return moduleOb;
		  }();

		  /* eslint-disable */
		  var BezierFactory = function () {
		    /**
		       * BezierEasing - use bezier curve for transition easing function
		       * by Gaëtan Renaudeau 2014 - 2015 – MIT License
		       *
		       * Credits: is based on Firefox's nsSMILKeySpline.cpp
		       * Usage:
		       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
		       * spline.get(x) => returns the easing value | x must be in [0, 1] range
		       *
		       */

		    var ob = {};
		    ob.getBezierEasing = getBezierEasing;
		    var beziers = {};
		    function getBezierEasing(a, b, c, d, nm) {
		      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
		      if (beziers[str]) {
		        return beziers[str];
		      }
		      var bezEasing = new BezierEasing([a, b, c, d]);
		      beziers[str] = bezEasing;
		      return bezEasing;
		    }

		    // These values are established by empiricism with tests (tradeoff: performance VS precision)
		    var NEWTON_ITERATIONS = 4;
		    var NEWTON_MIN_SLOPE = 0.001;
		    var SUBDIVISION_PRECISION = 0.0000001;
		    var SUBDIVISION_MAX_ITERATIONS = 10;
		    var kSplineTableSize = 11;
		    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
		    var float32ArraySupported = typeof Float32Array === 'function';
		    function A(aA1, aA2) {
		      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
		    }
		    function B(aA1, aA2) {
		      return 3.0 * aA2 - 6.0 * aA1;
		    }
		    function C(aA1) {
		      return 3.0 * aA1;
		    }

		    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
		    function calcBezier(aT, aA1, aA2) {
		      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
		    }

		    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
		    function getSlope(aT, aA1, aA2) {
		      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
		    }
		    function binarySubdivide(aX, aA, aB, mX1, mX2) {
		      var currentX,
		        currentT,
		        i = 0;
		      do {
		        currentT = aA + (aB - aA) / 2.0;
		        currentX = calcBezier(currentT, mX1, mX2) - aX;
		        if (currentX > 0.0) {
		          aB = currentT;
		        } else {
		          aA = currentT;
		        }
		      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
		      return currentT;
		    }
		    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
		      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
		        var currentSlope = getSlope(aGuessT, mX1, mX2);
		        if (currentSlope === 0.0) return aGuessT;
		        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
		        aGuessT -= currentX / currentSlope;
		      }
		      return aGuessT;
		    }

		    /**
		       * points is an array of [ mX1, mY1, mX2, mY2 ]
		       */
		    function BezierEasing(points) {
		      this._p = points;
		      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
		      this._precomputed = false;
		      this.get = this.get.bind(this);
		    }
		    BezierEasing.prototype = {
		      get: function get(x) {
		        var mX1 = this._p[0],
		          mY1 = this._p[1],
		          mX2 = this._p[2],
		          mY2 = this._p[3];
		        if (!this._precomputed) this._precompute();
		        if (mX1 === mY1 && mX2 === mY2) return x; // linear
		        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
		        if (x === 0) return 0;
		        if (x === 1) return 1;
		        return calcBezier(this._getTForX(x), mY1, mY2);
		      },
		      // Private part

		      _precompute: function _precompute() {
		        var mX1 = this._p[0],
		          mY1 = this._p[1],
		          mX2 = this._p[2],
		          mY2 = this._p[3];
		        this._precomputed = true;
		        if (mX1 !== mY1 || mX2 !== mY2) {
		          this._calcSampleValues();
		        }
		      },
		      _calcSampleValues: function _calcSampleValues() {
		        var mX1 = this._p[0],
		          mX2 = this._p[2];
		        for (var i = 0; i < kSplineTableSize; ++i) {
		          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
		        }
		      },
		      /**
		           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
		           */
		      _getTForX: function _getTForX(aX) {
		        var mX1 = this._p[0],
		          mX2 = this._p[2],
		          mSampleValues = this._mSampleValues;
		        var intervalStart = 0.0;
		        var currentSample = 1;
		        var lastSample = kSplineTableSize - 1;
		        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
		          intervalStart += kSampleStepSize;
		        }
		        --currentSample;

		        // Interpolate to provide an initial guess for t
		        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
		        var guessForT = intervalStart + dist * kSampleStepSize;
		        var initialSlope = getSlope(guessForT, mX1, mX2);
		        if (initialSlope >= NEWTON_MIN_SLOPE) {
		          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
		        }
		        if (initialSlope === 0.0) {
		          return guessForT;
		        }
		        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
		      }
		    };
		    return ob;
		  }();

		  var pooling = function () {
		    function _double(arr) {
		      return arr.concat(createSizedArray(arr.length));
		    }
		    return {
		      "double": _double
		    };
		  }();

		  var poolFactory = function () {
		    return function (initialLength, _create, _release) {
		      var _length = 0;
		      var _maxLength = initialLength;
		      var pool = createSizedArray(_maxLength);
		      var ob = {
		        newElement: newElement,
		        release: release
		      };
		      function newElement() {
		        var element;
		        if (_length) {
		          _length -= 1;
		          element = pool[_length];
		        } else {
		          element = _create();
		        }
		        return element;
		      }
		      function release(element) {
		        if (_length === _maxLength) {
		          pool = pooling["double"](pool);
		          _maxLength *= 2;
		        }
		        if (_release) {
		          _release(element);
		        }
		        pool[_length] = element;
		        _length += 1;
		      }
		      return ob;
		    };
		  }();

		  var bezierLengthPool = function () {
		    function create() {
		      return {
		        addedLength: 0,
		        percents: createTypedArray('float32', getDefaultCurveSegments()),
		        lengths: createTypedArray('float32', getDefaultCurveSegments())
		      };
		    }
		    return poolFactory(8, create);
		  }();

		  var segmentsLengthPool = function () {
		    function create() {
		      return {
		        lengths: [],
		        totalLength: 0
		      };
		    }
		    function release(element) {
		      var i;
		      var len = element.lengths.length;
		      for (i = 0; i < len; i += 1) {
		        bezierLengthPool.release(element.lengths[i]);
		      }
		      element.lengths.length = 0;
		    }
		    return poolFactory(8, create, release);
		  }();

		  function bezFunction() {
		    var math = Math;
		    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
		      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
		      return det1 > -0.001 && det1 < 0.001;
		    }
		    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
		      if (z1 === 0 && z2 === 0 && z3 === 0) {
		        return pointOnLine2D(x1, y1, x2, y2, x3, y3);
		      }
		      var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
		      var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
		      var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
		      var diffDist;
		      if (dist1 > dist2) {
		        if (dist1 > dist3) {
		          diffDist = dist1 - dist2 - dist3;
		        } else {
		          diffDist = dist3 - dist2 - dist1;
		        }
		      } else if (dist3 > dist2) {
		        diffDist = dist3 - dist2 - dist1;
		      } else {
		        diffDist = dist2 - dist1 - dist3;
		      }
		      return diffDist > -0.0001 && diffDist < 0.0001;
		    }
		    var getBezierLength = function () {
		      return function (pt1, pt2, pt3, pt4) {
		        var curveSegments = getDefaultCurveSegments();
		        var k;
		        var i;
		        var len;
		        var ptCoord;
		        var perc;
		        var addedLength = 0;
		        var ptDistance;
		        var point = [];
		        var lastPoint = [];
		        var lengthData = bezierLengthPool.newElement();
		        len = pt3.length;
		        for (k = 0; k < curveSegments; k += 1) {
		          perc = k / (curveSegments - 1);
		          ptDistance = 0;
		          for (i = 0; i < len; i += 1) {
		            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
		            point[i] = ptCoord;
		            if (lastPoint[i] !== null) {
		              ptDistance += bmPow(point[i] - lastPoint[i], 2);
		            }
		            lastPoint[i] = point[i];
		          }
		          if (ptDistance) {
		            ptDistance = bmSqrt(ptDistance);
		            addedLength += ptDistance;
		          }
		          lengthData.percents[k] = perc;
		          lengthData.lengths[k] = addedLength;
		        }
		        lengthData.addedLength = addedLength;
		        return lengthData;
		      };
		    }();
		    function getSegmentsLength(shapeData) {
		      var segmentsLength = segmentsLengthPool.newElement();
		      var closed = shapeData.c;
		      var pathV = shapeData.v;
		      var pathO = shapeData.o;
		      var pathI = shapeData.i;
		      var i;
		      var len = shapeData._length;
		      var lengths = segmentsLength.lengths;
		      var totalLength = 0;
		      for (i = 0; i < len - 1; i += 1) {
		        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
		        totalLength += lengths[i].addedLength;
		      }
		      if (closed && len) {
		        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
		        totalLength += lengths[i].addedLength;
		      }
		      segmentsLength.totalLength = totalLength;
		      return segmentsLength;
		    }
		    function BezierData(length) {
		      this.segmentLength = 0;
		      this.points = new Array(length);
		    }
		    function PointData(partial, point) {
		      this.partialLength = partial;
		      this.point = point;
		    }
		    var buildBezierData = function () {
		      var storedData = {};
		      return function (pt1, pt2, pt3, pt4) {
		        var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
		        if (!storedData[bezierName]) {
		          var curveSegments = getDefaultCurveSegments();
		          var k;
		          var i;
		          var len;
		          var ptCoord;
		          var perc;
		          var addedLength = 0;
		          var ptDistance;
		          var point;
		          var lastPoint = null;
		          if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
		            curveSegments = 2;
		          }
		          var bezierData = new BezierData(curveSegments);
		          len = pt3.length;
		          for (k = 0; k < curveSegments; k += 1) {
		            point = createSizedArray(len);
		            perc = k / (curveSegments - 1);
		            ptDistance = 0;
		            for (i = 0; i < len; i += 1) {
		              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
		              point[i] = ptCoord;
		              if (lastPoint !== null) {
		                ptDistance += bmPow(point[i] - lastPoint[i], 2);
		              }
		            }
		            ptDistance = bmSqrt(ptDistance);
		            addedLength += ptDistance;
		            bezierData.points[k] = new PointData(ptDistance, point);
		            lastPoint = point;
		          }
		          bezierData.segmentLength = addedLength;
		          storedData[bezierName] = bezierData;
		        }
		        return storedData[bezierName];
		      };
		    }();
		    function getDistancePerc(perc, bezierData) {
		      var percents = bezierData.percents;
		      var lengths = bezierData.lengths;
		      var len = percents.length;
		      var initPos = bmFloor((len - 1) * perc);
		      var lengthPos = perc * bezierData.addedLength;
		      var lPerc = 0;
		      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
		        return percents[initPos];
		      }
		      var dir = lengths[initPos] > lengthPos ? -1 : 1;
		      var flag = true;
		      while (flag) {
		        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
		          lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
		          flag = false;
		        } else {
		          initPos += dir;
		        }
		        if (initPos < 0 || initPos >= len - 1) {
		          // FIX for TypedArrays that don't store floating point values with enough accuracy
		          if (initPos === len - 1) {
		            return percents[initPos];
		          }
		          flag = false;
		        }
		      }
		      return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
		    }
		    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
		      var t1 = getDistancePerc(percent, bezierData);
		      var u1 = 1 - t1;
		      var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
		      var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
		      return [ptX, ptY];
		    }
		    var bezierSegmentPoints = createTypedArray('float32', 8);
		    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
		      if (startPerc < 0) {
		        startPerc = 0;
		      } else if (startPerc > 1) {
		        startPerc = 1;
		      }
		      var t0 = getDistancePerc(startPerc, bezierData);
		      endPerc = endPerc > 1 ? 1 : endPerc;
		      var t1 = getDistancePerc(endPerc, bezierData);
		      var i;
		      var len = pt1.length;
		      var u0 = 1 - t0;
		      var u1 = 1 - t1;
		      var u0u0u0 = u0 * u0 * u0;
		      var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
		      var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
		      var t0t0t0 = t0 * t0 * t0;
		      //
		      var u0u0u1 = u0 * u0 * u1;
		      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
		      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
		      var t0t0t1 = t0 * t0 * t1;
		      //
		      var u0u1u1 = u0 * u1 * u1;
		      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
		      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
		      var t0t1t1 = t0 * t1 * t1;
		      //
		      var u1u1u1 = u1 * u1 * u1;
		      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
		      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
		      var t1t1t1 = t1 * t1 * t1;
		      for (i = 0; i < len; i += 1) {
		        bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
		        bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
		        bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
		        bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
		      }
		      return bezierSegmentPoints;
		    }
		    return {
		      getSegmentsLength: getSegmentsLength,
		      getNewSegment: getNewSegment,
		      getPointInSegment: getPointInSegment,
		      buildBezierData: buildBezierData,
		      pointOnLine2D: pointOnLine2D,
		      pointOnLine3D: pointOnLine3D
		    };
		  }
		  var bez = bezFunction();

		  var initFrame = initialDefaultFrame;
		  var mathAbs = Math.abs;
		  function interpolateValue(frameNum, caching) {
		    var offsetTime = this.offsetTime;
		    var newValue;
		    if (this.propType === 'multidimensional') {
		      newValue = createTypedArray('float32', this.pv.length);
		    }
		    var iterationIndex = caching.lastIndex;
		    var i = iterationIndex;
		    var len = this.keyframes.length - 1;
		    var flag = true;
		    var keyData;
		    var nextKeyData;
		    var keyframeMetadata;
		    while (flag) {
		      keyData = this.keyframes[i];
		      nextKeyData = this.keyframes[i + 1];
		      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
		        if (keyData.h) {
		          keyData = nextKeyData;
		        }
		        iterationIndex = 0;
		        break;
		      }
		      if (nextKeyData.t - offsetTime > frameNum) {
		        iterationIndex = i;
		        break;
		      }
		      if (i < len - 1) {
		        i += 1;
		      } else {
		        iterationIndex = 0;
		        flag = false;
		      }
		    }
		    keyframeMetadata = this.keyframesMetadata[i] || {};
		    var k;
		    var kLen;
		    var perc;
		    var jLen;
		    var j;
		    var fnc;
		    var nextKeyTime = nextKeyData.t - offsetTime;
		    var keyTime = keyData.t - offsetTime;
		    var endValue;
		    if (keyData.to) {
		      if (!keyframeMetadata.bezierData) {
		        keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
		      }
		      var bezierData = keyframeMetadata.bezierData;
		      if (frameNum >= nextKeyTime || frameNum < keyTime) {
		        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
		        kLen = bezierData.points[ind].point.length;
		        for (k = 0; k < kLen; k += 1) {
		          newValue[k] = bezierData.points[ind].point[k];
		        }
		        // caching._lastKeyframeIndex = -1;
		      } else {
		        if (keyframeMetadata.__fnct) {
		          fnc = keyframeMetadata.__fnct;
		        } else {
		          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
		          keyframeMetadata.__fnct = fnc;
		        }
		        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
		        var distanceInLine = bezierData.segmentLength * perc;
		        var segmentPerc;
		        var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
		        j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
		        flag = true;
		        jLen = bezierData.points.length;
		        while (flag) {
		          addedLength += bezierData.points[j].partialLength;
		          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
		            kLen = bezierData.points[j].point.length;
		            for (k = 0; k < kLen; k += 1) {
		              newValue[k] = bezierData.points[j].point[k];
		            }
		            break;
		          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
		            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
		            kLen = bezierData.points[j].point.length;
		            for (k = 0; k < kLen; k += 1) {
		              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
		            }
		            break;
		          }
		          if (j < jLen - 1) {
		            j += 1;
		          } else {
		            flag = false;
		          }
		        }
		        caching._lastPoint = j;
		        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
		        caching._lastKeyframeIndex = i;
		      }
		    } else {
		      var outX;
		      var outY;
		      var inX;
		      var inY;
		      var keyValue;
		      len = keyData.s.length;
		      endValue = nextKeyData.s || keyData.e;
		      if (this.sh && keyData.h !== 1) {
		        if (frameNum >= nextKeyTime) {
		          newValue[0] = endValue[0];
		          newValue[1] = endValue[1];
		          newValue[2] = endValue[2];
		        } else if (frameNum <= keyTime) {
		          newValue[0] = keyData.s[0];
		          newValue[1] = keyData.s[1];
		          newValue[2] = keyData.s[2];
		        } else {
		          var quatStart = createQuaternion(keyData.s);
		          var quatEnd = createQuaternion(endValue);
		          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
		          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
		        }
		      } else {
		        for (i = 0; i < len; i += 1) {
		          if (keyData.h !== 1) {
		            if (frameNum >= nextKeyTime) {
		              perc = 1;
		            } else if (frameNum < keyTime) {
		              perc = 0;
		            } else {
		              if (keyData.o.x.constructor === Array) {
		                if (!keyframeMetadata.__fnct) {
		                  keyframeMetadata.__fnct = [];
		                }
		                if (!keyframeMetadata.__fnct[i]) {
		                  outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
		                  outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
		                  inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
		                  inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
		                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
		                  keyframeMetadata.__fnct[i] = fnc;
		                } else {
		                  fnc = keyframeMetadata.__fnct[i];
		                }
		              } else if (!keyframeMetadata.__fnct) {
		                outX = keyData.o.x;
		                outY = keyData.o.y;
		                inX = keyData.i.x;
		                inY = keyData.i.y;
		                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
		                keyData.keyframeMetadata = fnc;
		              } else {
		                fnc = keyframeMetadata.__fnct;
		              }
		              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
		            }
		          }
		          endValue = nextKeyData.s || keyData.e;
		          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
		          if (this.propType === 'multidimensional') {
		            newValue[i] = keyValue;
		          } else {
		            newValue = keyValue;
		          }
		        }
		      }
		    }
		    caching.lastIndex = iterationIndex;
		    return newValue;
		  }

		  // based on @Toji's https://github.com/toji/gl-matrix/
		  function slerp(a, b, t) {
		    var out = [];
		    var ax = a[0];
		    var ay = a[1];
		    var az = a[2];
		    var aw = a[3];
		    var bx = b[0];
		    var by = b[1];
		    var bz = b[2];
		    var bw = b[3];
		    var omega;
		    var cosom;
		    var sinom;
		    var scale0;
		    var scale1;
		    cosom = ax * bx + ay * by + az * bz + aw * bw;
		    if (cosom < 0.0) {
		      cosom = -cosom;
		      bx = -bx;
		      by = -by;
		      bz = -bz;
		      bw = -bw;
		    }
		    if (1.0 - cosom > 0.000001) {
		      omega = Math.acos(cosom);
		      sinom = Math.sin(omega);
		      scale0 = Math.sin((1.0 - t) * omega) / sinom;
		      scale1 = Math.sin(t * omega) / sinom;
		    } else {
		      scale0 = 1.0 - t;
		      scale1 = t;
		    }
		    out[0] = scale0 * ax + scale1 * bx;
		    out[1] = scale0 * ay + scale1 * by;
		    out[2] = scale0 * az + scale1 * bz;
		    out[3] = scale0 * aw + scale1 * bw;
		    return out;
		  }
		  function quaternionToEuler(out, quat) {
		    var qx = quat[0];
		    var qy = quat[1];
		    var qz = quat[2];
		    var qw = quat[3];
		    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
		    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
		    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
		    out[0] = heading / degToRads;
		    out[1] = attitude / degToRads;
		    out[2] = bank / degToRads;
		  }
		  function createQuaternion(values) {
		    var heading = values[0] * degToRads;
		    var attitude = values[1] * degToRads;
		    var bank = values[2] * degToRads;
		    var c1 = Math.cos(heading / 2);
		    var c2 = Math.cos(attitude / 2);
		    var c3 = Math.cos(bank / 2);
		    var s1 = Math.sin(heading / 2);
		    var s2 = Math.sin(attitude / 2);
		    var s3 = Math.sin(bank / 2);
		    var w = c1 * c2 * c3 - s1 * s2 * s3;
		    var x = s1 * s2 * c3 + c1 * c2 * s3;
		    var y = s1 * c2 * c3 + c1 * s2 * s3;
		    var z = c1 * s2 * c3 - s1 * c2 * s3;
		    return [x, y, z, w];
		  }
		  function getValueAtCurrentTime() {
		    var frameNum = this.comp.renderedFrame - this.offsetTime;
		    var initTime = this.keyframes[0].t - this.offsetTime;
		    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
		    if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
		      if (this._caching.lastFrame >= frameNum) {
		        this._caching._lastKeyframeIndex = -1;
		        this._caching.lastIndex = 0;
		      }
		      var renderResult = this.interpolateValue(frameNum, this._caching);
		      this.pv = renderResult;
		    }
		    this._caching.lastFrame = frameNum;
		    return this.pv;
		  }
		  function setVValue(val) {
		    var multipliedValue;
		    if (this.propType === 'unidimensional') {
		      multipliedValue = val * this.mult;
		      if (mathAbs(this.v - multipliedValue) > 0.00001) {
		        this.v = multipliedValue;
		        this._mdf = true;
		      }
		    } else {
		      var i = 0;
		      var len = this.v.length;
		      while (i < len) {
		        multipliedValue = val[i] * this.mult;
		        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
		          this.v[i] = multipliedValue;
		          this._mdf = true;
		        }
		        i += 1;
		      }
		    }
		  }
		  function processEffectsSequence() {
		    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
		      return;
		    }
		    if (this.lock) {
		      this.setVValue(this.pv);
		      return;
		    }
		    this.lock = true;
		    this._mdf = this._isFirstFrame;
		    var i;
		    var len = this.effectsSequence.length;
		    var finalValue = this.kf ? this.pv : this.data.k;
		    for (i = 0; i < len; i += 1) {
		      finalValue = this.effectsSequence[i](finalValue);
		    }
		    this.setVValue(finalValue);
		    this._isFirstFrame = false;
		    this.lock = false;
		    this.frameId = this.elem.globalData.frameId;
		  }
		  function addEffect(effectFunction) {
		    this.effectsSequence.push(effectFunction);
		    this.container.addDynamicProperty(this);
		  }
		  function ValueProperty(elem, data, mult, container) {
		    this.propType = 'unidimensional';
		    this.mult = mult || 1;
		    this.data = data;
		    this.v = mult ? data.k * mult : data.k;
		    this.pv = data.k;
		    this._mdf = false;
		    this.elem = elem;
		    this.container = container;
		    this.comp = elem.comp;
		    this.k = false;
		    this.kf = false;
		    this.vel = 0;
		    this.effectsSequence = [];
		    this._isFirstFrame = true;
		    this.getValue = processEffectsSequence;
		    this.setVValue = setVValue;
		    this.addEffect = addEffect;
		  }
		  function MultiDimensionalProperty(elem, data, mult, container) {
		    this.propType = 'multidimensional';
		    this.mult = mult || 1;
		    this.data = data;
		    this._mdf = false;
		    this.elem = elem;
		    this.container = container;
		    this.comp = elem.comp;
		    this.k = false;
		    this.kf = false;
		    this.frameId = -1;
		    var i;
		    var len = data.k.length;
		    this.v = createTypedArray('float32', len);
		    this.pv = createTypedArray('float32', len);
		    this.vel = createTypedArray('float32', len);
		    for (i = 0; i < len; i += 1) {
		      this.v[i] = data.k[i] * this.mult;
		      this.pv[i] = data.k[i];
		    }
		    this._isFirstFrame = true;
		    this.effectsSequence = [];
		    this.getValue = processEffectsSequence;
		    this.setVValue = setVValue;
		    this.addEffect = addEffect;
		  }
		  function KeyframedValueProperty(elem, data, mult, container) {
		    this.propType = 'unidimensional';
		    this.keyframes = data.k;
		    this.keyframesMetadata = [];
		    this.offsetTime = elem.data.st;
		    this.frameId = -1;
		    this._caching = {
		      lastFrame: initFrame,
		      lastIndex: 0,
		      value: 0,
		      _lastKeyframeIndex: -1
		    };
		    this.k = true;
		    this.kf = true;
		    this.data = data;
		    this.mult = mult || 1;
		    this.elem = elem;
		    this.container = container;
		    this.comp = elem.comp;
		    this.v = initFrame;
		    this.pv = initFrame;
		    this._isFirstFrame = true;
		    this.getValue = processEffectsSequence;
		    this.setVValue = setVValue;
		    this.interpolateValue = interpolateValue;
		    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
		    this.addEffect = addEffect;
		  }
		  function KeyframedMultidimensionalProperty(elem, data, mult, container) {
		    this.propType = 'multidimensional';
		    var i;
		    var len = data.k.length;
		    var s;
		    var e;
		    var to;
		    var ti;
		    for (i = 0; i < len - 1; i += 1) {
		      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
		        s = data.k[i].s;
		        e = data.k[i + 1].s;
		        to = data.k[i].to;
		        ti = data.k[i].ti;
		        if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
		          data.k[i].to = null;
		          data.k[i].ti = null;
		        }
		        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
		          if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
		            data.k[i].to = null;
		            data.k[i].ti = null;
		          }
		        }
		      }
		    }
		    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
		    this.data = data;
		    this.keyframes = data.k;
		    this.keyframesMetadata = [];
		    this.offsetTime = elem.data.st;
		    this.k = true;
		    this.kf = true;
		    this._isFirstFrame = true;
		    this.mult = mult || 1;
		    this.elem = elem;
		    this.container = container;
		    this.comp = elem.comp;
		    this.getValue = processEffectsSequence;
		    this.setVValue = setVValue;
		    this.interpolateValue = interpolateValue;
		    this.frameId = -1;
		    var arrLen = data.k[0].s.length;
		    this.v = createTypedArray('float32', arrLen);
		    this.pv = createTypedArray('float32', arrLen);
		    for (i = 0; i < arrLen; i += 1) {
		      this.v[i] = initFrame;
		      this.pv[i] = initFrame;
		    }
		    this._caching = {
		      lastFrame: initFrame,
		      lastIndex: 0,
		      value: createTypedArray('float32', arrLen)
		    };
		    this.addEffect = addEffect;
		  }
		  var PropertyFactory = function () {
		    function getProp(elem, data, type, mult, container) {
		      if (data.sid) {
		        data = elem.globalData.slotManager.getProp(data);
		      }
		      var p;
		      if (!data.k.length) {
		        p = new ValueProperty(elem, data, mult, container);
		      } else if (typeof data.k[0] === 'number') {
		        p = new MultiDimensionalProperty(elem, data, mult, container);
		      } else {
		        switch (type) {
		          case 0:
		            p = new KeyframedValueProperty(elem, data, mult, container);
		            break;
		          case 1:
		            p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
		            break;
		        }
		      }
		      if (p.effectsSequence.length) {
		        container.addDynamicProperty(p);
		      }
		      return p;
		    }
		    var ob = {
		      getProp: getProp
		    };
		    return ob;
		  }();

		  function DynamicPropertyContainer() {}
		  DynamicPropertyContainer.prototype = {
		    addDynamicProperty: function addDynamicProperty(prop) {
		      if (this.dynamicProperties.indexOf(prop) === -1) {
		        this.dynamicProperties.push(prop);
		        this.container.addDynamicProperty(this);
		        this._isAnimated = true;
		      }
		    },
		    iterateDynamicProperties: function iterateDynamicProperties() {
		      this._mdf = false;
		      var i;
		      var len = this.dynamicProperties.length;
		      for (i = 0; i < len; i += 1) {
		        this.dynamicProperties[i].getValue();
		        if (this.dynamicProperties[i]._mdf) {
		          this._mdf = true;
		        }
		      }
		    },
		    initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
		      this.container = container;
		      this.dynamicProperties = [];
		      this._mdf = false;
		      this._isAnimated = false;
		    }
		  };

		  var pointPool = function () {
		    function create() {
		      return createTypedArray('float32', 2);
		    }
		    return poolFactory(8, create);
		  }();

		  function ShapePath() {
		    this.c = false;
		    this._length = 0;
		    this._maxLength = 8;
		    this.v = createSizedArray(this._maxLength);
		    this.o = createSizedArray(this._maxLength);
		    this.i = createSizedArray(this._maxLength);
		  }
		  ShapePath.prototype.setPathData = function (closed, len) {
		    this.c = closed;
		    this.setLength(len);
		    var i = 0;
		    while (i < len) {
		      this.v[i] = pointPool.newElement();
		      this.o[i] = pointPool.newElement();
		      this.i[i] = pointPool.newElement();
		      i += 1;
		    }
		  };
		  ShapePath.prototype.setLength = function (len) {
		    while (this._maxLength < len) {
		      this.doubleArrayLength();
		    }
		    this._length = len;
		  };
		  ShapePath.prototype.doubleArrayLength = function () {
		    this.v = this.v.concat(createSizedArray(this._maxLength));
		    this.i = this.i.concat(createSizedArray(this._maxLength));
		    this.o = this.o.concat(createSizedArray(this._maxLength));
		    this._maxLength *= 2;
		  };
		  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
		    var arr;
		    this._length = Math.max(this._length, pos + 1);
		    if (this._length >= this._maxLength) {
		      this.doubleArrayLength();
		    }
		    switch (type) {
		      case 'v':
		        arr = this.v;
		        break;
		      case 'i':
		        arr = this.i;
		        break;
		      case 'o':
		        arr = this.o;
		        break;
		      default:
		        arr = [];
		        break;
		    }
		    if (!arr[pos] || arr[pos] && !replace) {
		      arr[pos] = pointPool.newElement();
		    }
		    arr[pos][0] = x;
		    arr[pos][1] = y;
		  };
		  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
		    this.setXYAt(vX, vY, 'v', pos, replace);
		    this.setXYAt(oX, oY, 'o', pos, replace);
		    this.setXYAt(iX, iY, 'i', pos, replace);
		  };
		  ShapePath.prototype.reverse = function () {
		    var newPath = new ShapePath();
		    newPath.setPathData(this.c, this._length);
		    var vertices = this.v;
		    var outPoints = this.o;
		    var inPoints = this.i;
		    var init = 0;
		    if (this.c) {
		      newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
		      init = 1;
		    }
		    var cnt = this._length - 1;
		    var len = this._length;
		    var i;
		    for (i = init; i < len; i += 1) {
		      newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
		      cnt -= 1;
		    }
		    return newPath;
		  };
		  ShapePath.prototype.length = function () {
		    return this._length;
		  };

		  var shapePool = function () {
		    function create() {
		      return new ShapePath();
		    }
		    function release(shapePath) {
		      var len = shapePath._length;
		      var i;
		      for (i = 0; i < len; i += 1) {
		        pointPool.release(shapePath.v[i]);
		        pointPool.release(shapePath.i[i]);
		        pointPool.release(shapePath.o[i]);
		        shapePath.v[i] = null;
		        shapePath.i[i] = null;
		        shapePath.o[i] = null;
		      }
		      shapePath._length = 0;
		      shapePath.c = false;
		    }
		    function clone(shape) {
		      var cloned = factory.newElement();
		      var i;
		      var len = shape._length === undefined ? shape.v.length : shape._length;
		      cloned.setLength(len);
		      cloned.c = shape.c;
		      for (i = 0; i < len; i += 1) {
		        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
		      }
		      return cloned;
		    }
		    var factory = poolFactory(4, create, release);
		    factory.clone = clone;
		    return factory;
		  }();

		  function ShapeCollection() {
		    this._length = 0;
		    this._maxLength = 4;
		    this.shapes = createSizedArray(this._maxLength);
		  }
		  ShapeCollection.prototype.addShape = function (shapeData) {
		    if (this._length === this._maxLength) {
		      this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
		      this._maxLength *= 2;
		    }
		    this.shapes[this._length] = shapeData;
		    this._length += 1;
		  };
		  ShapeCollection.prototype.releaseShapes = function () {
		    var i;
		    for (i = 0; i < this._length; i += 1) {
		      shapePool.release(this.shapes[i]);
		    }
		    this._length = 0;
		  };

		  var shapeCollectionPool = function () {
		    var ob = {
		      newShapeCollection: newShapeCollection,
		      release: release
		    };
		    var _length = 0;
		    var _maxLength = 4;
		    var pool = createSizedArray(_maxLength);
		    function newShapeCollection() {
		      var shapeCollection;
		      if (_length) {
		        _length -= 1;
		        shapeCollection = pool[_length];
		      } else {
		        shapeCollection = new ShapeCollection();
		      }
		      return shapeCollection;
		    }
		    function release(shapeCollection) {
		      var i;
		      var len = shapeCollection._length;
		      for (i = 0; i < len; i += 1) {
		        shapePool.release(shapeCollection.shapes[i]);
		      }
		      shapeCollection._length = 0;
		      if (_length === _maxLength) {
		        pool = pooling["double"](pool);
		        _maxLength *= 2;
		      }
		      pool[_length] = shapeCollection;
		      _length += 1;
		    }
		    return ob;
		  }();

		  var ShapePropertyFactory = function () {
		    var initFrame = -999999;
		    function interpolateShape(frameNum, previousValue, caching) {
		      var iterationIndex = caching.lastIndex;
		      var keyPropS;
		      var keyPropE;
		      var isHold;
		      var j;
		      var k;
		      var jLen;
		      var kLen;
		      var perc;
		      var vertexValue;
		      var kf = this.keyframes;
		      if (frameNum < kf[0].t - this.offsetTime) {
		        keyPropS = kf[0].s[0];
		        isHold = true;
		        iterationIndex = 0;
		      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
		        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
		        /* if(kf[kf.length - 1].s){
		                  keyPropS = kf[kf.length - 1].s[0];
		              }else{
		                  keyPropS = kf[kf.length - 2].e[0];
		              } */
		        isHold = true;
		      } else {
		        var i = iterationIndex;
		        var len = kf.length - 1;
		        var flag = true;
		        var keyData;
		        var nextKeyData;
		        var keyframeMetadata;
		        while (flag) {
		          keyData = kf[i];
		          nextKeyData = kf[i + 1];
		          if (nextKeyData.t - this.offsetTime > frameNum) {
		            break;
		          }
		          if (i < len - 1) {
		            i += 1;
		          } else {
		            flag = false;
		          }
		        }
		        keyframeMetadata = this.keyframesMetadata[i] || {};
		        isHold = keyData.h === 1;
		        iterationIndex = i;
		        if (!isHold) {
		          if (frameNum >= nextKeyData.t - this.offsetTime) {
		            perc = 1;
		          } else if (frameNum < keyData.t - this.offsetTime) {
		            perc = 0;
		          } else {
		            var fnc;
		            if (keyframeMetadata.__fnct) {
		              fnc = keyframeMetadata.__fnct;
		            } else {
		              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
		              keyframeMetadata.__fnct = fnc;
		            }
		            perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
		          }
		          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
		        }
		        keyPropS = keyData.s[0];
		      }
		      jLen = previousValue._length;
		      kLen = keyPropS.i[0].length;
		      caching.lastIndex = iterationIndex;
		      for (j = 0; j < jLen; j += 1) {
		        for (k = 0; k < kLen; k += 1) {
		          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
		          previousValue.i[j][k] = vertexValue;
		          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
		          previousValue.o[j][k] = vertexValue;
		          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
		          previousValue.v[j][k] = vertexValue;
		        }
		      }
		    }
		    function interpolateShapeCurrentTime() {
		      var frameNum = this.comp.renderedFrame - this.offsetTime;
		      var initTime = this.keyframes[0].t - this.offsetTime;
		      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
		      var lastFrame = this._caching.lastFrame;
		      if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
		        /// /
		        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
		        this.interpolateShape(frameNum, this.pv, this._caching);
		        /// /
		      }
		      this._caching.lastFrame = frameNum;
		      return this.pv;
		    }
		    function resetShape() {
		      this.paths = this.localShapeCollection;
		    }
		    function shapesEqual(shape1, shape2) {
		      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
		        return false;
		      }
		      var i;
		      var len = shape1._length;
		      for (i = 0; i < len; i += 1) {
		        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
		          return false;
		        }
		      }
		      return true;
		    }
		    function setVValue(newPath) {
		      if (!shapesEqual(this.v, newPath)) {
		        this.v = shapePool.clone(newPath);
		        this.localShapeCollection.releaseShapes();
		        this.localShapeCollection.addShape(this.v);
		        this._mdf = true;
		        this.paths = this.localShapeCollection;
		      }
		    }
		    function processEffectsSequence() {
		      if (this.elem.globalData.frameId === this.frameId) {
		        return;
		      }
		      if (!this.effectsSequence.length) {
		        this._mdf = false;
		        return;
		      }
		      if (this.lock) {
		        this.setVValue(this.pv);
		        return;
		      }
		      this.lock = true;
		      this._mdf = false;
		      var finalValue;
		      if (this.kf) {
		        finalValue = this.pv;
		      } else if (this.data.ks) {
		        finalValue = this.data.ks.k;
		      } else {
		        finalValue = this.data.pt.k;
		      }
		      var i;
		      var len = this.effectsSequence.length;
		      for (i = 0; i < len; i += 1) {
		        finalValue = this.effectsSequence[i](finalValue);
		      }
		      this.setVValue(finalValue);
		      this.lock = false;
		      this.frameId = this.elem.globalData.frameId;
		    }
		    function ShapeProperty(elem, data, type) {
		      this.propType = 'shape';
		      this.comp = elem.comp;
		      this.container = elem;
		      this.elem = elem;
		      this.data = data;
		      this.k = false;
		      this.kf = false;
		      this._mdf = false;
		      var pathData = type === 3 ? data.pt.k : data.ks.k;
		      this.v = shapePool.clone(pathData);
		      this.pv = shapePool.clone(this.v);
		      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
		      this.paths = this.localShapeCollection;
		      this.paths.addShape(this.v);
		      this.reset = resetShape;
		      this.effectsSequence = [];
		    }
		    function addEffect(effectFunction) {
		      this.effectsSequence.push(effectFunction);
		      this.container.addDynamicProperty(this);
		    }
		    ShapeProperty.prototype.interpolateShape = interpolateShape;
		    ShapeProperty.prototype.getValue = processEffectsSequence;
		    ShapeProperty.prototype.setVValue = setVValue;
		    ShapeProperty.prototype.addEffect = addEffect;
		    function KeyframedShapeProperty(elem, data, type) {
		      this.propType = 'shape';
		      this.comp = elem.comp;
		      this.elem = elem;
		      this.container = elem;
		      this.offsetTime = elem.data.st;
		      this.keyframes = type === 3 ? data.pt.k : data.ks.k;
		      this.keyframesMetadata = [];
		      this.k = true;
		      this.kf = true;
		      var len = this.keyframes[0].s[0].i.length;
		      this.v = shapePool.newElement();
		      this.v.setPathData(this.keyframes[0].s[0].c, len);
		      this.pv = shapePool.clone(this.v);
		      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
		      this.paths = this.localShapeCollection;
		      this.paths.addShape(this.v);
		      this.lastFrame = initFrame;
		      this.reset = resetShape;
		      this._caching = {
		        lastFrame: initFrame,
		        lastIndex: 0
		      };
		      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
		    }
		    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
		    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
		    KeyframedShapeProperty.prototype.setVValue = setVValue;
		    KeyframedShapeProperty.prototype.addEffect = addEffect;
		    var EllShapeProperty = function () {
		      var cPoint = roundCorner;
		      function EllShapePropertyFactory(elem, data) {
		        this.v = shapePool.newElement();
		        this.v.setPathData(true, 4);
		        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
		        this.paths = this.localShapeCollection;
		        this.localShapeCollection.addShape(this.v);
		        this.d = data.d;
		        this.elem = elem;
		        this.comp = elem.comp;
		        this.frameId = -1;
		        this.initDynamicPropertyContainer(elem);
		        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
		        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
		        if (this.dynamicProperties.length) {
		          this.k = true;
		        } else {
		          this.k = false;
		          this.convertEllToPath();
		        }
		      }
		      EllShapePropertyFactory.prototype = {
		        reset: resetShape,
		        getValue: function getValue() {
		          if (this.elem.globalData.frameId === this.frameId) {
		            return;
		          }
		          this.frameId = this.elem.globalData.frameId;
		          this.iterateDynamicProperties();
		          if (this._mdf) {
		            this.convertEllToPath();
		          }
		        },
		        convertEllToPath: function convertEllToPath() {
		          var p0 = this.p.v[0];
		          var p1 = this.p.v[1];
		          var s0 = this.s.v[0] / 2;
		          var s1 = this.s.v[1] / 2;
		          var _cw = this.d !== 3;
		          var _v = this.v;
		          _v.v[0][0] = p0;
		          _v.v[0][1] = p1 - s1;
		          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
		          _v.v[1][1] = p1;
		          _v.v[2][0] = p0;
		          _v.v[2][1] = p1 + s1;
		          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
		          _v.v[3][1] = p1;
		          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
		          _v.i[0][1] = p1 - s1;
		          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
		          _v.i[1][1] = p1 - s1 * cPoint;
		          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
		          _v.i[2][1] = p1 + s1;
		          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
		          _v.i[3][1] = p1 + s1 * cPoint;
		          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
		          _v.o[0][1] = p1 - s1;
		          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
		          _v.o[1][1] = p1 + s1 * cPoint;
		          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
		          _v.o[2][1] = p1 + s1;
		          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
		          _v.o[3][1] = p1 - s1 * cPoint;
		        }
		      };
		      extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
		      return EllShapePropertyFactory;
		    }();
		    var StarShapeProperty = function () {
		      function StarShapePropertyFactory(elem, data) {
		        this.v = shapePool.newElement();
		        this.v.setPathData(true, 0);
		        this.elem = elem;
		        this.comp = elem.comp;
		        this.data = data;
		        this.frameId = -1;
		        this.d = data.d;
		        this.initDynamicPropertyContainer(elem);
		        if (data.sy === 1) {
		          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
		          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
		          this.convertToPath = this.convertStarToPath;
		        } else {
		          this.convertToPath = this.convertPolygonToPath;
		        }
		        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
		        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
		        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
		        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
		        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
		        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
		        this.localShapeCollection.addShape(this.v);
		        this.paths = this.localShapeCollection;
		        if (this.dynamicProperties.length) {
		          this.k = true;
		        } else {
		          this.k = false;
		          this.convertToPath();
		        }
		      }
		      StarShapePropertyFactory.prototype = {
		        reset: resetShape,
		        getValue: function getValue() {
		          if (this.elem.globalData.frameId === this.frameId) {
		            return;
		          }
		          this.frameId = this.elem.globalData.frameId;
		          this.iterateDynamicProperties();
		          if (this._mdf) {
		            this.convertToPath();
		          }
		        },
		        convertStarToPath: function convertStarToPath() {
		          var numPts = Math.floor(this.pt.v) * 2;
		          var angle = Math.PI * 2 / numPts;
		          /* this.v.v.length = numPts;
		                  this.v.i.length = numPts;
		                  this.v.o.length = numPts; */
		          var longFlag = true;
		          var longRad = this.or.v;
		          var shortRad = this.ir.v;
		          var longRound = this.os.v;
		          var shortRound = this.is.v;
		          var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
		          var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
		          var i;
		          var rad;
		          var roundness;
		          var perimSegment;
		          var currentAng = -Math.PI / 2;
		          currentAng += this.r.v;
		          var dir = this.data.d === 3 ? -1 : 1;
		          this.v._length = 0;
		          for (i = 0; i < numPts; i += 1) {
		            rad = longFlag ? longRad : shortRad;
		            roundness = longFlag ? longRound : shortRound;
		            perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
		            var x = rad * Math.cos(currentAng);
		            var y = rad * Math.sin(currentAng);
		            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
		            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
		            x += +this.p.v[0];
		            y += +this.p.v[1];
		            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

		            /* this.v.v[i] = [x,y];
		                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
		                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
		                      this.v._length = numPts; */
		            longFlag = !longFlag;
		            currentAng += angle * dir;
		          }
		        },
		        convertPolygonToPath: function convertPolygonToPath() {
		          var numPts = Math.floor(this.pt.v);
		          var angle = Math.PI * 2 / numPts;
		          var rad = this.or.v;
		          var roundness = this.os.v;
		          var perimSegment = 2 * Math.PI * rad / (numPts * 4);
		          var i;
		          var currentAng = -Math.PI * 0.5;
		          var dir = this.data.d === 3 ? -1 : 1;
		          currentAng += this.r.v;
		          this.v._length = 0;
		          for (i = 0; i < numPts; i += 1) {
		            var x = rad * Math.cos(currentAng);
		            var y = rad * Math.sin(currentAng);
		            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
		            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
		            x += +this.p.v[0];
		            y += +this.p.v[1];
		            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
		            currentAng += angle * dir;
		          }
		          this.paths.length = 0;
		          this.paths[0] = this.v;
		        }
		      };
		      extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
		      return StarShapePropertyFactory;
		    }();
		    var RectShapeProperty = function () {
		      function RectShapePropertyFactory(elem, data) {
		        this.v = shapePool.newElement();
		        this.v.c = true;
		        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
		        this.localShapeCollection.addShape(this.v);
		        this.paths = this.localShapeCollection;
		        this.elem = elem;
		        this.comp = elem.comp;
		        this.frameId = -1;
		        this.d = data.d;
		        this.initDynamicPropertyContainer(elem);
		        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
		        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
		        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
		        if (this.dynamicProperties.length) {
		          this.k = true;
		        } else {
		          this.k = false;
		          this.convertRectToPath();
		        }
		      }
		      RectShapePropertyFactory.prototype = {
		        convertRectToPath: function convertRectToPath() {
		          var p0 = this.p.v[0];
		          var p1 = this.p.v[1];
		          var v0 = this.s.v[0] / 2;
		          var v1 = this.s.v[1] / 2;
		          var round = bmMin(v0, v1, this.r.v);
		          var cPoint = round * (1 - roundCorner);
		          this.v._length = 0;
		          if (this.d === 2 || this.d === 1) {
		            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
		            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
		            if (round !== 0) {
		              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
		              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
		              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
		              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
		              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
		              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
		            } else {
		              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
		              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
		            }
		          } else {
		            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
		            if (round !== 0) {
		              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
		              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
		              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
		              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
		              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
		              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
		              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
		            } else {
		              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
		              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
		              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
		            }
		          }
		        },
		        getValue: function getValue() {
		          if (this.elem.globalData.frameId === this.frameId) {
		            return;
		          }
		          this.frameId = this.elem.globalData.frameId;
		          this.iterateDynamicProperties();
		          if (this._mdf) {
		            this.convertRectToPath();
		          }
		        },
		        reset: resetShape
		      };
		      extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
		      return RectShapePropertyFactory;
		    }();
		    function getShapeProp(elem, data, type) {
		      var prop;
		      if (type === 3 || type === 4) {
		        var dataProp = type === 3 ? data.pt : data.ks;
		        var keys = dataProp.k;
		        if (keys.length) {
		          prop = new KeyframedShapeProperty(elem, data, type);
		        } else {
		          prop = new ShapeProperty(elem, data, type);
		        }
		      } else if (type === 5) {
		        prop = new RectShapeProperty(elem, data);
		      } else if (type === 6) {
		        prop = new EllShapeProperty(elem, data);
		      } else if (type === 7) {
		        prop = new StarShapeProperty(elem, data);
		      }
		      if (prop.k) {
		        elem.addDynamicProperty(prop);
		      }
		      return prop;
		    }
		    function getConstructorFunction() {
		      return ShapeProperty;
		    }
		    function getKeyframedConstructorFunction() {
		      return KeyframedShapeProperty;
		    }
		    var ob = {};
		    ob.getShapeProp = getShapeProp;
		    ob.getConstructorFunction = getConstructorFunction;
		    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
		    return ob;
		  }();

		  /*!
		   Transformation Matrix v2.0
		   (c) Epistemex 2014-2015
		   www.epistemex.com
		   By Ken Fyrstenberg
		   Contributions by leeoniya.
		   License: MIT, header required.
		   */

		  /**
		   * 2D transformation matrix object initialized with identity matrix.
		   *
		   * The matrix can synchronize a canvas context by supplying the context
		   * as an argument, or later apply current absolute transform to an
		   * existing context.
		   *
		   * All values are handled as floating point values.
		   *
		   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
		   * @prop {number} a - scale x
		   * @prop {number} b - shear y
		   * @prop {number} c - shear x
		   * @prop {number} d - scale y
		   * @prop {number} e - translate x
		   * @prop {number} f - translate y
		   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
		   * @constructor
		   */

		  var Matrix = function () {
		    var _cos = Math.cos;
		    var _sin = Math.sin;
		    var _tan = Math.tan;
		    var _rnd = Math.round;
		    function reset() {
		      this.props[0] = 1;
		      this.props[1] = 0;
		      this.props[2] = 0;
		      this.props[3] = 0;
		      this.props[4] = 0;
		      this.props[5] = 1;
		      this.props[6] = 0;
		      this.props[7] = 0;
		      this.props[8] = 0;
		      this.props[9] = 0;
		      this.props[10] = 1;
		      this.props[11] = 0;
		      this.props[12] = 0;
		      this.props[13] = 0;
		      this.props[14] = 0;
		      this.props[15] = 1;
		      return this;
		    }
		    function rotate(angle) {
		      if (angle === 0) {
		        return this;
		      }
		      var mCos = _cos(angle);
		      var mSin = _sin(angle);
		      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		    }
		    function rotateX(angle) {
		      if (angle === 0) {
		        return this;
		      }
		      var mCos = _cos(angle);
		      var mSin = _sin(angle);
		      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
		    }
		    function rotateY(angle) {
		      if (angle === 0) {
		        return this;
		      }
		      var mCos = _cos(angle);
		      var mSin = _sin(angle);
		      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
		    }
		    function rotateZ(angle) {
		      if (angle === 0) {
		        return this;
		      }
		      var mCos = _cos(angle);
		      var mSin = _sin(angle);
		      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		    }
		    function shear(sx, sy) {
		      return this._t(1, sy, sx, 1, 0, 0);
		    }
		    function skew(ax, ay) {
		      return this.shear(_tan(ax), _tan(ay));
		    }
		    function skewFromAxis(ax, angle) {
		      var mCos = _cos(angle);
		      var mSin = _sin(angle);
		      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		      // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
		    }
		    function scale(sx, sy, sz) {
		      if (!sz && sz !== 0) {
		        sz = 1;
		      }
		      if (sx === 1 && sy === 1 && sz === 1) {
		        return this;
		      }
		      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
		    }
		    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
		      this.props[0] = a;
		      this.props[1] = b;
		      this.props[2] = c;
		      this.props[3] = d;
		      this.props[4] = e;
		      this.props[5] = f;
		      this.props[6] = g;
		      this.props[7] = h;
		      this.props[8] = i;
		      this.props[9] = j;
		      this.props[10] = k;
		      this.props[11] = l;
		      this.props[12] = m;
		      this.props[13] = n;
		      this.props[14] = o;
		      this.props[15] = p;
		      return this;
		    }
		    function translate(tx, ty, tz) {
		      tz = tz || 0;
		      if (tx !== 0 || ty !== 0 || tz !== 0) {
		        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
		      }
		      return this;
		    }
		    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
		      var _p = this.props;
		      if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
		        // NOTE: commenting this condition because TurboFan deoptimizes code when present
		        // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
		        _p[12] = _p[12] * a2 + _p[15] * m2;
		        _p[13] = _p[13] * f2 + _p[15] * n2;
		        _p[14] = _p[14] * k2 + _p[15] * o2;
		        _p[15] *= p2;
		        // }
		        this._identityCalculated = false;
		        return this;
		      }
		      var a1 = _p[0];
		      var b1 = _p[1];
		      var c1 = _p[2];
		      var d1 = _p[3];
		      var e1 = _p[4];
		      var f1 = _p[5];
		      var g1 = _p[6];
		      var h1 = _p[7];
		      var i1 = _p[8];
		      var j1 = _p[9];
		      var k1 = _p[10];
		      var l1 = _p[11];
		      var m1 = _p[12];
		      var n1 = _p[13];
		      var o1 = _p[14];
		      var p1 = _p[15];

		      /* matrix order (canvas compatible):
		           * ace
		           * bdf
		           * 001
		           */
		      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
		      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
		      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
		      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
		      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
		      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
		      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
		      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
		      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
		      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
		      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
		      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
		      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
		      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
		      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
		      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
		      this._identityCalculated = false;
		      return this;
		    }
		    function multiply(matrix) {
		      var matrixProps = matrix.props;
		      return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
		    }
		    function isIdentity() {
		      if (!this._identityCalculated) {
		        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
		        this._identityCalculated = true;
		      }
		      return this._identity;
		    }
		    function equals(matr) {
		      var i = 0;
		      while (i < 16) {
		        if (matr.props[i] !== this.props[i]) {
		          return false;
		        }
		        i += 1;
		      }
		      return true;
		    }
		    function clone(matr) {
		      var i;
		      for (i = 0; i < 16; i += 1) {
		        matr.props[i] = this.props[i];
		      }
		      return matr;
		    }
		    function cloneFromProps(props) {
		      var i;
		      for (i = 0; i < 16; i += 1) {
		        this.props[i] = props[i];
		      }
		    }
		    function applyToPoint(x, y, z) {
		      return {
		        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
		        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
		        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
		      };
		      /* return {
		           x: x * me.a + y * me.c + me.e,
		           y: x * me.b + y * me.d + me.f
		           }; */
		    }
		    function applyToX(x, y, z) {
		      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
		    }
		    function applyToY(x, y, z) {
		      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
		    }
		    function applyToZ(x, y, z) {
		      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
		    }
		    function getInverseMatrix() {
		      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
		      var a = this.props[5] / determinant;
		      var b = -this.props[1] / determinant;
		      var c = -this.props[4] / determinant;
		      var d = this.props[0] / determinant;
		      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
		      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
		      var inverseMatrix = new Matrix();
		      inverseMatrix.props[0] = a;
		      inverseMatrix.props[1] = b;
		      inverseMatrix.props[4] = c;
		      inverseMatrix.props[5] = d;
		      inverseMatrix.props[12] = e;
		      inverseMatrix.props[13] = f;
		      return inverseMatrix;
		    }
		    function inversePoint(pt) {
		      var inverseMatrix = this.getInverseMatrix();
		      return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
		    }
		    function inversePoints(pts) {
		      var i;
		      var len = pts.length;
		      var retPts = [];
		      for (i = 0; i < len; i += 1) {
		        retPts[i] = inversePoint(pts[i]);
		      }
		      return retPts;
		    }
		    function applyToTriplePoints(pt1, pt2, pt3) {
		      var arr = createTypedArray('float32', 6);
		      if (this.isIdentity()) {
		        arr[0] = pt1[0];
		        arr[1] = pt1[1];
		        arr[2] = pt2[0];
		        arr[3] = pt2[1];
		        arr[4] = pt3[0];
		        arr[5] = pt3[1];
		      } else {
		        var p0 = this.props[0];
		        var p1 = this.props[1];
		        var p4 = this.props[4];
		        var p5 = this.props[5];
		        var p12 = this.props[12];
		        var p13 = this.props[13];
		        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
		        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
		        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
		        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
		        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
		        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
		      }
		      return arr;
		    }
		    function applyToPointArray(x, y, z) {
		      var arr;
		      if (this.isIdentity()) {
		        arr = [x, y, z];
		      } else {
		        arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
		      }
		      return arr;
		    }
		    function applyToPointStringified(x, y) {
		      if (this.isIdentity()) {
		        return x + ',' + y;
		      }
		      var _p = this.props;
		      return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
		    }
		    function toCSS() {
		      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
		      /* if(this.isIdentity()) {
		              return '';
		          } */
		      var i = 0;
		      var props = this.props;
		      var cssValue = 'matrix3d(';
		      var v = 10000;
		      while (i < 16) {
		        cssValue += _rnd(props[i] * v) / v;
		        cssValue += i === 15 ? ')' : ',';
		        i += 1;
		      }
		      return cssValue;
		    }
		    function roundMatrixProperty(val) {
		      var v = 10000;
		      if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
		        return _rnd(val * v) / v;
		      }
		      return val;
		    }
		    function to2dCSS() {
		      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
		      /* if(this.isIdentity()) {
		              return '';
		          } */
		      var props = this.props;
		      var _a = roundMatrixProperty(props[0]);
		      var _b = roundMatrixProperty(props[1]);
		      var _c = roundMatrixProperty(props[4]);
		      var _d = roundMatrixProperty(props[5]);
		      var _e = roundMatrixProperty(props[12]);
		      var _f = roundMatrixProperty(props[13]);
		      return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
		    }
		    return function () {
		      this.reset = reset;
		      this.rotate = rotate;
		      this.rotateX = rotateX;
		      this.rotateY = rotateY;
		      this.rotateZ = rotateZ;
		      this.skew = skew;
		      this.skewFromAxis = skewFromAxis;
		      this.shear = shear;
		      this.scale = scale;
		      this.setTransform = setTransform;
		      this.translate = translate;
		      this.transform = transform;
		      this.multiply = multiply;
		      this.applyToPoint = applyToPoint;
		      this.applyToX = applyToX;
		      this.applyToY = applyToY;
		      this.applyToZ = applyToZ;
		      this.applyToPointArray = applyToPointArray;
		      this.applyToTriplePoints = applyToTriplePoints;
		      this.applyToPointStringified = applyToPointStringified;
		      this.toCSS = toCSS;
		      this.to2dCSS = to2dCSS;
		      this.clone = clone;
		      this.cloneFromProps = cloneFromProps;
		      this.equals = equals;
		      this.inversePoints = inversePoints;
		      this.inversePoint = inversePoint;
		      this.getInverseMatrix = getInverseMatrix;
		      this._t = this.transform;
		      this.isIdentity = isIdentity;
		      this._identity = true;
		      this._identityCalculated = false;
		      this.props = createTypedArray('float32', 16);
		      this.reset();
		    };
		  }();

		  function _typeof$3(o) { "@babel/helpers - typeof"; return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$3(o); }
		  var lottie = {};
		  function setLocation(href) {
		    setLocationHref(href);
		  }
		  function searchAnimations() {
		    {
		      animationManager.searchAnimations();
		    }
		  }
		  function setSubframeRendering(flag) {
		    setSubframeEnabled(flag);
		  }
		  function setPrefix(prefix) {
		    setIdPrefix(prefix);
		  }
		  function loadAnimation(params) {
		    return animationManager.loadAnimation(params);
		  }
		  function setQuality(value) {
		    if (typeof value === 'string') {
		      switch (value) {
		        case 'high':
		          setDefaultCurveSegments(200);
		          break;
		        default:
		        case 'medium':
		          setDefaultCurveSegments(50);
		          break;
		        case 'low':
		          setDefaultCurveSegments(10);
		          break;
		      }
		    } else if (!isNaN(value) && value > 1) {
		      setDefaultCurveSegments(value);
		    }
		  }
		  function inBrowser() {
		    return typeof navigator !== 'undefined';
		  }
		  function installPlugin(type, plugin) {
		    if (type === 'expressions') {
		      setExpressionsPlugin(plugin);
		    }
		  }
		  function getFactory(name) {
		    switch (name) {
		      case 'propertyFactory':
		        return PropertyFactory;
		      case 'shapePropertyFactory':
		        return ShapePropertyFactory;
		      case 'matrix':
		        return Matrix;
		      default:
		        return null;
		    }
		  }
		  lottie.play = animationManager.play;
		  lottie.pause = animationManager.pause;
		  lottie.setLocationHref = setLocation;
		  lottie.togglePause = animationManager.togglePause;
		  lottie.setSpeed = animationManager.setSpeed;
		  lottie.setDirection = animationManager.setDirection;
		  lottie.stop = animationManager.stop;
		  lottie.searchAnimations = searchAnimations;
		  lottie.registerAnimation = animationManager.registerAnimation;
		  lottie.loadAnimation = loadAnimation;
		  lottie.setSubframeRendering = setSubframeRendering;
		  lottie.resize = animationManager.resize;
		  // lottie.start = start;
		  lottie.goToAndStop = animationManager.goToAndStop;
		  lottie.destroy = animationManager.destroy;
		  lottie.setQuality = setQuality;
		  lottie.inBrowser = inBrowser;
		  lottie.installPlugin = installPlugin;
		  lottie.freeze = animationManager.freeze;
		  lottie.unfreeze = animationManager.unfreeze;
		  lottie.setVolume = animationManager.setVolume;
		  lottie.mute = animationManager.mute;
		  lottie.unmute = animationManager.unmute;
		  lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
		  lottie.useWebWorker = setWebWorker;
		  lottie.setIDPrefix = setPrefix;
		  lottie.__getFactory = getFactory;
		  lottie.version = '5.13.0';
		  function checkReady() {
		    if (document.readyState === 'complete') {
		      clearInterval(readyStateCheckInterval);
		      searchAnimations();
		    }
		  }
		  function getQueryVariable(variable) {
		    var vars = queryString.split('&');
		    for (var i = 0; i < vars.length; i += 1) {
		      var pair = vars[i].split('=');
		      if (decodeURIComponent(pair[0]) == variable) {
		        // eslint-disable-line eqeqeq
		        return decodeURIComponent(pair[1]);
		      }
		    }
		    return null;
		  }
		  var queryString = '';
		  {
		    var scripts = document.getElementsByTagName('script');
		    var index = scripts.length - 1;
		    var myScript = scripts[index] || {
		      src: ''
		    };
		    queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, '') : ''; // eslint-disable-line no-useless-escape
		    getQueryVariable('renderer');
		  }
		  var readyStateCheckInterval = setInterval(checkReady, 100);

		  // this adds bodymovin to the window object for backwards compatibility
		  try {
		    if (!(('object' === "undefined" ? "undefined" : _typeof$3(exports)) === 'object' && 'object' !== 'undefined') && !(typeof undefined === 'function' && undefined.amd) // eslint-disable-line no-undef
		    ) {
		      window.bodymovin = lottie;
		    }
		  } catch (err) {
		    //
		  }

		  var ShapeModifiers = function () {
		    var ob = {};
		    var modifiers = {};
		    ob.registerModifier = registerModifier;
		    ob.getModifier = getModifier;
		    function registerModifier(nm, factory) {
		      if (!modifiers[nm]) {
		        modifiers[nm] = factory;
		      }
		    }
		    function getModifier(nm, elem, data) {
		      return new modifiers[nm](elem, data);
		    }
		    return ob;
		  }();
		  function ShapeModifier() {}
		  ShapeModifier.prototype.initModifierProperties = function () {};
		  ShapeModifier.prototype.addShapeToModifier = function () {};
		  ShapeModifier.prototype.addShape = function (data) {
		    if (!this.closed) {
		      // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
		      data.sh.container.addDynamicProperty(data.sh);
		      var shapeData = {
		        shape: data.sh,
		        data: data,
		        localShapeCollection: shapeCollectionPool.newShapeCollection()
		      };
		      this.shapes.push(shapeData);
		      this.addShapeToModifier(shapeData);
		      if (this._isAnimated) {
		        data.setAsAnimated();
		      }
		    }
		  };
		  ShapeModifier.prototype.init = function (elem, data) {
		    this.shapes = [];
		    this.elem = elem;
		    this.initDynamicPropertyContainer(elem);
		    this.initModifierProperties(elem, data);
		    this.frameId = initialDefaultFrame;
		    this.closed = false;
		    this.k = false;
		    if (this.dynamicProperties.length) {
		      this.k = true;
		    } else {
		      this.getValue(true);
		    }
		  };
		  ShapeModifier.prototype.processKeys = function () {
		    if (this.elem.globalData.frameId === this.frameId) {
		      return;
		    }
		    this.frameId = this.elem.globalData.frameId;
		    this.iterateDynamicProperties();
		  };
		  extendPrototype([DynamicPropertyContainer], ShapeModifier);

		  function TrimModifier() {}
		  extendPrototype([ShapeModifier], TrimModifier);
		  TrimModifier.prototype.initModifierProperties = function (elem, data) {
		    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
		    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
		    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
		    this.sValue = 0;
		    this.eValue = 0;
		    this.getValue = this.processKeys;
		    this.m = data.m;
		    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
		  };
		  TrimModifier.prototype.addShapeToModifier = function (shapeData) {
		    shapeData.pathsData = [];
		  };
		  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
		    var segments = [];
		    if (e <= 1) {
		      segments.push({
		        s: s,
		        e: e
		      });
		    } else if (s >= 1) {
		      segments.push({
		        s: s - 1,
		        e: e - 1
		      });
		    } else {
		      segments.push({
		        s: s,
		        e: 1
		      });
		      segments.push({
		        s: 0,
		        e: e - 1
		      });
		    }
		    var shapeSegments = [];
		    var i;
		    var len = segments.length;
		    var segmentOb;
		    for (i = 0; i < len; i += 1) {
		      segmentOb = segments[i];
		      if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
		        var shapeS;
		        var shapeE;
		        if (segmentOb.s * totalModifierLength <= addedLength) {
		          shapeS = 0;
		        } else {
		          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
		        }
		        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
		          shapeE = 1;
		        } else {
		          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
		        }
		        shapeSegments.push([shapeS, shapeE]);
		      }
		    }
		    if (!shapeSegments.length) {
		      shapeSegments.push([0, 0]);
		    }
		    return shapeSegments;
		  };
		  TrimModifier.prototype.releasePathsData = function (pathsData) {
		    var i;
		    var len = pathsData.length;
		    for (i = 0; i < len; i += 1) {
		      segmentsLengthPool.release(pathsData[i]);
		    }
		    pathsData.length = 0;
		    return pathsData;
		  };
		  TrimModifier.prototype.processShapes = function (_isFirstFrame) {
		    var s;
		    var e;
		    if (this._mdf || _isFirstFrame) {
		      var o = this.o.v % 360 / 360;
		      if (o < 0) {
		        o += 1;
		      }
		      if (this.s.v > 1) {
		        s = 1 + o;
		      } else if (this.s.v < 0) {
		        s = 0 + o;
		      } else {
		        s = this.s.v + o;
		      }
		      if (this.e.v > 1) {
		        e = 1 + o;
		      } else if (this.e.v < 0) {
		        e = 0 + o;
		      } else {
		        e = this.e.v + o;
		      }
		      if (s > e) {
		        var _s = s;
		        s = e;
		        e = _s;
		      }
		      s = Math.round(s * 10000) * 0.0001;
		      e = Math.round(e * 10000) * 0.0001;
		      this.sValue = s;
		      this.eValue = e;
		    } else {
		      s = this.sValue;
		      e = this.eValue;
		    }
		    var shapePaths;
		    var i;
		    var len = this.shapes.length;
		    var j;
		    var jLen;
		    var pathsData;
		    var pathData;
		    var totalShapeLength;
		    var totalModifierLength = 0;
		    if (e === s) {
		      for (i = 0; i < len; i += 1) {
		        this.shapes[i].localShapeCollection.releaseShapes();
		        this.shapes[i].shape._mdf = true;
		        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
		        if (this._mdf) {
		          this.shapes[i].pathsData.length = 0;
		        }
		      }
		    } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
		      var segments = [];
		      var shapeData;
		      var localShapeCollection;
		      for (i = 0; i < len; i += 1) {
		        shapeData = this.shapes[i];
		        // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
		        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
		          shapeData.shape.paths = shapeData.localShapeCollection;
		        } else {
		          shapePaths = shapeData.shape.paths;
		          jLen = shapePaths._length;
		          totalShapeLength = 0;
		          if (!shapeData.shape._mdf && shapeData.pathsData.length) {
		            totalShapeLength = shapeData.totalShapeLength;
		          } else {
		            pathsData = this.releasePathsData(shapeData.pathsData);
		            for (j = 0; j < jLen; j += 1) {
		              pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
		              pathsData.push(pathData);
		              totalShapeLength += pathData.totalLength;
		            }
		            shapeData.totalShapeLength = totalShapeLength;
		            shapeData.pathsData = pathsData;
		          }
		          totalModifierLength += totalShapeLength;
		          shapeData.shape._mdf = true;
		        }
		      }
		      var shapeS = s;
		      var shapeE = e;
		      var addedLength = 0;
		      var edges;
		      for (i = len - 1; i >= 0; i -= 1) {
		        shapeData = this.shapes[i];
		        if (shapeData.shape._mdf) {
		          localShapeCollection = shapeData.localShapeCollection;
		          localShapeCollection.releaseShapes();
		          // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
		          if (this.m === 2 && len > 1) {
		            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
		            addedLength += shapeData.totalShapeLength;
		          } else {
		            edges = [[shapeS, shapeE]];
		          }
		          jLen = edges.length;
		          for (j = 0; j < jLen; j += 1) {
		            shapeS = edges[j][0];
		            shapeE = edges[j][1];
		            segments.length = 0;
		            if (shapeE <= 1) {
		              segments.push({
		                s: shapeData.totalShapeLength * shapeS,
		                e: shapeData.totalShapeLength * shapeE
		              });
		            } else if (shapeS >= 1) {
		              segments.push({
		                s: shapeData.totalShapeLength * (shapeS - 1),
		                e: shapeData.totalShapeLength * (shapeE - 1)
		              });
		            } else {
		              segments.push({
		                s: shapeData.totalShapeLength * shapeS,
		                e: shapeData.totalShapeLength
		              });
		              segments.push({
		                s: 0,
		                e: shapeData.totalShapeLength * (shapeE - 1)
		              });
		            }
		            var newShapesData = this.addShapes(shapeData, segments[0]);
		            if (segments[0].s !== segments[0].e) {
		              if (segments.length > 1) {
		                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
		                if (lastShapeInCollection.c) {
		                  var lastShape = newShapesData.pop();
		                  this.addPaths(newShapesData, localShapeCollection);
		                  newShapesData = this.addShapes(shapeData, segments[1], lastShape);
		                } else {
		                  this.addPaths(newShapesData, localShapeCollection);
		                  newShapesData = this.addShapes(shapeData, segments[1]);
		                }
		              }
		              this.addPaths(newShapesData, localShapeCollection);
		            }
		          }
		          shapeData.shape.paths = localShapeCollection;
		        }
		      }
		    } else if (this._mdf) {
		      for (i = 0; i < len; i += 1) {
		        // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
		        // Don't remove this even if it's losing cached info.
		        this.shapes[i].pathsData.length = 0;
		        this.shapes[i].shape._mdf = true;
		      }
		    }
		  };
		  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
		    var i;
		    var len = newPaths.length;
		    for (i = 0; i < len; i += 1) {
		      localShapeCollection.addShape(newPaths[i]);
		    }
		  };
		  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
		    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
		    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
		    if (newShape) {
		      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
		    }
		    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
		  };
		  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
		    shapePath.setXYAt(points[1], points[5], 'o', pos);
		    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
		    if (newShape) {
		      shapePath.setXYAt(points[0], points[4], 'v', pos);
		    }
		    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
		  };
		  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
		    var pathsData = shapeData.pathsData;
		    var shapePaths = shapeData.shape.paths.shapes;
		    var i;
		    var len = shapeData.shape.paths._length;
		    var j;
		    var jLen;
		    var addedLength = 0;
		    var currentLengthData;
		    var segmentCount;
		    var lengths;
		    var segment;
		    var shapes = [];
		    var initPos;
		    var newShape = true;
		    if (!shapePath) {
		      shapePath = shapePool.newElement();
		      segmentCount = 0;
		      initPos = 0;
		    } else {
		      segmentCount = shapePath._length;
		      initPos = shapePath._length;
		    }
		    shapes.push(shapePath);
		    for (i = 0; i < len; i += 1) {
		      lengths = pathsData[i].lengths;
		      shapePath.c = shapePaths[i].c;
		      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
		      for (j = 1; j < jLen; j += 1) {
		        currentLengthData = lengths[j - 1];
		        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
		          addedLength += currentLengthData.addedLength;
		          shapePath.c = false;
		        } else if (addedLength > shapeSegment.e) {
		          shapePath.c = false;
		          break;
		        } else {
		          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
		            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
		            newShape = false;
		          } else {
		            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
		            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
		            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
		            newShape = false;
		            shapePath.c = false;
		          }
		          addedLength += currentLengthData.addedLength;
		          segmentCount += 1;
		        }
		      }
		      if (shapePaths[i].c && lengths.length) {
		        currentLengthData = lengths[j - 1];
		        if (addedLength <= shapeSegment.e) {
		          var segmentLength = lengths[j - 1].addedLength;
		          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
		            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
		            newShape = false;
		          } else {
		            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
		            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
		            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
		            newShape = false;
		            shapePath.c = false;
		          }
		        } else {
		          shapePath.c = false;
		        }
		        addedLength += currentLengthData.addedLength;
		        segmentCount += 1;
		      }
		      if (shapePath._length) {
		        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
		        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
		      }
		      if (addedLength > shapeSegment.e) {
		        break;
		      }
		      if (i < len - 1) {
		        shapePath = shapePool.newElement();
		        newShape = true;
		        shapes.push(shapePath);
		        segmentCount = 0;
		      }
		    }
		    return shapes;
		  };

		  function PuckerAndBloatModifier() {}
		  extendPrototype([ShapeModifier], PuckerAndBloatModifier);
		  PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
		    this.getValue = this.processKeys;
		    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
		    this._isAnimated = !!this.amount.effectsSequence.length;
		  };
		  PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
		    var percent = amount / 100;
		    var centerPoint = [0, 0];
		    var pathLength = path._length;
		    var i = 0;
		    for (i = 0; i < pathLength; i += 1) {
		      centerPoint[0] += path.v[i][0];
		      centerPoint[1] += path.v[i][1];
		    }
		    centerPoint[0] /= pathLength;
		    centerPoint[1] /= pathLength;
		    var clonedPath = shapePool.newElement();
		    clonedPath.c = path.c;
		    var vX;
		    var vY;
		    var oX;
		    var oY;
		    var iX;
		    var iY;
		    for (i = 0; i < pathLength; i += 1) {
		      vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
		      vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
		      oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
		      oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
		      iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
		      iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
		      clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
		    }
		    return clonedPath;
		  };
		  PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
		    var shapePaths;
		    var i;
		    var len = this.shapes.length;
		    var j;
		    var jLen;
		    var amount = this.amount.v;
		    if (amount !== 0) {
		      var shapeData;
		      var localShapeCollection;
		      for (i = 0; i < len; i += 1) {
		        shapeData = this.shapes[i];
		        localShapeCollection = shapeData.localShapeCollection;
		        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
		          localShapeCollection.releaseShapes();
		          shapeData.shape._mdf = true;
		          shapePaths = shapeData.shape.paths.shapes;
		          jLen = shapeData.shape.paths._length;
		          for (j = 0; j < jLen; j += 1) {
		            localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
		          }
		        }
		        shapeData.shape.paths = shapeData.localShapeCollection;
		      }
		    }
		    if (!this.dynamicProperties.length) {
		      this._mdf = false;
		    }
		  };

		  var TransformPropertyFactory = function () {
		    var defaultVector = [0, 0];
		    function applyToMatrix(mat) {
		      var _mdf = this._mdf;
		      this.iterateDynamicProperties();
		      this._mdf = this._mdf || _mdf;
		      if (this.a) {
		        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
		      }
		      if (this.s) {
		        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
		      }
		      if (this.sk) {
		        mat.skewFromAxis(-this.sk.v, this.sa.v);
		      }
		      if (this.r) {
		        mat.rotate(-this.r.v);
		      } else {
		        mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
		      }
		      if (this.data.p.s) {
		        if (this.data.p.z) {
		          mat.translate(this.px.v, this.py.v, -this.pz.v);
		        } else {
		          mat.translate(this.px.v, this.py.v, 0);
		        }
		      } else {
		        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
		      }
		    }
		    function processKeys(forceRender) {
		      if (this.elem.globalData.frameId === this.frameId) {
		        return;
		      }
		      if (this._isDirty) {
		        this.precalculateMatrix();
		        this._isDirty = false;
		      }
		      this.iterateDynamicProperties();
		      if (this._mdf || forceRender) {
		        var frameRate;
		        this.v.cloneFromProps(this.pre.props);
		        if (this.appliedTransformations < 1) {
		          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
		        }
		        if (this.appliedTransformations < 2) {
		          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
		        }
		        if (this.sk && this.appliedTransformations < 3) {
		          this.v.skewFromAxis(-this.sk.v, this.sa.v);
		        }
		        if (this.r && this.appliedTransformations < 4) {
		          this.v.rotate(-this.r.v);
		        } else if (!this.r && this.appliedTransformations < 4) {
		          this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
		        }
		        if (this.autoOriented) {
		          var v1;
		          var v2;
		          frameRate = this.elem.globalData.frameRate;
		          if (this.p && this.p.keyframes && this.p.getValueAtTime) {
		            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
		              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
		              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
		            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
		              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
		              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
		            } else {
		              v1 = this.p.pv;
		              v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
		            }
		          } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
		            v1 = [];
		            v2 = [];
		            var px = this.px;
		            var py = this.py;
		            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
		              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
		              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
		              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
		              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
		            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
		              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
		              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
		              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
		              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
		            } else {
		              v1 = [px.pv, py.pv];
		              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
		              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
		            }
		          } else {
		            v2 = defaultVector;
		            v1 = v2;
		          }
		          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
		        }
		        if (this.data.p && this.data.p.s) {
		          if (this.data.p.z) {
		            this.v.translate(this.px.v, this.py.v, -this.pz.v);
		          } else {
		            this.v.translate(this.px.v, this.py.v, 0);
		          }
		        } else {
		          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
		        }
		      }
		      this.frameId = this.elem.globalData.frameId;
		    }
		    function precalculateMatrix() {
		      this.appliedTransformations = 0;
		      this.pre.reset();
		      if (!this.a.effectsSequence.length) {
		        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
		        this.appliedTransformations = 1;
		      } else {
		        return;
		      }
		      if (!this.s.effectsSequence.length) {
		        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
		        this.appliedTransformations = 2;
		      } else {
		        return;
		      }
		      if (this.sk) {
		        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
		          this.pre.skewFromAxis(-this.sk.v, this.sa.v);
		          this.appliedTransformations = 3;
		        } else {
		          return;
		        }
		      }
		      if (this.r) {
		        if (!this.r.effectsSequence.length) {
		          this.pre.rotate(-this.r.v);
		          this.appliedTransformations = 4;
		        }
		      } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
		        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
		        this.appliedTransformations = 4;
		      }
		    }
		    function autoOrient() {
		      //
		      // var prevP = this.getValueAtTime();
		    }
		    function addDynamicProperty(prop) {
		      this._addDynamicProperty(prop);
		      this.elem.addDynamicProperty(prop);
		      this._isDirty = true;
		    }
		    function TransformProperty(elem, data, container) {
		      this.elem = elem;
		      this.frameId = -1;
		      this.propType = 'transform';
		      this.data = data;
		      this.v = new Matrix();
		      // Precalculated matrix with non animated properties
		      this.pre = new Matrix();
		      this.appliedTransformations = 0;
		      this.initDynamicPropertyContainer(container || elem);
		      if (data.p && data.p.s) {
		        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
		        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
		        if (data.p.z) {
		          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
		        }
		      } else {
		        this.p = PropertyFactory.getProp(elem, data.p || {
		          k: [0, 0, 0]
		        }, 1, 0, this);
		      }
		      if (data.rx) {
		        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
		        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
		        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
		        if (data.or.k[0].ti) {
		          var i;
		          var len = data.or.k.length;
		          for (i = 0; i < len; i += 1) {
		            data.or.k[i].to = null;
		            data.or.k[i].ti = null;
		          }
		        }
		        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
		        // sh Indicates it needs to be capped between -180 and 180
		        this.or.sh = true;
		      } else {
		        this.r = PropertyFactory.getProp(elem, data.r || {
		          k: 0
		        }, 0, degToRads, this);
		      }
		      if (data.sk) {
		        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
		        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
		      }
		      this.a = PropertyFactory.getProp(elem, data.a || {
		        k: [0, 0, 0]
		      }, 1, 0, this);
		      this.s = PropertyFactory.getProp(elem, data.s || {
		        k: [100, 100, 100]
		      }, 1, 0.01, this);
		      // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
		      if (data.o) {
		        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
		      } else {
		        this.o = {
		          _mdf: false,
		          v: 1
		        };
		      }
		      this._isDirty = true;
		      if (!this.dynamicProperties.length) {
		        this.getValue(true);
		      }
		    }
		    TransformProperty.prototype = {
		      applyToMatrix: applyToMatrix,
		      getValue: processKeys,
		      precalculateMatrix: precalculateMatrix,
		      autoOrient: autoOrient
		    };
		    extendPrototype([DynamicPropertyContainer], TransformProperty);
		    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
		    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
		    function getTransformProperty(elem, data, container) {
		      return new TransformProperty(elem, data, container);
		    }
		    return {
		      getTransformProperty: getTransformProperty
		    };
		  }();

		  function RepeaterModifier() {}
		  extendPrototype([ShapeModifier], RepeaterModifier);
		  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
		    this.getValue = this.processKeys;
		    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
		    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
		    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
		    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
		    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
		    this.data = data;
		    if (!this.dynamicProperties.length) {
		      this.getValue(true);
		    }
		    this._isAnimated = !!this.dynamicProperties.length;
		    this.pMatrix = new Matrix();
		    this.rMatrix = new Matrix();
		    this.sMatrix = new Matrix();
		    this.tMatrix = new Matrix();
		    this.matrix = new Matrix();
		  };
		  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
		    var dir = inv ? -1 : 1;
		    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
		    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
		    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
		    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
		    rMatrix.rotate(-transform.r.v * dir * perc);
		    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
		    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
		    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
		    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
		  };
		  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
		    this.elem = elem;
		    this.arr = arr;
		    this.pos = pos;
		    this.elemsData = elemsData;
		    this._currentCopies = 0;
		    this._elements = [];
		    this._groups = [];
		    this.frameId = -1;
		    this.initDynamicPropertyContainer(elem);
		    this.initModifierProperties(elem, arr[pos]);
		    while (pos > 0) {
		      pos -= 1;
		      // this._elements.unshift(arr.splice(pos,1)[0]);
		      this._elements.unshift(arr[pos]);
		    }
		    if (this.dynamicProperties.length) {
		      this.k = true;
		    } else {
		      this.getValue(true);
		    }
		  };
		  RepeaterModifier.prototype.resetElements = function (elements) {
		    var i;
		    var len = elements.length;
		    for (i = 0; i < len; i += 1) {
		      elements[i]._processed = false;
		      if (elements[i].ty === 'gr') {
		        this.resetElements(elements[i].it);
		      }
		    }
		  };
		  RepeaterModifier.prototype.cloneElements = function (elements) {
		    var newElements = JSON.parse(JSON.stringify(elements));
		    this.resetElements(newElements);
		    return newElements;
		  };
		  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
		    var i;
		    var len = elements.length;
		    for (i = 0; i < len; i += 1) {
		      elements[i]._render = renderFlag;
		      if (elements[i].ty === 'gr') {
		        this.changeGroupRender(elements[i].it, renderFlag);
		      }
		    }
		  };
		  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
		    var items;
		    var itemsTransform;
		    var i;
		    var dir;
		    var cont;
		    var hasReloaded = false;
		    if (this._mdf || _isFirstFrame) {
		      var copies = Math.ceil(this.c.v);
		      if (this._groups.length < copies) {
		        while (this._groups.length < copies) {
		          var group = {
		            it: this.cloneElements(this._elements),
		            ty: 'gr'
		          };
		          group.it.push({
		            a: {
		              a: 0,
		              ix: 1,
		              k: [0, 0]
		            },
		            nm: 'Transform',
		            o: {
		              a: 0,
		              ix: 7,
		              k: 100
		            },
		            p: {
		              a: 0,
		              ix: 2,
		              k: [0, 0]
		            },
		            r: {
		              a: 1,
		              ix: 6,
		              k: [{
		                s: 0,
		                e: 0,
		                t: 0
		              }, {
		                s: 0,
		                e: 0,
		                t: 1
		              }]
		            },
		            s: {
		              a: 0,
		              ix: 3,
		              k: [100, 100]
		            },
		            sa: {
		              a: 0,
		              ix: 5,
		              k: 0
		            },
		            sk: {
		              a: 0,
		              ix: 4,
		              k: 0
		            },
		            ty: 'tr'
		          });
		          this.arr.splice(0, 0, group);
		          this._groups.splice(0, 0, group);
		          this._currentCopies += 1;
		        }
		        this.elem.reloadShapes();
		        hasReloaded = true;
		      }
		      cont = 0;
		      var renderFlag;
		      for (i = 0; i <= this._groups.length - 1; i += 1) {
		        renderFlag = cont < copies;
		        this._groups[i]._render = renderFlag;
		        this.changeGroupRender(this._groups[i].it, renderFlag);
		        if (!renderFlag) {
		          var elems = this.elemsData[i].it;
		          var transformData = elems[elems.length - 1];
		          if (transformData.transform.op.v !== 0) {
		            transformData.transform.op._mdf = true;
		            transformData.transform.op.v = 0;
		          } else {
		            transformData.transform.op._mdf = false;
		          }
		        }
		        cont += 1;
		      }
		      this._currentCopies = copies;
		      /// /

		      var offset = this.o.v;
		      var offsetModulo = offset % 1;
		      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
		      var pProps = this.pMatrix.props;
		      var rProps = this.rMatrix.props;
		      var sProps = this.sMatrix.props;
		      this.pMatrix.reset();
		      this.rMatrix.reset();
		      this.sMatrix.reset();
		      this.tMatrix.reset();
		      this.matrix.reset();
		      var iteration = 0;
		      if (offset > 0) {
		        while (iteration < roundOffset) {
		          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
		          iteration += 1;
		        }
		        if (offsetModulo) {
		          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
		          iteration += offsetModulo;
		        }
		      } else if (offset < 0) {
		        while (iteration > roundOffset) {
		          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
		          iteration -= 1;
		        }
		        if (offsetModulo) {
		          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
		          iteration -= offsetModulo;
		        }
		      }
		      i = this.data.m === 1 ? 0 : this._currentCopies - 1;
		      dir = this.data.m === 1 ? 1 : -1;
		      cont = this._currentCopies;
		      var j;
		      var jLen;
		      while (cont) {
		        items = this.elemsData[i].it;
		        itemsTransform = items[items.length - 1].transform.mProps.v.props;
		        jLen = itemsTransform.length;
		        items[items.length - 1].transform.mProps._mdf = true;
		        items[items.length - 1].transform.op._mdf = true;
		        items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
		        if (iteration !== 0) {
		          if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
		            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
		          }
		          this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
		          this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
		          this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
		          for (j = 0; j < jLen; j += 1) {
		            itemsTransform[j] = this.matrix.props[j];
		          }
		          this.matrix.reset();
		        } else {
		          this.matrix.reset();
		          for (j = 0; j < jLen; j += 1) {
		            itemsTransform[j] = this.matrix.props[j];
		          }
		        }
		        iteration += 1;
		        cont -= 1;
		        i += dir;
		      }
		    } else {
		      cont = this._currentCopies;
		      i = 0;
		      dir = 1;
		      while (cont) {
		        items = this.elemsData[i].it;
		        itemsTransform = items[items.length - 1].transform.mProps.v.props;
		        items[items.length - 1].transform.mProps._mdf = false;
		        items[items.length - 1].transform.op._mdf = false;
		        cont -= 1;
		        i += dir;
		      }
		    }
		    return hasReloaded;
		  };
		  RepeaterModifier.prototype.addShape = function () {};

		  function RoundCornersModifier() {}
		  extendPrototype([ShapeModifier], RoundCornersModifier);
		  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
		    this.getValue = this.processKeys;
		    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
		    this._isAnimated = !!this.rd.effectsSequence.length;
		  };
		  RoundCornersModifier.prototype.processPath = function (path, round) {
		    var clonedPath = shapePool.newElement();
		    clonedPath.c = path.c;
		    var i;
		    var len = path._length;
		    var currentV;
		    var currentI;
		    var currentO;
		    var closerV;
		    var distance;
		    var newPosPerc;
		    var index = 0;
		    var vX;
		    var vY;
		    var oX;
		    var oY;
		    var iX;
		    var iY;
		    for (i = 0; i < len; i += 1) {
		      currentV = path.v[i];
		      currentO = path.o[i];
		      currentI = path.i[i];
		      if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
		        if ((i === 0 || i === len - 1) && !path.c) {
		          clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
		          /* clonedPath.v[index] = currentV;
		                  clonedPath.o[index] = currentO;
		                  clonedPath.i[index] = currentI; */
		          index += 1;
		        } else {
		          if (i === 0) {
		            closerV = path.v[len - 1];
		          } else {
		            closerV = path.v[i - 1];
		          }
		          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
		          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
		          iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
		          vX = iX;
		          iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
		          vY = iY;
		          oX = vX - (vX - currentV[0]) * roundCorner;
		          oY = vY - (vY - currentV[1]) * roundCorner;
		          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
		          index += 1;
		          if (i === len - 1) {
		            closerV = path.v[0];
		          } else {
		            closerV = path.v[i + 1];
		          }
		          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
		          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
		          oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
		          vX = oX;
		          oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
		          vY = oY;
		          iX = vX - (vX - currentV[0]) * roundCorner;
		          iY = vY - (vY - currentV[1]) * roundCorner;
		          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
		          index += 1;
		        }
		      } else {
		        clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
		        index += 1;
		      }
		    }
		    return clonedPath;
		  };
		  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
		    var shapePaths;
		    var i;
		    var len = this.shapes.length;
		    var j;
		    var jLen;
		    var rd = this.rd.v;
		    if (rd !== 0) {
		      var shapeData;
		      var localShapeCollection;
		      for (i = 0; i < len; i += 1) {
		        shapeData = this.shapes[i];
		        localShapeCollection = shapeData.localShapeCollection;
		        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
		          localShapeCollection.releaseShapes();
		          shapeData.shape._mdf = true;
		          shapePaths = shapeData.shape.paths.shapes;
		          jLen = shapeData.shape.paths._length;
		          for (j = 0; j < jLen; j += 1) {
		            localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
		          }
		        }
		        shapeData.shape.paths = shapeData.localShapeCollection;
		      }
		    }
		    if (!this.dynamicProperties.length) {
		      this._mdf = false;
		    }
		  };

		  function floatEqual(a, b) {
		    return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));
		  }
		  function floatZero(f) {
		    return Math.abs(f) <= 0.00001;
		  }
		  function lerp(p0, p1, amount) {
		    return p0 * (1 - amount) + p1 * amount;
		  }
		  function lerpPoint(p0, p1, amount) {
		    return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
		  }
		  function quadRoots(a, b, c) {
		    // no root
		    if (a === 0) return [];
		    var s = b * b - 4 * a * c;
		    // Complex roots
		    if (s < 0) return [];
		    var singleRoot = -b / (2 * a);
		    // 1 root
		    if (s === 0) return [singleRoot];
		    var delta = Math.sqrt(s) / (2 * a);
		    // 2 roots
		    return [singleRoot - delta, singleRoot + delta];
		  }
		  function polynomialCoefficients(p0, p1, p2, p3) {
		    return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
		  }
		  function singlePoint(p) {
		    return new PolynomialBezier(p, p, p, p, false);
		  }
		  function PolynomialBezier(p0, p1, p2, p3, linearize) {
		    if (linearize && pointEqual(p0, p1)) {
		      p1 = lerpPoint(p0, p3, 1 / 3);
		    }
		    if (linearize && pointEqual(p2, p3)) {
		      p2 = lerpPoint(p0, p3, 2 / 3);
		    }
		    var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
		    var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
		    this.a = [coeffx[0], coeffy[0]];
		    this.b = [coeffx[1], coeffy[1]];
		    this.c = [coeffx[2], coeffy[2]];
		    this.d = [coeffx[3], coeffy[3]];
		    this.points = [p0, p1, p2, p3];
		  }
		  PolynomialBezier.prototype.point = function (t) {
		    return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
		  };
		  PolynomialBezier.prototype.derivative = function (t) {
		    return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
		  };
		  PolynomialBezier.prototype.tangentAngle = function (t) {
		    var p = this.derivative(t);
		    return Math.atan2(p[1], p[0]);
		  };
		  PolynomialBezier.prototype.normalAngle = function (t) {
		    var p = this.derivative(t);
		    return Math.atan2(p[0], p[1]);
		  };
		  PolynomialBezier.prototype.inflectionPoints = function () {
		    var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
		    if (floatZero(denom)) return [];
		    var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
		    var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
		    if (square < 0) return [];
		    var root = Math.sqrt(square);
		    if (floatZero(root)) {
		      if (root > 0 && root < 1) return [tcusp];
		      return [];
		    }
		    return [tcusp - root, tcusp + root].filter(function (r) {
		      return r > 0 && r < 1;
		    });
		  };
		  PolynomialBezier.prototype.split = function (t) {
		    if (t <= 0) return [singlePoint(this.points[0]), this];
		    if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
		    var p10 = lerpPoint(this.points[0], this.points[1], t);
		    var p11 = lerpPoint(this.points[1], this.points[2], t);
		    var p12 = lerpPoint(this.points[2], this.points[3], t);
		    var p20 = lerpPoint(p10, p11, t);
		    var p21 = lerpPoint(p11, p12, t);
		    var p3 = lerpPoint(p20, p21, t);
		    return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
		  };
		  function extrema(bez, comp) {
		    var min = bez.points[0][comp];
		    var max = bez.points[bez.points.length - 1][comp];
		    if (min > max) {
		      var e = max;
		      max = min;
		      min = e;
		    }
		    // Derivative roots to find min/max
		    var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);
		    for (var i = 0; i < f.length; i += 1) {
		      if (f[i] > 0 && f[i] < 1) {
		        var val = bez.point(f[i])[comp];
		        if (val < min) min = val;else if (val > max) max = val;
		      }
		    }
		    return {
		      min: min,
		      max: max
		    };
		  }
		  PolynomialBezier.prototype.bounds = function () {
		    return {
		      x: extrema(this, 0),
		      y: extrema(this, 1)
		    };
		  };
		  PolynomialBezier.prototype.boundingBox = function () {
		    var bounds = this.bounds();
		    return {
		      left: bounds.x.min,
		      right: bounds.x.max,
		      top: bounds.y.min,
		      bottom: bounds.y.max,
		      width: bounds.x.max - bounds.x.min,
		      height: bounds.y.max - bounds.y.min,
		      cx: (bounds.x.max + bounds.x.min) / 2,
		      cy: (bounds.y.max + bounds.y.min) / 2
		    };
		  };
		  function intersectData(bez, t1, t2) {
		    var box = bez.boundingBox();
		    return {
		      cx: box.cx,
		      cy: box.cy,
		      width: box.width,
		      height: box.height,
		      bez: bez,
		      t: (t1 + t2) / 2,
		      t1: t1,
		      t2: t2
		    };
		  }
		  function splitData(data) {
		    var split = data.bez.split(0.5);
		    return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];
		  }
		  function boxIntersect(b1, b2) {
		    return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
		  }
		  function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
		    if (!boxIntersect(d1, d2)) return;
		    if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
		      intersections.push([d1.t, d2.t]);
		      return;
		    }
		    var d1s = splitData(d1);
		    var d2s = splitData(d2);
		    intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
		    intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
		    intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
		    intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
		  }
		  PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {
		    if (tolerance === undefined) tolerance = 2;
		    if (maxRecursion === undefined) maxRecursion = 7;
		    var intersections = [];
		    intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
		    return intersections;
		  };
		  PolynomialBezier.shapeSegment = function (shapePath, index) {
		    var nextIndex = (index + 1) % shapePath.length();
		    return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
		  };
		  PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {
		    var nextIndex = (index + 1) % shapePath.length();
		    return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);
		  };
		  function crossProduct(a, b) {
		    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
		  }
		  function lineIntersection(start1, end1, start2, end2) {
		    var v1 = [start1[0], start1[1], 1];
		    var v2 = [end1[0], end1[1], 1];
		    var v3 = [start2[0], start2[1], 1];
		    var v4 = [end2[0], end2[1], 1];
		    var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
		    if (floatZero(r[2])) return null;
		    return [r[0] / r[2], r[1] / r[2]];
		  }
		  function polarOffset(p, angle, length) {
		    return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];
		  }
		  function pointDistance(p1, p2) {
		    return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
		  }
		  function pointEqual(p1, p2) {
		    return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
		  }

		  function ZigZagModifier() {}
		  extendPrototype([ShapeModifier], ZigZagModifier);
		  ZigZagModifier.prototype.initModifierProperties = function (elem, data) {
		    this.getValue = this.processKeys;
		    this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);
		    this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);
		    this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);
		    this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
		  };
		  function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
		    var angO = angle - Math.PI / 2;
		    var angI = angle + Math.PI / 2;
		    var px = point[0] + Math.cos(angle) * direction * amplitude;
		    var py = point[1] - Math.sin(angle) * direction * amplitude;
		    outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
		  }
		  function getPerpendicularVector(pt1, pt2) {
		    var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
		    var rot = -Math.PI * 0.5;
		    var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
		    return rotatedVector;
		  }
		  function getProjectingAngle(path, cur) {
		    var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
		    var nextIndex = (cur + 1) % path.length();
		    var prevPoint = path.v[prevIndex];
		    var nextPoint = path.v[nextIndex];
		    var pVector = getPerpendicularVector(prevPoint, nextPoint);
		    return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
		  }
		  function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
		    var angle = getProjectingAngle(path, cur);
		    var point = path.v[cur % path._length];
		    var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
		    var nextPoint = path.v[(cur + 1) % path._length];
		    var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
		    var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
		    setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
		  }
		  function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
		    for (var i = 0; i < frequency; i += 1) {
		      var t = (i + 1) / (frequency + 1);
		      var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
		      var angle = segment.normalAngle(t);
		      var point = segment.point(t);
		      setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
		      direction = -direction;
		    }
		    return direction;
		  }
		  ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {
		    var count = path._length;
		    var clonedPath = shapePool.newElement();
		    clonedPath.c = path.c;
		    if (!path.c) {
		      count -= 1;
		    }
		    if (count === 0) return clonedPath;
		    var direction = -1;
		    var segment = PolynomialBezier.shapeSegment(path, 0);
		    zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
		    for (var i = 0; i < count; i += 1) {
		      direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
		      if (i === count - 1 && !path.c) {
		        segment = null;
		      } else {
		        segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
		      }
		      zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
		    }
		    return clonedPath;
		  };
		  ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {
		    var shapePaths;
		    var i;
		    var len = this.shapes.length;
		    var j;
		    var jLen;
		    var amplitude = this.amplitude.v;
		    var frequency = Math.max(0, Math.round(this.frequency.v));
		    var pointType = this.pointsType.v;
		    if (amplitude !== 0) {
		      var shapeData;
		      var localShapeCollection;
		      for (i = 0; i < len; i += 1) {
		        shapeData = this.shapes[i];
		        localShapeCollection = shapeData.localShapeCollection;
		        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
		          localShapeCollection.releaseShapes();
		          shapeData.shape._mdf = true;
		          shapePaths = shapeData.shape.paths.shapes;
		          jLen = shapeData.shape.paths._length;
		          for (j = 0; j < jLen; j += 1) {
		            localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
		          }
		        }
		        shapeData.shape.paths = shapeData.localShapeCollection;
		      }
		    }
		    if (!this.dynamicProperties.length) {
		      this._mdf = false;
		    }
		  };

		  function linearOffset(p1, p2, amount) {
		    var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
		    return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
		  }
		  function offsetSegment(segment, amount) {
		    var p0;
		    var p1a;
		    var p1b;
		    var p2b;
		    var p2a;
		    var p3;
		    var e;
		    e = linearOffset(segment.points[0], segment.points[1], amount);
		    p0 = e[0];
		    p1a = e[1];
		    e = linearOffset(segment.points[1], segment.points[2], amount);
		    p1b = e[0];
		    p2b = e[1];
		    e = linearOffset(segment.points[2], segment.points[3], amount);
		    p2a = e[0];
		    p3 = e[1];
		    var p1 = lineIntersection(p0, p1a, p1b, p2b);
		    if (p1 === null) p1 = p1a;
		    var p2 = lineIntersection(p2a, p3, p1b, p2b);
		    if (p2 === null) p2 = p2a;
		    return new PolynomialBezier(p0, p1, p2, p3);
		  }
		  function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
		    var p0 = seg1.points[3];
		    var p1 = seg2.points[0];

		    // Bevel
		    if (lineJoin === 3) return p0;

		    // Connected, they don't need a joint
		    if (pointEqual(p0, p1)) return p0;

		    // Round
		    if (lineJoin === 2) {
		      var angleOut = -seg1.tangentAngle(1);
		      var angleIn = -seg2.tangentAngle(0) + Math.PI;
		      var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
		      var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
		      var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
		      outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);
		      tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
		      outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
		      return p1;
		    }

		    // Miter
		    var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
		    var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
		    var intersection = lineIntersection(t0, p0, p1, t1);
		    if (intersection && pointDistance(intersection, p0) < miterLimit) {
		      outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
		      return intersection;
		    }
		    return p0;
		  }
		  function getIntersection(a, b) {
		    var intersect = a.intersections(b);
		    if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
		    if (intersect.length) return intersect[0];
		    return null;
		  }
		  function pruneSegmentIntersection(a, b) {
		    var outa = a.slice();
		    var outb = b.slice();
		    var intersect = getIntersection(a[a.length - 1], b[0]);
		    if (intersect) {
		      outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
		      outb[0] = b[0].split(intersect[1])[1];
		    }
		    if (a.length > 1 && b.length > 1) {
		      intersect = getIntersection(a[0], b[b.length - 1]);
		      if (intersect) {
		        return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
		      }
		    }
		    return [outa, outb];
		  }
		  function pruneIntersections(segments) {
		    var e;
		    for (var i = 1; i < segments.length; i += 1) {
		      e = pruneSegmentIntersection(segments[i - 1], segments[i]);
		      segments[i - 1] = e[0];
		      segments[i] = e[1];
		    }
		    if (segments.length > 1) {
		      e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
		      segments[segments.length - 1] = e[0];
		      segments[0] = e[1];
		    }
		    return segments;
		  }
		  function offsetSegmentSplit(segment, amount) {
		    /*
		      We split each bezier segment into smaller pieces based
		      on inflection points, this ensures the control point
		      polygon is convex.
		       (A cubic bezier can have none, one, or two inflection points)
		    */
		    var flex = segment.inflectionPoints();
		    var left;
		    var right;
		    var split;
		    var mid;
		    if (flex.length === 0) {
		      return [offsetSegment(segment, amount)];
		    }
		    if (flex.length === 1 || floatEqual(flex[1], 1)) {
		      split = segment.split(flex[0]);
		      left = split[0];
		      right = split[1];
		      return [offsetSegment(left, amount), offsetSegment(right, amount)];
		    }
		    split = segment.split(flex[0]);
		    left = split[0];
		    var t = (flex[1] - flex[0]) / (1 - flex[0]);
		    split = split[1].split(t);
		    mid = split[0];
		    right = split[1];
		    return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
		  }
		  function OffsetPathModifier() {}
		  extendPrototype([ShapeModifier], OffsetPathModifier);
		  OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {
		    this.getValue = this.processKeys;
		    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
		    this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);
		    this.lineJoin = data.lj;
		    this._isAnimated = this.amount.effectsSequence.length !== 0;
		  };
		  OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {
		    var outputBezier = shapePool.newElement();
		    outputBezier.c = inputBezier.c;
		    var count = inputBezier.length();
		    if (!inputBezier.c) {
		      count -= 1;
		    }
		    var i;
		    var j;
		    var segment;
		    var multiSegments = [];
		    for (i = 0; i < count; i += 1) {
		      segment = PolynomialBezier.shapeSegment(inputBezier, i);
		      multiSegments.push(offsetSegmentSplit(segment, amount));
		    }
		    if (!inputBezier.c) {
		      for (i = count - 1; i >= 0; i -= 1) {
		        segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
		        multiSegments.push(offsetSegmentSplit(segment, amount));
		      }
		    }
		    multiSegments = pruneIntersections(multiSegments);

		    // Add bezier segments to the output and apply line joints
		    var lastPoint = null;
		    var lastSeg = null;
		    for (i = 0; i < multiSegments.length; i += 1) {
		      var multiSegment = multiSegments[i];
		      if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
		      lastSeg = multiSegment[multiSegment.length - 1];
		      for (j = 0; j < multiSegment.length; j += 1) {
		        segment = multiSegment[j];
		        if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
		          outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);
		        } else {
		          outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
		        }
		        outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
		        lastPoint = segment.points[3];
		      }
		    }
		    if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
		    return outputBezier;
		  };
		  OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {
		    var shapePaths;
		    var i;
		    var len = this.shapes.length;
		    var j;
		    var jLen;
		    var amount = this.amount.v;
		    var miterLimit = this.miterLimit.v;
		    var lineJoin = this.lineJoin;
		    if (amount !== 0) {
		      var shapeData;
		      var localShapeCollection;
		      for (i = 0; i < len; i += 1) {
		        shapeData = this.shapes[i];
		        localShapeCollection = shapeData.localShapeCollection;
		        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
		          localShapeCollection.releaseShapes();
		          shapeData.shape._mdf = true;
		          shapePaths = shapeData.shape.paths.shapes;
		          jLen = shapeData.shape.paths._length;
		          for (j = 0; j < jLen; j += 1) {
		            localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
		          }
		        }
		        shapeData.shape.paths = shapeData.localShapeCollection;
		      }
		    }
		    if (!this.dynamicProperties.length) {
		      this._mdf = false;
		    }
		  };

		  function getFontProperties(fontData) {
		    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
		    var fWeight = 'normal';
		    var fStyle = 'normal';
		    var len = styles.length;
		    var styleName;
		    for (var i = 0; i < len; i += 1) {
		      styleName = styles[i].toLowerCase();
		      switch (styleName) {
		        case 'italic':
		          fStyle = 'italic';
		          break;
		        case 'bold':
		          fWeight = '700';
		          break;
		        case 'black':
		          fWeight = '900';
		          break;
		        case 'medium':
		          fWeight = '500';
		          break;
		        case 'regular':
		        case 'normal':
		          fWeight = '400';
		          break;
		        case 'light':
		        case 'thin':
		          fWeight = '200';
		          break;
		      }
		    }
		    return {
		      style: fStyle,
		      weight: fontData.fWeight || fWeight
		    };
		  }

		  var FontManager = function () {
		    var maxWaitingTime = 5000;
		    var emptyChar = {
		      w: 0,
		      size: 0,
		      shapes: [],
		      data: {
		        shapes: []
		      }
		    };
		    var combinedCharacters = [];
		    // Hindi characters
		    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
		    var BLACK_FLAG_CODE_POINT = 127988;
		    var CANCEL_TAG_CODE_POINT = 917631;
		    var A_TAG_CODE_POINT = 917601;
		    var Z_TAG_CODE_POINT = 917626;
		    var VARIATION_SELECTOR_16_CODE_POINT = 65039;
		    var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
		    var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
		    var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
		    var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];
		    function trimFontOptions(font) {
		      var familyArray = font.split(',');
		      var i;
		      var len = familyArray.length;
		      var enabledFamilies = [];
		      for (i = 0; i < len; i += 1) {
		        if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
		          enabledFamilies.push(familyArray[i]);
		        }
		      }
		      return enabledFamilies.join(',');
		    }
		    function setUpNode(font, family) {
		      var parentNode = createTag('span');
		      // Node is invisible to screen readers.
		      parentNode.setAttribute('aria-hidden', true);
		      parentNode.style.fontFamily = family;
		      var node = createTag('span');
		      // Characters that vary significantly among different fonts
		      node.innerText = 'giItT1WQy@!-/#';
		      // Visible - so we can measure it - but not on the screen
		      parentNode.style.position = 'absolute';
		      parentNode.style.left = '-10000px';
		      parentNode.style.top = '-10000px';
		      // Large font size makes even subtle changes obvious
		      parentNode.style.fontSize = '300px';
		      // Reset any font properties
		      parentNode.style.fontVariant = 'normal';
		      parentNode.style.fontStyle = 'normal';
		      parentNode.style.fontWeight = 'normal';
		      parentNode.style.letterSpacing = '0';
		      parentNode.appendChild(node);
		      document.body.appendChild(parentNode);

		      // Remember width with no applied web font
		      var width = node.offsetWidth;
		      node.style.fontFamily = trimFontOptions(font) + ', ' + family;
		      return {
		        node: node,
		        w: width,
		        parent: parentNode
		      };
		    }
		    function checkLoadedFonts() {
		      var i;
		      var len = this.fonts.length;
		      var node;
		      var w;
		      var loadedCount = len;
		      for (i = 0; i < len; i += 1) {
		        if (this.fonts[i].loaded) {
		          loadedCount -= 1;
		        } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
		          this.fonts[i].loaded = true;
		        } else {
		          node = this.fonts[i].monoCase.node;
		          w = this.fonts[i].monoCase.w;
		          if (node.offsetWidth !== w) {
		            loadedCount -= 1;
		            this.fonts[i].loaded = true;
		          } else {
		            node = this.fonts[i].sansCase.node;
		            w = this.fonts[i].sansCase.w;
		            if (node.offsetWidth !== w) {
		              loadedCount -= 1;
		              this.fonts[i].loaded = true;
		            }
		          }
		          if (this.fonts[i].loaded) {
		            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
		            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
		          }
		        }
		      }
		      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
		        setTimeout(this.checkLoadedFontsBinded, 20);
		      } else {
		        setTimeout(this.setIsLoadedBinded, 10);
		      }
		    }
		    function createHelper(fontData, def) {
		      var engine = document.body && def ? 'svg' : 'canvas';
		      var helper;
		      var fontProps = getFontProperties(fontData);
		      if (engine === 'svg') {
		        var tHelper = createNS('text');
		        tHelper.style.fontSize = '100px';
		        // tHelper.style.fontFamily = fontData.fFamily;
		        tHelper.setAttribute('font-family', fontData.fFamily);
		        tHelper.setAttribute('font-style', fontProps.style);
		        tHelper.setAttribute('font-weight', fontProps.weight);
		        tHelper.textContent = '1';
		        if (fontData.fClass) {
		          tHelper.style.fontFamily = 'inherit';
		          tHelper.setAttribute('class', fontData.fClass);
		        } else {
		          tHelper.style.fontFamily = fontData.fFamily;
		        }
		        def.appendChild(tHelper);
		        helper = tHelper;
		      } else {
		        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');
		        tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;
		        helper = tCanvasHelper;
		      }
		      function measure(text) {
		        if (engine === 'svg') {
		          helper.textContent = text;
		          return helper.getComputedTextLength();
		        }
		        return helper.measureText(text).width;
		      }
		      return {
		        measureText: measure
		      };
		    }
		    function addFonts(fontData, defs) {
		      if (!fontData) {
		        this.isLoaded = true;
		        return;
		      }
		      if (this.chars) {
		        this.isLoaded = true;
		        this.fonts = fontData.list;
		        return;
		      }
		      if (!document.body) {
		        this.isLoaded = true;
		        fontData.list.forEach(function (data) {
		          data.helper = createHelper(data);
		          data.cache = {};
		        });
		        this.fonts = fontData.list;
		        return;
		      }
		      var fontArr = fontData.list;
		      var i;
		      var len = fontArr.length;
		      var _pendingFonts = len;
		      for (i = 0; i < len; i += 1) {
		        var shouldLoadFont = true;
		        var loadedSelector;
		        var j;
		        fontArr[i].loaded = false;
		        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
		        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
		        if (!fontArr[i].fPath) {
		          fontArr[i].loaded = true;
		          _pendingFonts -= 1;
		        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
		          loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
		          if (loadedSelector.length > 0) {
		            shouldLoadFont = false;
		          }
		          if (shouldLoadFont) {
		            var s = createTag('style');
		            s.setAttribute('f-forigin', fontArr[i].fOrigin);
		            s.setAttribute('f-origin', fontArr[i].origin);
		            s.setAttribute('f-family', fontArr[i].fFamily);
		            s.type = 'text/css';
		            s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
		            defs.appendChild(s);
		          }
		        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
		          loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
		          for (j = 0; j < loadedSelector.length; j += 1) {
		            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
		              // Font is already loaded
		              shouldLoadFont = false;
		            }
		          }
		          if (shouldLoadFont) {
		            var l = createTag('link');
		            l.setAttribute('f-forigin', fontArr[i].fOrigin);
		            l.setAttribute('f-origin', fontArr[i].origin);
		            l.type = 'text/css';
		            l.rel = 'stylesheet';
		            l.href = fontArr[i].fPath;
		            document.body.appendChild(l);
		          }
		        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
		          loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
		          for (j = 0; j < loadedSelector.length; j += 1) {
		            if (fontArr[i].fPath === loadedSelector[j].src) {
		              // Font is already loaded
		              shouldLoadFont = false;
		            }
		          }
		          if (shouldLoadFont) {
		            var sc = createTag('link');
		            sc.setAttribute('f-forigin', fontArr[i].fOrigin);
		            sc.setAttribute('f-origin', fontArr[i].origin);
		            sc.setAttribute('rel', 'stylesheet');
		            sc.setAttribute('href', fontArr[i].fPath);
		            defs.appendChild(sc);
		          }
		        }
		        fontArr[i].helper = createHelper(fontArr[i], defs);
		        fontArr[i].cache = {};
		        this.fonts.push(fontArr[i]);
		      }
		      if (_pendingFonts === 0) {
		        this.isLoaded = true;
		      } else {
		        // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
		        // Adding this timeout seems to fix it
		        setTimeout(this.checkLoadedFonts.bind(this), 100);
		      }
		    }
		    function addChars(chars) {
		      if (!chars) {
		        return;
		      }
		      if (!this.chars) {
		        this.chars = [];
		      }
		      var i;
		      var len = chars.length;
		      var j;
		      var jLen = this.chars.length;
		      var found;
		      for (i = 0; i < len; i += 1) {
		        j = 0;
		        found = false;
		        while (j < jLen) {
		          if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
		            found = true;
		          }
		          j += 1;
		        }
		        if (!found) {
		          this.chars.push(chars[i]);
		          jLen += 1;
		        }
		      }
		    }
		    function getCharData(_char, style, font) {
		      var i = 0;
		      var len = this.chars.length;
		      while (i < len) {
		        if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
		          return this.chars[i];
		        }
		        i += 1;
		      }
		      if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
		      && !this._warned) {
		        this._warned = true;
		        console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console
		      }
		      return emptyChar;
		    }
		    function measureText(_char2, fontName, size) {
		      var fontData = this.getFontByName(fontName);
		      // Using the char instead of char.charCodeAt(0)
		      // to avoid collisions between equal chars
		      var index = _char2;
		      if (!fontData.cache[index]) {
		        var tHelper = fontData.helper;
		        if (_char2 === ' ') {
		          var doubleSize = tHelper.measureText('|' + _char2 + '|');
		          var singleSize = tHelper.measureText('||');
		          fontData.cache[index] = (doubleSize - singleSize) / 100;
		        } else {
		          fontData.cache[index] = tHelper.measureText(_char2) / 100;
		        }
		      }
		      return fontData.cache[index] * size;
		    }
		    function getFontByName(name) {
		      var i = 0;
		      var len = this.fonts.length;
		      while (i < len) {
		        if (this.fonts[i].fName === name) {
		          return this.fonts[i];
		        }
		        i += 1;
		      }
		      return this.fonts[0];
		    }
		    function getCodePoint(string) {
		      var codePoint = 0;
		      var first = string.charCodeAt(0);
		      if (first >= 0xD800 && first <= 0xDBFF) {
		        var second = string.charCodeAt(1);
		        if (second >= 0xDC00 && second <= 0xDFFF) {
		          codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
		        }
		      }
		      return codePoint;
		    }

		    // Skin tone modifiers
		    function isModifier(firstCharCode, secondCharCode) {
		      var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
		      return surrogateModifiers.indexOf(sum) !== -1;
		    }
		    function isZeroWidthJoiner(charCode) {
		      return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
		    }

		    // This codepoint may change the appearance of the preceding character.
		    // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered
		    // as a colorful image as compared to a monochrome text variant.
		    function isVariationSelector(charCode) {
		      return charCode === VARIATION_SELECTOR_16_CODE_POINT;
		    }

		    // The regional indicator symbols are a set of 26 alphabetic Unicode
		    /// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2
		    // two-letter country codes in a way that allows optional special treatment.
		    function isRegionalCode(string) {
		      var codePoint = getCodePoint(string);
		      if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
		        return true;
		      }
		      return false;
		    }

		    // Some Emoji implementations represent combinations of
		    // two “regional indicator” letters as a single flag symbol.
		    function isFlagEmoji(string) {
		      return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
		    }
		    function isCombinedCharacter(_char3) {
		      return combinedCharacters.indexOf(_char3) !== -1;
		    }

		    // Regional flags start with a BLACK_FLAG_CODE_POINT
		    // folowed by 5 chars in the TAG range
		    // and end with a CANCEL_TAG_CODE_POINT
		    function isRegionalFlag(text, index) {
		      var codePoint = getCodePoint(text.substr(index, 2));
		      if (codePoint !== BLACK_FLAG_CODE_POINT) {
		        return false;
		      }
		      var count = 0;
		      index += 2;
		      while (count < 5) {
		        codePoint = getCodePoint(text.substr(index, 2));
		        if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
		          return false;
		        }
		        count += 1;
		        index += 2;
		      }
		      return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;
		    }
		    function setIsLoaded() {
		      this.isLoaded = true;
		    }
		    var Font = function Font() {
		      this.fonts = [];
		      this.chars = null;
		      this.typekitLoaded = 0;
		      this.isLoaded = false;
		      this._warned = false;
		      this.initTime = Date.now();
		      this.setIsLoadedBinded = this.setIsLoaded.bind(this);
		      this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
		    };
		    Font.isModifier = isModifier;
		    Font.isZeroWidthJoiner = isZeroWidthJoiner;
		    Font.isFlagEmoji = isFlagEmoji;
		    Font.isRegionalCode = isRegionalCode;
		    Font.isCombinedCharacter = isCombinedCharacter;
		    Font.isRegionalFlag = isRegionalFlag;
		    Font.isVariationSelector = isVariationSelector;
		    Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
		    var fontPrototype = {
		      addChars: addChars,
		      addFonts: addFonts,
		      getCharData: getCharData,
		      getFontByName: getFontByName,
		      measureText: measureText,
		      checkLoadedFonts: checkLoadedFonts,
		      setIsLoaded: setIsLoaded
		    };
		    Font.prototype = fontPrototype;
		    return Font;
		  }();

		  function SlotManager(animationData) {
		    this.animationData = animationData;
		  }
		  SlotManager.prototype.getProp = function (data) {
		    if (this.animationData.slots && this.animationData.slots[data.sid]) {
		      return Object.assign(data, this.animationData.slots[data.sid].p);
		    }
		    return data;
		  };
		  function slotFactory(animationData) {
		    return new SlotManager(animationData);
		  }

		  function RenderableElement() {}
		  RenderableElement.prototype = {
		    initRenderable: function initRenderable() {
		      // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
		      this.isInRange = false;
		      // layer's display state
		      this.hidden = false;
		      // If layer's transparency equals 0, it can be hidden
		      this.isTransparent = false;
		      // list of animated components
		      this.renderableComponents = [];
		    },
		    addRenderableComponent: function addRenderableComponent(component) {
		      if (this.renderableComponents.indexOf(component) === -1) {
		        this.renderableComponents.push(component);
		      }
		    },
		    removeRenderableComponent: function removeRenderableComponent(component) {
		      if (this.renderableComponents.indexOf(component) !== -1) {
		        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
		      }
		    },
		    prepareRenderableFrame: function prepareRenderableFrame(num) {
		      this.checkLayerLimits(num);
		    },
		    checkTransparency: function checkTransparency() {
		      if (this.finalTransform.mProp.o.v <= 0) {
		        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
		          this.isTransparent = true;
		          this.hide();
		        }
		      } else if (this.isTransparent) {
		        this.isTransparent = false;
		        this.show();
		      }
		    },
		    /**
		       * @function
		       * Initializes frame related properties.
		       *
		       * @param {number} num
		       * current frame number in Layer's time
		       *
		       */
		    checkLayerLimits: function checkLayerLimits(num) {
		      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
		        if (this.isInRange !== true) {
		          this.globalData._mdf = true;
		          this._mdf = true;
		          this.isInRange = true;
		          this.show();
		        }
		      } else if (this.isInRange !== false) {
		        this.globalData._mdf = true;
		        this.isInRange = false;
		        this.hide();
		      }
		    },
		    renderRenderable: function renderRenderable() {
		      var i;
		      var len = this.renderableComponents.length;
		      for (i = 0; i < len; i += 1) {
		        this.renderableComponents[i].renderFrame(this._isFirstFrame);
		      }
		      /* this.maskManager.renderFrame(this.finalTransform.mat);
		          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
		    },
		    sourceRectAtTime: function sourceRectAtTime() {
		      return {
		        top: 0,
		        left: 0,
		        width: 100,
		        height: 100
		      };
		    },
		    getLayerSize: function getLayerSize() {
		      if (this.data.ty === 5) {
		        return {
		          w: this.data.textData.width,
		          h: this.data.textData.height
		        };
		      }
		      return {
		        w: this.data.width,
		        h: this.data.height
		      };
		    }
		  };

		  var getBlendMode = function () {
		    var blendModeEnums = {
		      0: 'source-over',
		      1: 'multiply',
		      2: 'screen',
		      3: 'overlay',
		      4: 'darken',
		      5: 'lighten',
		      6: 'color-dodge',
		      7: 'color-burn',
		      8: 'hard-light',
		      9: 'soft-light',
		      10: 'difference',
		      11: 'exclusion',
		      12: 'hue',
		      13: 'saturation',
		      14: 'color',
		      15: 'luminosity'
		    };
		    return function (mode) {
		      return blendModeEnums[mode] || '';
		    };
		  }();

		  function SliderEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
		  }
		  function AngleEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
		  }
		  function ColorEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
		  }
		  function PointEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
		  }
		  function LayerIndexEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
		  }
		  function MaskIndexEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
		  }
		  function CheckboxEffect(data, elem, container) {
		    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
		  }
		  function NoValueEffect() {
		    this.p = {};
		  }

		  function EffectsManager(data, element) {
		    var effects = data.ef || [];
		    this.effectElements = [];
		    var i;
		    var len = effects.length;
		    var effectItem;
		    for (i = 0; i < len; i += 1) {
		      effectItem = new GroupEffect(effects[i], element);
		      this.effectElements.push(effectItem);
		    }
		  }
		  function GroupEffect(data, element) {
		    this.init(data, element);
		  }
		  extendPrototype([DynamicPropertyContainer], GroupEffect);
		  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
		  GroupEffect.prototype.init = function (data, element) {
		    this.data = data;
		    this.effectElements = [];
		    this.initDynamicPropertyContainer(element);
		    var i;
		    var len = this.data.ef.length;
		    var eff;
		    var effects = this.data.ef;
		    for (i = 0; i < len; i += 1) {
		      eff = null;
		      switch (effects[i].ty) {
		        case 0:
		          eff = new SliderEffect(effects[i], element, this);
		          break;
		        case 1:
		          eff = new AngleEffect(effects[i], element, this);
		          break;
		        case 2:
		          eff = new ColorEffect(effects[i], element, this);
		          break;
		        case 3:
		          eff = new PointEffect(effects[i], element, this);
		          break;
		        case 4:
		        case 7:
		          eff = new CheckboxEffect(effects[i], element, this);
		          break;
		        case 10:
		          eff = new LayerIndexEffect(effects[i], element, this);
		          break;
		        case 11:
		          eff = new MaskIndexEffect(effects[i], element, this);
		          break;
		        case 5:
		          eff = new EffectsManager(effects[i], element);
		          break;
		        // case 6:
		        default:
		          eff = new NoValueEffect(effects[i]);
		          break;
		      }
		      if (eff) {
		        this.effectElements.push(eff);
		      }
		    }
		  };

		  function BaseElement() {}
		  BaseElement.prototype = {
		    checkMasks: function checkMasks() {
		      if (!this.data.hasMask) {
		        return false;
		      }
		      var i = 0;
		      var len = this.data.masksProperties.length;
		      while (i < len) {
		        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
		          return true;
		        }
		        i += 1;
		      }
		      return false;
		    },
		    initExpressions: function initExpressions() {
		      var expressionsInterfaces = getExpressionInterfaces();
		      if (!expressionsInterfaces) {
		        return;
		      }
		      var LayerExpressionInterface = expressionsInterfaces('layer');
		      var EffectsExpressionInterface = expressionsInterfaces('effects');
		      var ShapeExpressionInterface = expressionsInterfaces('shape');
		      var TextExpressionInterface = expressionsInterfaces('text');
		      var CompExpressionInterface = expressionsInterfaces('comp');
		      this.layerInterface = LayerExpressionInterface(this);
		      if (this.data.hasMask && this.maskManager) {
		        this.layerInterface.registerMaskInterface(this.maskManager);
		      }
		      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
		      this.layerInterface.registerEffectsInterface(effectsInterface);
		      if (this.data.ty === 0 || this.data.xt) {
		        this.compInterface = CompExpressionInterface(this);
		      } else if (this.data.ty === 4) {
		        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
		        this.layerInterface.content = this.layerInterface.shapeInterface;
		      } else if (this.data.ty === 5) {
		        this.layerInterface.textInterface = TextExpressionInterface(this);
		        this.layerInterface.text = this.layerInterface.textInterface;
		      }
		    },
		    setBlendMode: function setBlendMode() {
		      var blendModeValue = getBlendMode(this.data.bm);
		      var elem = this.baseElement || this.layerElement;
		      elem.style['mix-blend-mode'] = blendModeValue;
		    },
		    initBaseData: function initBaseData(data, globalData, comp) {
		      this.globalData = globalData;
		      this.comp = comp;
		      this.data = data;
		      this.layerId = createElementID();

		      // Stretch factor for old animations missing this property.
		      if (!this.data.sr) {
		        this.data.sr = 1;
		      }
		      // effects manager
		      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
		    },
		    getType: function getType() {
		      return this.type;
		    },
		    sourceRectAtTime: function sourceRectAtTime() {}
		  };

		  /**
		   * @file
		   * Handles element's layer frame update.
		   * Checks layer in point and out point
		   *
		   */

		  function FrameElement() {}
		  FrameElement.prototype = {
		    /**
		       * @function
		       * Initializes frame related properties.
		       *
		       */
		    initFrame: function initFrame() {
		      // set to true when inpoint is rendered
		      this._isFirstFrame = false;
		      // list of animated properties
		      this.dynamicProperties = [];
		      // If layer has been modified in current tick this will be true
		      this._mdf = false;
		    },
		    /**
		       * @function
		       * Calculates all dynamic values
		       *
		       * @param {number} num
		       * current frame number in Layer's time
		       * @param {boolean} isVisible
		       * if layers is currently in range
		       *
		       */
		    prepareProperties: function prepareProperties(num, isVisible) {
		      var i;
		      var len = this.dynamicProperties.length;
		      for (i = 0; i < len; i += 1) {
		        if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
		          this.dynamicProperties[i].getValue();
		          if (this.dynamicProperties[i]._mdf) {
		            this.globalData._mdf = true;
		            this._mdf = true;
		          }
		        }
		      }
		    },
		    addDynamicProperty: function addDynamicProperty(prop) {
		      if (this.dynamicProperties.indexOf(prop) === -1) {
		        this.dynamicProperties.push(prop);
		      }
		    }
		  };

		  function FootageElement(data, globalData, comp) {
		    this.initFrame();
		    this.initRenderable();
		    this.assetData = globalData.getAssetData(data.refId);
		    this.footageData = globalData.imageLoader.getAsset(this.assetData);
		    this.initBaseData(data, globalData, comp);
		  }
		  FootageElement.prototype.prepareFrame = function () {};
		  extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
		  FootageElement.prototype.getBaseElement = function () {
		    return null;
		  };
		  FootageElement.prototype.renderFrame = function () {};
		  FootageElement.prototype.destroy = function () {};
		  FootageElement.prototype.initExpressions = function () {
		    var expressionsInterfaces = getExpressionInterfaces();
		    if (!expressionsInterfaces) {
		      return;
		    }
		    var FootageInterface = expressionsInterfaces('footage');
		    this.layerInterface = FootageInterface(this);
		  };
		  FootageElement.prototype.getFootageData = function () {
		    return this.footageData;
		  };

		  function AudioElement(data, globalData, comp) {
		    this.initFrame();
		    this.initRenderable();
		    this.assetData = globalData.getAssetData(data.refId);
		    this.initBaseData(data, globalData, comp);
		    this._isPlaying = false;
		    this._canPlay = false;
		    var assetPath = this.globalData.getAssetsPath(this.assetData);
		    this.audio = this.globalData.audioController.createAudio(assetPath);
		    this._currentTime = 0;
		    this.globalData.audioController.addAudio(this);
		    this._volumeMultiplier = 1;
		    this._volume = 1;
		    this._previousVolume = null;
		    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
		      _placeholder: true
		    };
		    this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
		      k: [100]
		    }, 1, 0.01, this);
		  }
		  AudioElement.prototype.prepareFrame = function (num) {
		    this.prepareRenderableFrame(num, true);
		    this.prepareProperties(num, true);
		    if (!this.tm._placeholder) {
		      var timeRemapped = this.tm.v;
		      this._currentTime = timeRemapped;
		    } else {
		      this._currentTime = num / this.data.sr;
		    }
		    this._volume = this.lv.v[0];
		    var totalVolume = this._volume * this._volumeMultiplier;
		    if (this._previousVolume !== totalVolume) {
		      this._previousVolume = totalVolume;
		      this.audio.volume(totalVolume);
		    }
		  };
		  extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
		  AudioElement.prototype.renderFrame = function () {
		    if (this.isInRange && this._canPlay) {
		      if (!this._isPlaying) {
		        this.audio.play();
		        this.audio.seek(this._currentTime / this.globalData.frameRate);
		        this._isPlaying = true;
		      } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
		        this.audio.seek(this._currentTime / this.globalData.frameRate);
		      }
		    }
		  };
		  AudioElement.prototype.show = function () {
		    // this.audio.play()
		  };
		  AudioElement.prototype.hide = function () {
		    this.audio.pause();
		    this._isPlaying = false;
		  };
		  AudioElement.prototype.pause = function () {
		    this.audio.pause();
		    this._isPlaying = false;
		    this._canPlay = false;
		  };
		  AudioElement.prototype.resume = function () {
		    this._canPlay = true;
		  };
		  AudioElement.prototype.setRate = function (rateValue) {
		    this.audio.rate(rateValue);
		  };
		  AudioElement.prototype.volume = function (volumeValue) {
		    this._volumeMultiplier = volumeValue;
		    this._previousVolume = volumeValue * this._volume;
		    this.audio.volume(this._previousVolume);
		  };
		  AudioElement.prototype.getBaseElement = function () {
		    return null;
		  };
		  AudioElement.prototype.destroy = function () {};
		  AudioElement.prototype.sourceRectAtTime = function () {};
		  AudioElement.prototype.initExpressions = function () {};

		  function BaseRenderer() {}
		  BaseRenderer.prototype.checkLayers = function (num) {
		    var i;
		    var len = this.layers.length;
		    var data;
		    this.completeLayers = true;
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (!this.elements[i]) {
		        data = this.layers[i];
		        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
		          this.buildItem(i);
		        }
		      }
		      this.completeLayers = this.elements[i] ? this.completeLayers : false;
		    }
		    this.checkPendingElements();
		  };
		  BaseRenderer.prototype.createItem = function (layer) {
		    switch (layer.ty) {
		      case 2:
		        return this.createImage(layer);
		      case 0:
		        return this.createComp(layer);
		      case 1:
		        return this.createSolid(layer);
		      case 3:
		        return this.createNull(layer);
		      case 4:
		        return this.createShape(layer);
		      case 5:
		        return this.createText(layer);
		      case 6:
		        return this.createAudio(layer);
		      case 13:
		        return this.createCamera(layer);
		      case 15:
		        return this.createFootage(layer);
		      default:
		        return this.createNull(layer);
		    }
		  };
		  BaseRenderer.prototype.createCamera = function () {
		    throw new Error('You\'re using a 3d camera. Try the html renderer.');
		  };
		  BaseRenderer.prototype.createAudio = function (data) {
		    return new AudioElement(data, this.globalData, this);
		  };
		  BaseRenderer.prototype.createFootage = function (data) {
		    return new FootageElement(data, this.globalData, this);
		  };
		  BaseRenderer.prototype.buildAllItems = function () {
		    var i;
		    var len = this.layers.length;
		    for (i = 0; i < len; i += 1) {
		      this.buildItem(i);
		    }
		    this.checkPendingElements();
		  };
		  BaseRenderer.prototype.includeLayers = function (newLayers) {
		    this.completeLayers = false;
		    var i;
		    var len = newLayers.length;
		    var j;
		    var jLen = this.layers.length;
		    for (i = 0; i < len; i += 1) {
		      j = 0;
		      while (j < jLen) {
		        if (this.layers[j].id === newLayers[i].id) {
		          this.layers[j] = newLayers[i];
		          break;
		        }
		        j += 1;
		      }
		    }
		  };
		  BaseRenderer.prototype.setProjectInterface = function (pInterface) {
		    this.globalData.projectInterface = pInterface;
		  };
		  BaseRenderer.prototype.initItems = function () {
		    if (!this.globalData.progressiveLoad) {
		      this.buildAllItems();
		    }
		  };
		  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
		    var elements = this.elements;
		    var layers = this.layers;
		    var i = 0;
		    var len = layers.length;
		    while (i < len) {
		      if (layers[i].ind == parentName) {
		        // eslint-disable-line eqeqeq
		        if (!elements[i] || elements[i] === true) {
		          this.buildItem(i);
		          this.addPendingElement(element);
		        } else {
		          hierarchy.push(elements[i]);
		          elements[i].setAsParent();
		          if (layers[i].parent !== undefined) {
		            this.buildElementParenting(element, layers[i].parent, hierarchy);
		          } else {
		            element.setHierarchy(hierarchy);
		          }
		        }
		      }
		      i += 1;
		    }
		  };
		  BaseRenderer.prototype.addPendingElement = function (element) {
		    this.pendingElements.push(element);
		  };
		  BaseRenderer.prototype.searchExtraCompositions = function (assets) {
		    var i;
		    var len = assets.length;
		    for (i = 0; i < len; i += 1) {
		      if (assets[i].xt) {
		        var comp = this.createComp(assets[i]);
		        comp.initExpressions();
		        this.globalData.projectInterface.registerComposition(comp);
		      }
		    }
		  };
		  BaseRenderer.prototype.getElementById = function (ind) {
		    var i;
		    var len = this.elements.length;
		    for (i = 0; i < len; i += 1) {
		      if (this.elements[i].data.ind === ind) {
		        return this.elements[i];
		      }
		    }
		    return null;
		  };
		  BaseRenderer.prototype.getElementByPath = function (path) {
		    var pathValue = path.shift();
		    var element;
		    if (typeof pathValue === 'number') {
		      element = this.elements[pathValue];
		    } else {
		      var i;
		      var len = this.elements.length;
		      for (i = 0; i < len; i += 1) {
		        if (this.elements[i].data.nm === pathValue) {
		          element = this.elements[i];
		          break;
		        }
		      }
		    }
		    if (path.length === 0) {
		      return element;
		    }
		    return element.getElementByPath(path);
		  };
		  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
		    this.globalData.fontManager = new FontManager();
		    this.globalData.slotManager = slotFactory(animData);
		    this.globalData.fontManager.addChars(animData.chars);
		    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
		    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
		    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
		    this.globalData.imageLoader = this.animationItem.imagePreloader;
		    this.globalData.audioController = this.animationItem.audioController;
		    this.globalData.frameId = 0;
		    this.globalData.frameRate = animData.fr;
		    this.globalData.nm = animData.nm;
		    this.globalData.compSize = {
		      w: animData.w,
		      h: animData.h
		    };
		  };

		  var effectTypes = {
		    TRANSFORM_EFFECT: 'transformEFfect'
		  };

		  function TransformElement() {}
		  TransformElement.prototype = {
		    initTransform: function initTransform() {
		      var mat = new Matrix();
		      this.finalTransform = {
		        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
		          o: 0
		        },
		        _matMdf: false,
		        _localMatMdf: false,
		        _opMdf: false,
		        mat: mat,
		        localMat: mat,
		        localOpacity: 1
		      };
		      if (this.data.ao) {
		        this.finalTransform.mProp.autoOriented = true;
		      }

		      // TODO: check TYPE 11: Guided elements
		      if (this.data.ty !== 11) ;
		    },
		    renderTransform: function renderTransform() {
		      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
		      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
		      if (this.hierarchy) {
		        var mat;
		        var finalMat = this.finalTransform.mat;
		        var i = 0;
		        var len = this.hierarchy.length;
		        // Checking if any of the transformation matrices in the hierarchy chain has changed.
		        if (!this.finalTransform._matMdf) {
		          while (i < len) {
		            if (this.hierarchy[i].finalTransform.mProp._mdf) {
		              this.finalTransform._matMdf = true;
		              break;
		            }
		            i += 1;
		          }
		        }
		        if (this.finalTransform._matMdf) {
		          mat = this.finalTransform.mProp.v.props;
		          finalMat.cloneFromProps(mat);
		          for (i = 0; i < len; i += 1) {
		            finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
		          }
		        }
		      }
		      if (!this.localTransforms || this.finalTransform._matMdf) {
		        this.finalTransform._localMatMdf = this.finalTransform._matMdf;
		      }
		      if (this.finalTransform._opMdf) {
		        this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
		      }
		    },
		    renderLocalTransform: function renderLocalTransform() {
		      if (this.localTransforms) {
		        var i = 0;
		        var len = this.localTransforms.length;
		        this.finalTransform._localMatMdf = this.finalTransform._matMdf;
		        if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
		          while (i < len) {
		            if (this.localTransforms[i]._mdf) {
		              this.finalTransform._localMatMdf = true;
		            }
		            if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
		              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
		              this.finalTransform._opMdf = true;
		            }
		            i += 1;
		          }
		        }
		        if (this.finalTransform._localMatMdf) {
		          var localMat = this.finalTransform.localMat;
		          this.localTransforms[0].matrix.clone(localMat);
		          for (i = 1; i < len; i += 1) {
		            var lmat = this.localTransforms[i].matrix;
		            localMat.multiply(lmat);
		          }
		          localMat.multiply(this.finalTransform.mat);
		        }
		        if (this.finalTransform._opMdf) {
		          var localOp = this.finalTransform.localOpacity;
		          for (i = 0; i < len; i += 1) {
		            localOp *= this.localTransforms[i].opacity * 0.01;
		          }
		          this.finalTransform.localOpacity = localOp;
		        }
		      }
		    },
		    searchEffectTransforms: function searchEffectTransforms() {
		      if (this.renderableEffectsManager) {
		        var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
		        if (transformEffects.length) {
		          this.localTransforms = [];
		          this.finalTransform.localMat = new Matrix();
		          var i = 0;
		          var len = transformEffects.length;
		          for (i = 0; i < len; i += 1) {
		            this.localTransforms.push(transformEffects[i]);
		          }
		        }
		      }
		    },
		    globalToLocal: function globalToLocal(pt) {
		      var transforms = [];
		      transforms.push(this.finalTransform);
		      var flag = true;
		      var comp = this.comp;
		      while (flag) {
		        if (comp.finalTransform) {
		          if (comp.data.hasMask) {
		            transforms.splice(0, 0, comp.finalTransform);
		          }
		          comp = comp.comp;
		        } else {
		          flag = false;
		        }
		      }
		      var i;
		      var len = transforms.length;
		      var ptNew;
		      for (i = 0; i < len; i += 1) {
		        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
		        // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
		        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
		      }
		      return pt;
		    },
		    mHelper: new Matrix()
		  };

		  function MaskElement(data, element, globalData) {
		    this.data = data;
		    this.element = element;
		    this.globalData = globalData;
		    this.storedData = [];
		    this.masksProperties = this.data.masksProperties || [];
		    this.maskElement = null;
		    var defs = this.globalData.defs;
		    var i;
		    var len = this.masksProperties ? this.masksProperties.length : 0;
		    this.viewData = createSizedArray(len);
		    this.solidPath = '';
		    var path;
		    var properties = this.masksProperties;
		    var count = 0;
		    var currentMasks = [];
		    var j;
		    var jLen;
		    var layerId = createElementID();
		    var rect;
		    var expansor;
		    var feMorph;
		    var x;
		    var maskType = 'clipPath';
		    var maskRef = 'clip-path';
		    for (i = 0; i < len; i += 1) {
		      if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
		        maskType = 'mask';
		        maskRef = 'mask';
		      }
		      if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
		        rect = createNS('rect');
		        rect.setAttribute('fill', '#ffffff');
		        rect.setAttribute('width', this.element.comp.data.w || 0);
		        rect.setAttribute('height', this.element.comp.data.h || 0);
		        currentMasks.push(rect);
		      } else {
		        rect = null;
		      }
		      path = createNS('path');
		      if (properties[i].mode === 'n') {
		        // TODO move this to a factory or to a constructor
		        this.viewData[i] = {
		          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
		          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
		          elem: path,
		          lastPath: ''
		        };
		        defs.appendChild(path);
		      } else {
		        count += 1;
		        path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
		        path.setAttribute('clip-rule', 'nonzero');
		        var filterID;
		        if (properties[i].x.k !== 0) {
		          maskType = 'mask';
		          maskRef = 'mask';
		          x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
		          filterID = createElementID();
		          expansor = createNS('filter');
		          expansor.setAttribute('id', filterID);
		          feMorph = createNS('feMorphology');
		          feMorph.setAttribute('operator', 'erode');
		          feMorph.setAttribute('in', 'SourceGraphic');
		          feMorph.setAttribute('radius', '0');
		          expansor.appendChild(feMorph);
		          defs.appendChild(expansor);
		          path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
		        } else {
		          feMorph = null;
		          x = null;
		        }

		        // TODO move this to a factory or to a constructor
		        this.storedData[i] = {
		          elem: path,
		          x: x,
		          expan: feMorph,
		          lastPath: '',
		          lastOperator: '',
		          filterId: filterID,
		          lastRadius: 0
		        };
		        if (properties[i].mode === 'i') {
		          jLen = currentMasks.length;
		          var g = createNS('g');
		          for (j = 0; j < jLen; j += 1) {
		            g.appendChild(currentMasks[j]);
		          }
		          var mask = createNS('mask');
		          mask.setAttribute('mask-type', 'alpha');
		          mask.setAttribute('id', layerId + '_' + count);
		          mask.appendChild(path);
		          defs.appendChild(mask);
		          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');
		          currentMasks.length = 0;
		          currentMasks.push(g);
		        } else {
		          currentMasks.push(path);
		        }
		        if (properties[i].inv && !this.solidPath) {
		          this.solidPath = this.createLayerSolidPath();
		        }
		        // TODO move this to a factory or to a constructor
		        this.viewData[i] = {
		          elem: path,
		          lastPath: '',
		          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
		          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
		          invRect: rect
		        };
		        if (!this.viewData[i].prop.k) {
		          this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
		        }
		      }
		    }
		    this.maskElement = createNS(maskType);
		    len = currentMasks.length;
		    for (i = 0; i < len; i += 1) {
		      this.maskElement.appendChild(currentMasks[i]);
		    }
		    if (count > 0) {
		      this.maskElement.setAttribute('id', layerId);
		      this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');
		      defs.appendChild(this.maskElement);
		    }
		    if (this.viewData.length) {
		      this.element.addRenderableComponent(this);
		    }
		  }
		  MaskElement.prototype.getMaskProperty = function (pos) {
		    return this.viewData[pos].prop;
		  };
		  MaskElement.prototype.renderFrame = function (isFirstFrame) {
		    var finalMat = this.element.finalTransform.mat;
		    var i;
		    var len = this.masksProperties.length;
		    for (i = 0; i < len; i += 1) {
		      if (this.viewData[i].prop._mdf || isFirstFrame) {
		        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
		      }
		      if (this.viewData[i].op._mdf || isFirstFrame) {
		        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
		      }
		      if (this.masksProperties[i].mode !== 'n') {
		        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
		          this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
		        }
		        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
		          var feMorph = this.storedData[i].expan;
		          if (this.storedData[i].x.v < 0) {
		            if (this.storedData[i].lastOperator !== 'erode') {
		              this.storedData[i].lastOperator = 'erode';
		              this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');
		            }
		            feMorph.setAttribute('radius', -this.storedData[i].x.v);
		          } else {
		            if (this.storedData[i].lastOperator !== 'dilate') {
		              this.storedData[i].lastOperator = 'dilate';
		              this.storedData[i].elem.setAttribute('filter', null);
		            }
		            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
		          }
		        }
		      }
		    }
		  };
		  MaskElement.prototype.getMaskelement = function () {
		    return this.maskElement;
		  };
		  MaskElement.prototype.createLayerSolidPath = function () {
		    var path = 'M0,0 ';
		    path += ' h' + this.globalData.compSize.w;
		    path += ' v' + this.globalData.compSize.h;
		    path += ' h-' + this.globalData.compSize.w;
		    path += ' v-' + this.globalData.compSize.h + ' ';
		    return path;
		  };
		  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
		    var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
		    var i;
		    var len;
		    len = pathNodes._length;
		    for (i = 1; i < len; i += 1) {
		      // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
		      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
		    }
		    // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
		    if (pathNodes.c && len > 1) {
		      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
		    }
		    // pathNodes.__renderedString = pathString;

		    if (viewData.lastPath !== pathString) {
		      var pathShapeValue = '';
		      if (viewData.elem) {
		        if (pathNodes.c) {
		          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
		        }
		        viewData.elem.setAttribute('d', pathShapeValue);
		      }
		      viewData.lastPath = pathString;
		    }
		  };
		  MaskElement.prototype.destroy = function () {
		    this.element = null;
		    this.globalData = null;
		    this.maskElement = null;
		    this.data = null;
		    this.masksProperties = null;
		  };

		  var filtersFactory = function () {
		    var ob = {};
		    ob.createFilter = createFilter;
		    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
		    function createFilter(filId, skipCoordinates) {
		      var fil = createNS('filter');
		      fil.setAttribute('id', filId);
		      if (skipCoordinates !== true) {
		        fil.setAttribute('filterUnits', 'objectBoundingBox');
		        fil.setAttribute('x', '0%');
		        fil.setAttribute('y', '0%');
		        fil.setAttribute('width', '100%');
		        fil.setAttribute('height', '100%');
		      }
		      return fil;
		    }
		    function createAlphaToLuminanceFilter() {
		      var feColorMatrix = createNS('feColorMatrix');
		      feColorMatrix.setAttribute('type', 'matrix');
		      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
		      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
		      return feColorMatrix;
		    }
		    return ob;
		  }();

		  var featureSupport = function () {
		    var ob = {
		      maskType: true,
		      svgLumaHidden: true,
		      offscreenCanvas: typeof OffscreenCanvas !== 'undefined'
		    };
		    if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
		      ob.maskType = false;
		    }
		    if (/firefox/i.test(navigator.userAgent)) {
		      ob.svgLumaHidden = false;
		    }
		    return ob;
		  }();

		  var registeredEffects$1 = {};
		  var idPrefix = 'filter_result_';
		  function SVGEffects(elem) {
		    var i;
		    var source = 'SourceGraphic';
		    var len = elem.data.ef ? elem.data.ef.length : 0;
		    var filId = createElementID();
		    var fil = filtersFactory.createFilter(filId, true);
		    var count = 0;
		    this.filters = [];
		    var filterManager;
		    for (i = 0; i < len; i += 1) {
		      filterManager = null;
		      var type = elem.data.ef[i].ty;
		      if (registeredEffects$1[type]) {
		        var Effect = registeredEffects$1[type].effect;
		        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
		        source = idPrefix + count;
		        if (registeredEffects$1[type].countsAsEffect) {
		          count += 1;
		        }
		      }
		      if (filterManager) {
		        this.filters.push(filterManager);
		      }
		    }
		    if (count) {
		      elem.globalData.defs.appendChild(fil);
		      elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
		    }
		    if (this.filters.length) {
		      elem.addRenderableComponent(this);
		    }
		  }
		  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
		    var i;
		    var len = this.filters.length;
		    for (i = 0; i < len; i += 1) {
		      this.filters[i].renderFrame(_isFirstFrame);
		    }
		  };
		  SVGEffects.prototype.getEffects = function (type) {
		    var i;
		    var len = this.filters.length;
		    var effects = [];
		    for (i = 0; i < len; i += 1) {
		      if (this.filters[i].type === type) {
		        effects.push(this.filters[i]);
		      }
		    }
		    return effects;
		  };
		  function registerEffect$1(id, effect, countsAsEffect) {
		    registeredEffects$1[id] = {
		      effect: effect,
		      countsAsEffect: countsAsEffect
		    };
		  }

		  function SVGBaseElement() {}
		  SVGBaseElement.prototype = {
		    initRendererElement: function initRendererElement() {
		      this.layerElement = createNS('g');
		    },
		    createContainerElements: function createContainerElements() {
		      this.matteElement = createNS('g');
		      this.transformedElement = this.layerElement;
		      this.maskedElement = this.layerElement;
		      this._sizeChanged = false;
		      var layerElementParent = null;
		      // If this layer acts as a mask for the following layer
		      if (this.data.td) {
		        this.matteMasks = {};
		        var gg = createNS('g');
		        gg.setAttribute('id', this.layerId);
		        gg.appendChild(this.layerElement);
		        layerElementParent = gg;
		        this.globalData.defs.appendChild(gg);
		      } else if (this.data.tt) {
		        this.matteElement.appendChild(this.layerElement);
		        layerElementParent = this.matteElement;
		        this.baseElement = this.matteElement;
		      } else {
		        this.baseElement = this.layerElement;
		      }
		      if (this.data.ln) {
		        this.layerElement.setAttribute('id', this.data.ln);
		      }
		      if (this.data.cl) {
		        this.layerElement.setAttribute('class', this.data.cl);
		      }
		      // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
		      if (this.data.ty === 0 && !this.data.hd) {
		        var cp = createNS('clipPath');
		        var pt = createNS('path');
		        pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
		        var clipId = createElementID();
		        cp.setAttribute('id', clipId);
		        cp.appendChild(pt);
		        this.globalData.defs.appendChild(cp);
		        if (this.checkMasks()) {
		          var cpGroup = createNS('g');
		          cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
		          cpGroup.appendChild(this.layerElement);
		          this.transformedElement = cpGroup;
		          if (layerElementParent) {
		            layerElementParent.appendChild(this.transformedElement);
		          } else {
		            this.baseElement = this.transformedElement;
		          }
		        } else {
		          this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
		        }
		      }
		      if (this.data.bm !== 0) {
		        this.setBlendMode();
		      }
		    },
		    renderElement: function renderElement() {
		      if (this.finalTransform._localMatMdf) {
		        this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());
		      }
		      if (this.finalTransform._opMdf) {
		        this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);
		      }
		    },
		    destroyBaseElement: function destroyBaseElement() {
		      this.layerElement = null;
		      this.matteElement = null;
		      this.maskManager.destroy();
		    },
		    getBaseElement: function getBaseElement() {
		      if (this.data.hd) {
		        return null;
		      }
		      return this.baseElement;
		    },
		    createRenderableComponents: function createRenderableComponents() {
		      this.maskManager = new MaskElement(this.data, this, this.globalData);
		      this.renderableEffectsManager = new SVGEffects(this);
		      this.searchEffectTransforms();
		    },
		    getMatte: function getMatte(matteType) {
		      // This should not be a common case. But for backward compatibility, we'll create the matte object.
		      // It solves animations that have two consecutive layers marked as matte masks.
		      // Which is an undefined behavior in AE.
		      if (!this.matteMasks) {
		        this.matteMasks = {};
		      }
		      if (!this.matteMasks[matteType]) {
		        var id = this.layerId + '_' + matteType;
		        var filId;
		        var fil;
		        var useElement;
		        var gg;
		        if (matteType === 1 || matteType === 3) {
		          var masker = createNS('mask');
		          masker.setAttribute('id', id);
		          masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');
		          useElement = createNS('use');
		          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
		          masker.appendChild(useElement);
		          this.globalData.defs.appendChild(masker);
		          if (!featureSupport.maskType && matteType === 1) {
		            masker.setAttribute('mask-type', 'luminance');
		            filId = createElementID();
		            fil = filtersFactory.createFilter(filId);
		            this.globalData.defs.appendChild(fil);
		            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
		            gg = createNS('g');
		            gg.appendChild(useElement);
		            masker.appendChild(gg);
		            gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
		          }
		        } else if (matteType === 2) {
		          var maskGroup = createNS('mask');
		          maskGroup.setAttribute('id', id);
		          maskGroup.setAttribute('mask-type', 'alpha');
		          var maskGrouper = createNS('g');
		          maskGroup.appendChild(maskGrouper);
		          filId = createElementID();
		          fil = filtersFactory.createFilter(filId);
		          /// /
		          var feCTr = createNS('feComponentTransfer');
		          feCTr.setAttribute('in', 'SourceGraphic');
		          fil.appendChild(feCTr);
		          var feFunc = createNS('feFuncA');
		          feFunc.setAttribute('type', 'table');
		          feFunc.setAttribute('tableValues', '1.0 0.0');
		          feCTr.appendChild(feFunc);
		          /// /
		          this.globalData.defs.appendChild(fil);
		          var alphaRect = createNS('rect');
		          alphaRect.setAttribute('width', this.comp.data.w);
		          alphaRect.setAttribute('height', this.comp.data.h);
		          alphaRect.setAttribute('x', '0');
		          alphaRect.setAttribute('y', '0');
		          alphaRect.setAttribute('fill', '#ffffff');
		          alphaRect.setAttribute('opacity', '0');
		          maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
		          maskGrouper.appendChild(alphaRect);
		          useElement = createNS('use');
		          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
		          maskGrouper.appendChild(useElement);
		          if (!featureSupport.maskType) {
		            maskGroup.setAttribute('mask-type', 'luminance');
		            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
		            gg = createNS('g');
		            maskGrouper.appendChild(alphaRect);
		            gg.appendChild(this.layerElement);
		            maskGrouper.appendChild(gg);
		          }
		          this.globalData.defs.appendChild(maskGroup);
		        }
		        this.matteMasks[matteType] = id;
		      }
		      return this.matteMasks[matteType];
		    },
		    setMatte: function setMatte(id) {
		      if (!this.matteElement) {
		        return;
		      }
		      this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
		    }
		  };

		  /**
		   * @file
		   * Handles AE's layer parenting property.
		   *
		   */

		  function HierarchyElement() {}
		  HierarchyElement.prototype = {
		    /**
		       * @function
		       * Initializes hierarchy properties
		       *
		       */
		    initHierarchy: function initHierarchy() {
		      // element's parent list
		      this.hierarchy = [];
		      // if element is parent of another layer _isParent will be true
		      this._isParent = false;
		      this.checkParenting();
		    },
		    /**
		       * @function
		       * Sets layer's hierarchy.
		       * @param {array} hierarch
		       * layer's parent list
		       *
		       */
		    setHierarchy: function setHierarchy(hierarchy) {
		      this.hierarchy = hierarchy;
		    },
		    /**
		       * @function
		       * Sets layer as parent.
		       *
		       */
		    setAsParent: function setAsParent() {
		      this._isParent = true;
		    },
		    /**
		       * @function
		       * Searches layer's parenting chain
		       *
		       */
		    checkParenting: function checkParenting() {
		      if (this.data.parent !== undefined) {
		        this.comp.buildElementParenting(this, this.data.parent, []);
		      }
		    }
		  };

		  function RenderableDOMElement() {}
		  (function () {
		    var _prototype = {
		      initElement: function initElement(data, globalData, comp) {
		        this.initFrame();
		        this.initBaseData(data, globalData, comp);
		        this.initTransform(data, globalData, comp);
		        this.initHierarchy();
		        this.initRenderable();
		        this.initRendererElement();
		        this.createContainerElements();
		        this.createRenderableComponents();
		        this.createContent();
		        this.hide();
		      },
		      hide: function hide() {
		        // console.log('HIDE', this);
		        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
		          var elem = this.baseElement || this.layerElement;
		          elem.style.display = 'none';
		          this.hidden = true;
		        }
		      },
		      show: function show() {
		        // console.log('SHOW', this);
		        if (this.isInRange && !this.isTransparent) {
		          if (!this.data.hd) {
		            var elem = this.baseElement || this.layerElement;
		            elem.style.display = 'block';
		          }
		          this.hidden = false;
		          this._isFirstFrame = true;
		        }
		      },
		      renderFrame: function renderFrame() {
		        // If it is exported as hidden (data.hd === true) no need to render
		        // If it is not visible no need to render
		        if (this.data.hd || this.hidden) {
		          return;
		        }
		        this.renderTransform();
		        this.renderRenderable();
		        this.renderLocalTransform();
		        this.renderElement();
		        this.renderInnerContent();
		        if (this._isFirstFrame) {
		          this._isFirstFrame = false;
		        }
		      },
		      renderInnerContent: function renderInnerContent() {},
		      prepareFrame: function prepareFrame(num) {
		        this._mdf = false;
		        this.prepareRenderableFrame(num);
		        this.prepareProperties(num, this.isInRange);
		        this.checkTransparency();
		      },
		      destroy: function destroy() {
		        this.innerElem = null;
		        this.destroyBaseElement();
		      }
		    };
		    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
		  })();

		  function IImageElement(data, globalData, comp) {
		    this.assetData = globalData.getAssetData(data.refId);
		    if (this.assetData && this.assetData.sid) {
		      this.assetData = globalData.slotManager.getProp(this.assetData);
		    }
		    this.initElement(data, globalData, comp);
		    this.sourceRect = {
		      top: 0,
		      left: 0,
		      width: this.assetData.w,
		      height: this.assetData.h
		    };
		  }
		  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
		  IImageElement.prototype.createContent = function () {
		    var assetPath = this.globalData.getAssetsPath(this.assetData);
		    this.innerElem = createNS('image');
		    this.innerElem.setAttribute('width', this.assetData.w + 'px');
		    this.innerElem.setAttribute('height', this.assetData.h + 'px');
		    this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
		    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
		    this.layerElement.appendChild(this.innerElem);
		  };
		  IImageElement.prototype.sourceRectAtTime = function () {
		    return this.sourceRect;
		  };

		  function ProcessedElement(element, position) {
		    this.elem = element;
		    this.pos = position;
		  }

		  function IShapeElement() {}
		  IShapeElement.prototype = {
		    addShapeToModifiers: function addShapeToModifiers(data) {
		      var i;
		      var len = this.shapeModifiers.length;
		      for (i = 0; i < len; i += 1) {
		        this.shapeModifiers[i].addShape(data);
		      }
		    },
		    isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
		      var i = 0;
		      var len = this.shapeModifiers.length;
		      while (i < len) {
		        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
		          return true;
		        }
		      }
		      return false;
		    },
		    renderModifiers: function renderModifiers() {
		      if (!this.shapeModifiers.length) {
		        return;
		      }
		      var i;
		      var len = this.shapes.length;
		      for (i = 0; i < len; i += 1) {
		        this.shapes[i].sh.reset();
		      }
		      len = this.shapeModifiers.length;
		      var shouldBreakProcess;
		      for (i = len - 1; i >= 0; i -= 1) {
		        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
		        // workaround to fix cases where a repeater resets the shape so the following processes get called twice
		        // TODO: find a better solution for this
		        if (shouldBreakProcess) {
		          break;
		        }
		      }
		    },
		    searchProcessedElement: function searchProcessedElement(elem) {
		      var elements = this.processedElements;
		      var i = 0;
		      var len = elements.length;
		      while (i < len) {
		        if (elements[i].elem === elem) {
		          return elements[i].pos;
		        }
		        i += 1;
		      }
		      return 0;
		    },
		    addProcessedElement: function addProcessedElement(elem, pos) {
		      var elements = this.processedElements;
		      var i = elements.length;
		      while (i) {
		        i -= 1;
		        if (elements[i].elem === elem) {
		          elements[i].pos = pos;
		          return;
		        }
		      }
		      elements.push(new ProcessedElement(elem, pos));
		    },
		    prepareFrame: function prepareFrame(num) {
		      this.prepareRenderableFrame(num);
		      this.prepareProperties(num, this.isInRange);
		    }
		  };

		  var lineCapEnum = {
		    1: 'butt',
		    2: 'round',
		    3: 'square'
		  };
		  var lineJoinEnum = {
		    1: 'miter',
		    2: 'round',
		    3: 'bevel'
		  };

		  function SVGShapeData(transformers, level, shape) {
		    this.caches = [];
		    this.styles = [];
		    this.transformers = transformers;
		    this.lStr = '';
		    this.sh = shape;
		    this.lvl = level;
		    // TODO find if there are some cases where _isAnimated can be false.
		    // For now, since shapes add up with other shapes. They have to be calculated every time.
		    // One way of finding out is checking if all styles associated to this shape depend only of this shape
		    this._isAnimated = !!shape.k;
		    // TODO: commenting this for now since all shapes are animated
		    var i = 0;
		    var len = transformers.length;
		    while (i < len) {
		      if (transformers[i].mProps.dynamicProperties.length) {
		        this._isAnimated = true;
		        break;
		      }
		      i += 1;
		    }
		  }
		  SVGShapeData.prototype.setAsAnimated = function () {
		    this._isAnimated = true;
		  };

		  function SVGStyleData(data, level) {
		    this.data = data;
		    this.type = data.ty;
		    this.d = '';
		    this.lvl = level;
		    this._mdf = false;
		    this.closed = data.hd === true;
		    this.pElem = createNS('path');
		    this.msElem = null;
		  }
		  SVGStyleData.prototype.reset = function () {
		    this.d = '';
		    this._mdf = false;
		  };

		  function DashProperty(elem, data, renderer, container) {
		    this.elem = elem;
		    this.frameId = -1;
		    this.dataProps = createSizedArray(data.length);
		    this.renderer = renderer;
		    this.k = false;
		    this.dashStr = '';
		    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
		    this.dashoffset = createTypedArray('float32', 1);
		    this.initDynamicPropertyContainer(container);
		    var i;
		    var len = data.length || 0;
		    var prop;
		    for (i = 0; i < len; i += 1) {
		      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
		      this.k = prop.k || this.k;
		      this.dataProps[i] = {
		        n: data[i].n,
		        p: prop
		      };
		    }
		    if (!this.k) {
		      this.getValue(true);
		    }
		    this._isAnimated = this.k;
		  }
		  DashProperty.prototype.getValue = function (forceRender) {
		    if (this.elem.globalData.frameId === this.frameId && !forceRender) {
		      return;
		    }
		    this.frameId = this.elem.globalData.frameId;
		    this.iterateDynamicProperties();
		    this._mdf = this._mdf || forceRender;
		    if (this._mdf) {
		      var i = 0;
		      var len = this.dataProps.length;
		      if (this.renderer === 'svg') {
		        this.dashStr = '';
		      }
		      for (i = 0; i < len; i += 1) {
		        if (this.dataProps[i].n !== 'o') {
		          if (this.renderer === 'svg') {
		            this.dashStr += ' ' + this.dataProps[i].p.v;
		          } else {
		            this.dashArray[i] = this.dataProps[i].p.v;
		          }
		        } else {
		          this.dashoffset[0] = this.dataProps[i].p.v;
		        }
		      }
		    }
		  };
		  extendPrototype([DynamicPropertyContainer], DashProperty);

		  function SVGStrokeStyleData(elem, data, styleOb) {
		    this.initDynamicPropertyContainer(elem);
		    this.getValue = this.iterateDynamicProperties;
		    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
		    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
		    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
		    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
		    this.style = styleOb;
		    this._isAnimated = !!this._isAnimated;
		  }
		  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

		  function SVGFillStyleData(elem, data, styleOb) {
		    this.initDynamicPropertyContainer(elem);
		    this.getValue = this.iterateDynamicProperties;
		    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
		    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
		    this.style = styleOb;
		  }
		  extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

		  function SVGNoStyleData(elem, data, styleOb) {
		    this.initDynamicPropertyContainer(elem);
		    this.getValue = this.iterateDynamicProperties;
		    this.style = styleOb;
		  }
		  extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

		  function GradientProperty(elem, data, container) {
		    this.data = data;
		    this.c = createTypedArray('uint8c', data.p * 4);
		    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
		    this.o = createTypedArray('float32', cLength);
		    this._cmdf = false;
		    this._omdf = false;
		    this._collapsable = this.checkCollapsable();
		    this._hasOpacity = cLength;
		    this.initDynamicPropertyContainer(container);
		    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
		    this.k = this.prop.k;
		    this.getValue(true);
		  }
		  GradientProperty.prototype.comparePoints = function (values, points) {
		    var i = 0;
		    var len = this.o.length / 2;
		    var diff;
		    while (i < len) {
		      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
		      if (diff > 0.01) {
		        return false;
		      }
		      i += 1;
		    }
		    return true;
		  };
		  GradientProperty.prototype.checkCollapsable = function () {
		    if (this.o.length / 2 !== this.c.length / 4) {
		      return false;
		    }
		    if (this.data.k.k[0].s) {
		      var i = 0;
		      var len = this.data.k.k.length;
		      while (i < len) {
		        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
		          return false;
		        }
		        i += 1;
		      }
		    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
		      return false;
		    }
		    return true;
		  };
		  GradientProperty.prototype.getValue = function (forceRender) {
		    this.prop.getValue();
		    this._mdf = false;
		    this._cmdf = false;
		    this._omdf = false;
		    if (this.prop._mdf || forceRender) {
		      var i;
		      var len = this.data.p * 4;
		      var mult;
		      var val;
		      for (i = 0; i < len; i += 1) {
		        mult = i % 4 === 0 ? 100 : 255;
		        val = Math.round(this.prop.v[i] * mult);
		        if (this.c[i] !== val) {
		          this.c[i] = val;
		          this._cmdf = !forceRender;
		        }
		      }
		      if (this.o.length) {
		        len = this.prop.v.length;
		        for (i = this.data.p * 4; i < len; i += 1) {
		          mult = i % 2 === 0 ? 100 : 1;
		          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
		          if (this.o[i - this.data.p * 4] !== val) {
		            this.o[i - this.data.p * 4] = val;
		            this._omdf = !forceRender;
		          }
		        }
		      }
		      this._mdf = !forceRender;
		    }
		  };
		  extendPrototype([DynamicPropertyContainer], GradientProperty);

		  function SVGGradientFillStyleData(elem, data, styleOb) {
		    this.initDynamicPropertyContainer(elem);
		    this.getValue = this.iterateDynamicProperties;
		    this.initGradientData(elem, data, styleOb);
		  }
		  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
		    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
		    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
		    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
		    this.h = PropertyFactory.getProp(elem, data.h || {
		      k: 0
		    }, 0, 0.01, this);
		    this.a = PropertyFactory.getProp(elem, data.a || {
		      k: 0
		    }, 0, degToRads, this);
		    this.g = new GradientProperty(elem, data.g, this);
		    this.style = styleOb;
		    this.stops = [];
		    this.setGradientData(styleOb.pElem, data);
		    this.setGradientOpacity(data, styleOb);
		    this._isAnimated = !!this._isAnimated;
		  };
		  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
		    var gradientId = createElementID();
		    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
		    gfill.setAttribute('id', gradientId);
		    gfill.setAttribute('spreadMethod', 'pad');
		    gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
		    var stops = [];
		    var stop;
		    var j;
		    var jLen;
		    jLen = data.g.p * 4;
		    for (j = 0; j < jLen; j += 4) {
		      stop = createNS('stop');
		      gfill.appendChild(stop);
		      stops.push(stop);
		    }
		    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');
		    this.gf = gfill;
		    this.cst = stops;
		  };
		  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
		    if (this.g._hasOpacity && !this.g._collapsable) {
		      var stop;
		      var j;
		      var jLen;
		      var mask = createNS('mask');
		      var maskElement = createNS('path');
		      mask.appendChild(maskElement);
		      var opacityId = createElementID();
		      var maskId = createElementID();
		      mask.setAttribute('id', maskId);
		      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
		      opFill.setAttribute('id', opacityId);
		      opFill.setAttribute('spreadMethod', 'pad');
		      opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
		      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
		      var stops = this.stops;
		      for (j = data.g.p * 4; j < jLen; j += 2) {
		        stop = createNS('stop');
		        stop.setAttribute('stop-color', 'rgb(255,255,255)');
		        opFill.appendChild(stop);
		        stops.push(stop);
		      }
		      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');
		      if (data.ty === 'gs') {
		        maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
		        maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
		        if (data.lj === 1) {
		          maskElement.setAttribute('stroke-miterlimit', data.ml);
		        }
		      }
		      this.of = opFill;
		      this.ms = mask;
		      this.ost = stops;
		      this.maskId = maskId;
		      styleOb.msElem = maskElement;
		    }
		  };
		  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

		  function SVGGradientStrokeStyleData(elem, data, styleOb) {
		    this.initDynamicPropertyContainer(elem);
		    this.getValue = this.iterateDynamicProperties;
		    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
		    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
		    this.initGradientData(elem, data, styleOb);
		    this._isAnimated = !!this._isAnimated;
		  }
		  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

		  function ShapeGroupData() {
		    this.it = [];
		    this.prevViewData = [];
		    this.gr = createNS('g');
		  }

		  function SVGTransformData(mProps, op, container) {
		    this.transform = {
		      mProps: mProps,
		      op: op,
		      container: container
		    };
		    this.elements = [];
		    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
		  }

		  var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
		    if (length === 0) {
		      return '';
		    }
		    var _o = pathNodes.o;
		    var _i = pathNodes.i;
		    var _v = pathNodes.v;
		    var i;
		    var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
		    for (i = 1; i < length; i += 1) {
		      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
		    }
		    if (closed && length) {
		      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
		      shapeString += 'z';
		    }
		    return shapeString;
		  };

		  var SVGElementsRenderer = function () {
		    var _identityMatrix = new Matrix();
		    var _matrixHelper = new Matrix();
		    var ob = {
		      createRenderFunction: createRenderFunction
		    };
		    function createRenderFunction(data) {
		      switch (data.ty) {
		        case 'fl':
		          return renderFill;
		        case 'gf':
		          return renderGradient;
		        case 'gs':
		          return renderGradientStroke;
		        case 'st':
		          return renderStroke;
		        case 'sh':
		        case 'el':
		        case 'rc':
		        case 'sr':
		          return renderPath;
		        case 'tr':
		          return renderContentTransform;
		        case 'no':
		          return renderNoop;
		        default:
		          return null;
		      }
		    }
		    function renderContentTransform(styleData, itemData, isFirstFrame) {
		      if (isFirstFrame || itemData.transform.op._mdf) {
		        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
		      }
		      if (isFirstFrame || itemData.transform.mProps._mdf) {
		        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
		      }
		    }
		    function renderNoop() {}
		    function renderPath(styleData, itemData, isFirstFrame) {
		      var j;
		      var jLen;
		      var pathStringTransformed;
		      var redraw;
		      var pathNodes;
		      var l;
		      var lLen = itemData.styles.length;
		      var lvl = itemData.lvl;
		      var paths;
		      var mat;
		      var iterations;
		      var k;
		      for (l = 0; l < lLen; l += 1) {
		        redraw = itemData.sh._mdf || isFirstFrame;
		        if (itemData.styles[l].lvl < lvl) {
		          mat = _matrixHelper.reset();
		          iterations = lvl - itemData.styles[l].lvl;
		          k = itemData.transformers.length - 1;
		          while (!redraw && iterations > 0) {
		            redraw = itemData.transformers[k].mProps._mdf || redraw;
		            iterations -= 1;
		            k -= 1;
		          }
		          if (redraw) {
		            iterations = lvl - itemData.styles[l].lvl;
		            k = itemData.transformers.length - 1;
		            while (iterations > 0) {
		              mat.multiply(itemData.transformers[k].mProps.v);
		              iterations -= 1;
		              k -= 1;
		            }
		          }
		        } else {
		          mat = _identityMatrix;
		        }
		        paths = itemData.sh.paths;
		        jLen = paths._length;
		        if (redraw) {
		          pathStringTransformed = '';
		          for (j = 0; j < jLen; j += 1) {
		            pathNodes = paths.shapes[j];
		            if (pathNodes && pathNodes._length) {
		              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
		            }
		          }
		          itemData.caches[l] = pathStringTransformed;
		        } else {
		          pathStringTransformed = itemData.caches[l];
		        }
		        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
		        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
		      }
		    }
		    function renderFill(styleData, itemData, isFirstFrame) {
		      var styleElem = itemData.style;
		      if (itemData.c._mdf || isFirstFrame) {
		        styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
		      }
		      if (itemData.o._mdf || isFirstFrame) {
		        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
		      }
		    }
		    function renderGradientStroke(styleData, itemData, isFirstFrame) {
		      renderGradient(styleData, itemData, isFirstFrame);
		      renderStroke(styleData, itemData, isFirstFrame);
		    }
		    function renderGradient(styleData, itemData, isFirstFrame) {
		      var gfill = itemData.gf;
		      var hasOpacity = itemData.g._hasOpacity;
		      var pt1 = itemData.s.v;
		      var pt2 = itemData.e.v;
		      if (itemData.o._mdf || isFirstFrame) {
		        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
		        itemData.style.pElem.setAttribute(attr, itemData.o.v);
		      }
		      if (itemData.s._mdf || isFirstFrame) {
		        var attr1 = styleData.t === 1 ? 'x1' : 'cx';
		        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
		        gfill.setAttribute(attr1, pt1[0]);
		        gfill.setAttribute(attr2, pt1[1]);
		        if (hasOpacity && !itemData.g._collapsable) {
		          itemData.of.setAttribute(attr1, pt1[0]);
		          itemData.of.setAttribute(attr2, pt1[1]);
		        }
		      }
		      var stops;
		      var i;
		      var len;
		      var stop;
		      if (itemData.g._cmdf || isFirstFrame) {
		        stops = itemData.cst;
		        var cValues = itemData.g.c;
		        len = stops.length;
		        for (i = 0; i < len; i += 1) {
		          stop = stops[i];
		          stop.setAttribute('offset', cValues[i * 4] + '%');
		          stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
		        }
		      }
		      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
		        var oValues = itemData.g.o;
		        if (itemData.g._collapsable) {
		          stops = itemData.cst;
		        } else {
		          stops = itemData.ost;
		        }
		        len = stops.length;
		        for (i = 0; i < len; i += 1) {
		          stop = stops[i];
		          if (!itemData.g._collapsable) {
		            stop.setAttribute('offset', oValues[i * 2] + '%');
		          }
		          stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
		        }
		      }
		      if (styleData.t === 1) {
		        if (itemData.e._mdf || isFirstFrame) {
		          gfill.setAttribute('x2', pt2[0]);
		          gfill.setAttribute('y2', pt2[1]);
		          if (hasOpacity && !itemData.g._collapsable) {
		            itemData.of.setAttribute('x2', pt2[0]);
		            itemData.of.setAttribute('y2', pt2[1]);
		          }
		        }
		      } else {
		        var rad;
		        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
		          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
		          gfill.setAttribute('r', rad);
		          if (hasOpacity && !itemData.g._collapsable) {
		            itemData.of.setAttribute('r', rad);
		          }
		        }
		        if (itemData.s._mdf || itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
		          if (!rad) {
		            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
		          }
		          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
		          var percent = itemData.h.v;
		          if (percent >= 1) {
		            percent = 0.99;
		          } else if (percent <= -1) {
		            percent = -0.99;
		          }
		          var dist = rad * percent;
		          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
		          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
		          gfill.setAttribute('fx', x);
		          gfill.setAttribute('fy', y);
		          if (hasOpacity && !itemData.g._collapsable) {
		            itemData.of.setAttribute('fx', x);
		            itemData.of.setAttribute('fy', y);
		          }
		        }
		        // gfill.setAttribute('fy','200');
		      }
		    }
		    function renderStroke(styleData, itemData, isFirstFrame) {
		      var styleElem = itemData.style;
		      var d = itemData.d;
		      if (d && (d._mdf || isFirstFrame) && d.dashStr) {
		        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
		        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
		      }
		      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
		        styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
		      }
		      if (itemData.o._mdf || isFirstFrame) {
		        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
		      }
		      if (itemData.w._mdf || isFirstFrame) {
		        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
		        if (styleElem.msElem) {
		          styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
		        }
		      }
		    }
		    return ob;
		  }();

		  function SVGShapeElement(data, globalData, comp) {
		    // List of drawable elements
		    this.shapes = [];
		    // Full shape data
		    this.shapesData = data.shapes;
		    // List of styles that will be applied to shapes
		    this.stylesList = [];
		    // List of modifiers that will be applied to shapes
		    this.shapeModifiers = [];
		    // List of items in shape tree
		    this.itemsData = [];
		    // List of items in previous shape tree
		    this.processedElements = [];
		    // List of animated components
		    this.animatedContents = [];
		    this.initElement(data, globalData, comp);
		    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
		    // List of elements that have been created
		    this.prevViewData = [];
		    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
		  }
		  extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
		  SVGShapeElement.prototype.initSecondaryElement = function () {};
		  SVGShapeElement.prototype.identityMatrix = new Matrix();
		  SVGShapeElement.prototype.buildExpressionInterface = function () {};
		  SVGShapeElement.prototype.createContent = function () {
		    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
		    this.filterUniqueShapes();
		  };

		  /*
		  This method searches for multiple shapes that affect a single element and one of them is animated
		  */
		  SVGShapeElement.prototype.filterUniqueShapes = function () {
		    var i;
		    var len = this.shapes.length;
		    var shape;
		    var j;
		    var jLen = this.stylesList.length;
		    var style;
		    var tempShapes = [];
		    var areAnimated = false;
		    for (j = 0; j < jLen; j += 1) {
		      style = this.stylesList[j];
		      areAnimated = false;
		      tempShapes.length = 0;
		      for (i = 0; i < len; i += 1) {
		        shape = this.shapes[i];
		        if (shape.styles.indexOf(style) !== -1) {
		          tempShapes.push(shape);
		          areAnimated = shape._isAnimated || areAnimated;
		        }
		      }
		      if (tempShapes.length > 1 && areAnimated) {
		        this.setShapesAsAnimated(tempShapes);
		      }
		    }
		  };
		  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
		    var i;
		    var len = shapes.length;
		    for (i = 0; i < len; i += 1) {
		      shapes[i].setAsAnimated();
		    }
		  };
		  SVGShapeElement.prototype.createStyleElement = function (data, level) {
		    // TODO: prevent drawing of hidden styles
		    var elementData;
		    var styleOb = new SVGStyleData(data, level);
		    var pathElement = styleOb.pElem;
		    if (data.ty === 'st') {
		      elementData = new SVGStrokeStyleData(this, data, styleOb);
		    } else if (data.ty === 'fl') {
		      elementData = new SVGFillStyleData(this, data, styleOb);
		    } else if (data.ty === 'gf' || data.ty === 'gs') {
		      var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
		      elementData = new GradientConstructor(this, data, styleOb);
		      this.globalData.defs.appendChild(elementData.gf);
		      if (elementData.maskId) {
		        this.globalData.defs.appendChild(elementData.ms);
		        this.globalData.defs.appendChild(elementData.of);
		        pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');
		      }
		    } else if (data.ty === 'no') {
		      elementData = new SVGNoStyleData(this, data, styleOb);
		    }
		    if (data.ty === 'st' || data.ty === 'gs') {
		      pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
		      pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
		      pathElement.setAttribute('fill-opacity', '0');
		      if (data.lj === 1) {
		        pathElement.setAttribute('stroke-miterlimit', data.ml);
		      }
		    }
		    if (data.r === 2) {
		      pathElement.setAttribute('fill-rule', 'evenodd');
		    }
		    if (data.ln) {
		      pathElement.setAttribute('id', data.ln);
		    }
		    if (data.cl) {
		      pathElement.setAttribute('class', data.cl);
		    }
		    if (data.bm) {
		      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
		    }
		    this.stylesList.push(styleOb);
		    this.addToAnimatedContents(data, elementData);
		    return elementData;
		  };
		  SVGShapeElement.prototype.createGroupElement = function (data) {
		    var elementData = new ShapeGroupData();
		    if (data.ln) {
		      elementData.gr.setAttribute('id', data.ln);
		    }
		    if (data.cl) {
		      elementData.gr.setAttribute('class', data.cl);
		    }
		    if (data.bm) {
		      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
		    }
		    return elementData;
		  };
		  SVGShapeElement.prototype.createTransformElement = function (data, container) {
		    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
		    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
		    this.addToAnimatedContents(data, elementData);
		    return elementData;
		  };
		  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
		    var ty = 4;
		    if (data.ty === 'rc') {
		      ty = 5;
		    } else if (data.ty === 'el') {
		      ty = 6;
		    } else if (data.ty === 'sr') {
		      ty = 7;
		    }
		    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
		    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
		    this.shapes.push(elementData);
		    this.addShapeToModifiers(elementData);
		    this.addToAnimatedContents(data, elementData);
		    return elementData;
		  };
		  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
		    var i = 0;
		    var len = this.animatedContents.length;
		    while (i < len) {
		      if (this.animatedContents[i].element === element) {
		        return;
		      }
		      i += 1;
		    }
		    this.animatedContents.push({
		      fn: SVGElementsRenderer.createRenderFunction(data),
		      element: element,
		      data: data
		    });
		  };
		  SVGShapeElement.prototype.setElementStyles = function (elementData) {
		    var arr = elementData.styles;
		    var j;
		    var jLen = this.stylesList.length;
		    for (j = 0; j < jLen; j += 1) {
		      if (arr.indexOf(this.stylesList[j]) === -1 && !this.stylesList[j].closed) {
		        arr.push(this.stylesList[j]);
		      }
		    }
		  };
		  SVGShapeElement.prototype.reloadShapes = function () {
		    this._isFirstFrame = true;
		    var i;
		    var len = this.itemsData.length;
		    for (i = 0; i < len; i += 1) {
		      this.prevViewData[i] = this.itemsData[i];
		    }
		    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
		    this.filterUniqueShapes();
		    len = this.dynamicProperties.length;
		    for (i = 0; i < len; i += 1) {
		      this.dynamicProperties[i].getValue();
		    }
		    this.renderModifiers();
		  };
		  SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
		    var ownTransformers = [].concat(transformers);
		    var i;
		    var len = arr.length - 1;
		    var j;
		    var jLen;
		    var ownStyles = [];
		    var ownModifiers = [];
		    var currentTransform;
		    var modifier;
		    var processedPos;
		    for (i = len; i >= 0; i -= 1) {
		      processedPos = this.searchProcessedElement(arr[i]);
		      if (!processedPos) {
		        arr[i]._render = render;
		      } else {
		        itemsData[i] = prevViewData[processedPos - 1];
		      }
		      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {
		        if (!processedPos) {
		          itemsData[i] = this.createStyleElement(arr[i], level);
		        } else {
		          itemsData[i].style.closed = arr[i].hd;
		        }
		        if (arr[i]._render) {
		          if (itemsData[i].style.pElem.parentNode !== container) {
		            container.appendChild(itemsData[i].style.pElem);
		          }
		        }
		        ownStyles.push(itemsData[i].style);
		      } else if (arr[i].ty === 'gr') {
		        if (!processedPos) {
		          itemsData[i] = this.createGroupElement(arr[i]);
		        } else {
		          jLen = itemsData[i].it.length;
		          for (j = 0; j < jLen; j += 1) {
		            itemsData[i].prevViewData[j] = itemsData[i].it[j];
		          }
		        }
		        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
		        if (arr[i]._render) {
		          if (itemsData[i].gr.parentNode !== container) {
		            container.appendChild(itemsData[i].gr);
		          }
		        }
		      } else if (arr[i].ty === 'tr') {
		        if (!processedPos) {
		          itemsData[i] = this.createTransformElement(arr[i], container);
		        }
		        currentTransform = itemsData[i].transform;
		        ownTransformers.push(currentTransform);
		      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
		        if (!processedPos) {
		          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
		        }
		        this.setElementStyles(itemsData[i]);
		      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
		        if (!processedPos) {
		          modifier = ShapeModifiers.getModifier(arr[i].ty);
		          modifier.init(this, arr[i]);
		          itemsData[i] = modifier;
		          this.shapeModifiers.push(modifier);
		        } else {
		          modifier = itemsData[i];
		          modifier.closed = false;
		        }
		        ownModifiers.push(modifier);
		      } else if (arr[i].ty === 'rp') {
		        if (!processedPos) {
		          modifier = ShapeModifiers.getModifier(arr[i].ty);
		          itemsData[i] = modifier;
		          modifier.init(this, arr, i, itemsData);
		          this.shapeModifiers.push(modifier);
		          render = false;
		        } else {
		          modifier = itemsData[i];
		          modifier.closed = true;
		        }
		        ownModifiers.push(modifier);
		      }
		      this.addProcessedElement(arr[i], i + 1);
		    }
		    len = ownStyles.length;
		    for (i = 0; i < len; i += 1) {
		      ownStyles[i].closed = true;
		    }
		    len = ownModifiers.length;
		    for (i = 0; i < len; i += 1) {
		      ownModifiers[i].closed = true;
		    }
		  };
		  SVGShapeElement.prototype.renderInnerContent = function () {
		    this.renderModifiers();
		    var i;
		    var len = this.stylesList.length;
		    for (i = 0; i < len; i += 1) {
		      this.stylesList[i].reset();
		    }
		    this.renderShape();
		    for (i = 0; i < len; i += 1) {
		      if (this.stylesList[i]._mdf || this._isFirstFrame) {
		        if (this.stylesList[i].msElem) {
		          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
		          // Adding M0 0 fixes same mask bug on all browsers
		          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
		        }
		        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
		      }
		    }
		  };
		  SVGShapeElement.prototype.renderShape = function () {
		    var i;
		    var len = this.animatedContents.length;
		    var animatedContent;
		    for (i = 0; i < len; i += 1) {
		      animatedContent = this.animatedContents[i];
		      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
		        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
		      }
		    }
		  };
		  SVGShapeElement.prototype.destroy = function () {
		    this.destroyBaseElement();
		    this.shapesData = null;
		    this.itemsData = null;
		  };

		  function LetterProps(o, sw, sc, fc, m, p) {
		    this.o = o;
		    this.sw = sw;
		    this.sc = sc;
		    this.fc = fc;
		    this.m = m;
		    this.p = p;
		    this._mdf = {
		      o: true,
		      sw: !!sw,
		      sc: !!sc,
		      fc: !!fc,
		      m: true,
		      p: true
		    };
		  }
		  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
		    this._mdf.o = false;
		    this._mdf.sw = false;
		    this._mdf.sc = false;
		    this._mdf.fc = false;
		    this._mdf.m = false;
		    this._mdf.p = false;
		    var updated = false;
		    if (this.o !== o) {
		      this.o = o;
		      this._mdf.o = true;
		      updated = true;
		    }
		    if (this.sw !== sw) {
		      this.sw = sw;
		      this._mdf.sw = true;
		      updated = true;
		    }
		    if (this.sc !== sc) {
		      this.sc = sc;
		      this._mdf.sc = true;
		      updated = true;
		    }
		    if (this.fc !== fc) {
		      this.fc = fc;
		      this._mdf.fc = true;
		      updated = true;
		    }
		    if (this.m !== m) {
		      this.m = m;
		      this._mdf.m = true;
		      updated = true;
		    }
		    if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
		      this.p = p;
		      this._mdf.p = true;
		      updated = true;
		    }
		    return updated;
		  };

		  function TextProperty(elem, data) {
		    this._frameId = initialDefaultFrame;
		    this.pv = '';
		    this.v = '';
		    this.kf = false;
		    this._isFirstFrame = true;
		    this._mdf = false;
		    if (data.d && data.d.sid) {
		      data.d = elem.globalData.slotManager.getProp(data.d);
		    }
		    this.data = data;
		    this.elem = elem;
		    this.comp = this.elem.comp;
		    this.keysIndex = 0;
		    this.canResize = false;
		    this.minimumFontSize = 1;
		    this.effectsSequence = [];
		    this.currentData = {
		      ascent: 0,
		      boxWidth: this.defaultBoxWidth,
		      f: '',
		      fStyle: '',
		      fWeight: '',
		      fc: '',
		      j: '',
		      justifyOffset: '',
		      l: [],
		      lh: 0,
		      lineWidths: [],
		      ls: '',
		      of: '',
		      s: '',
		      sc: '',
		      sw: 0,
		      t: 0,
		      tr: 0,
		      sz: 0,
		      ps: null,
		      fillColorAnim: false,
		      strokeColorAnim: false,
		      strokeWidthAnim: false,
		      yOffset: 0,
		      finalSize: 0,
		      finalText: [],
		      finalLineHeight: 0,
		      __complete: false
		    };
		    this.copyData(this.currentData, this.data.d.k[0].s);
		    if (!this.searchProperty()) {
		      this.completeTextData(this.currentData);
		    }
		  }
		  TextProperty.prototype.defaultBoxWidth = [0, 0];
		  TextProperty.prototype.copyData = function (obj, data) {
		    for (var s in data) {
		      if (Object.prototype.hasOwnProperty.call(data, s)) {
		        obj[s] = data[s];
		      }
		    }
		    return obj;
		  };
		  TextProperty.prototype.setCurrentData = function (data) {
		    if (!data.__complete) {
		      this.completeTextData(data);
		    }
		    this.currentData = data;
		    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
		    this._mdf = true;
		  };
		  TextProperty.prototype.searchProperty = function () {
		    return this.searchKeyframes();
		  };
		  TextProperty.prototype.searchKeyframes = function () {
		    this.kf = this.data.d.k.length > 1;
		    if (this.kf) {
		      this.addEffect(this.getKeyframeValue.bind(this));
		    }
		    return this.kf;
		  };
		  TextProperty.prototype.addEffect = function (effectFunction) {
		    this.effectsSequence.push(effectFunction);
		    this.elem.addDynamicProperty(this);
		  };
		  TextProperty.prototype.getValue = function (_finalValue) {
		    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
		      return;
		    }
		    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
		    var currentValue = this.currentData;
		    var currentIndex = this.keysIndex;
		    if (this.lock) {
		      this.setCurrentData(this.currentData);
		      return;
		    }
		    this.lock = true;
		    this._mdf = false;
		    var i;
		    var len = this.effectsSequence.length;
		    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
		    for (i = 0; i < len; i += 1) {
		      // Checking if index changed to prevent creating a new object every time the expression updates.
		      if (currentIndex !== this.keysIndex) {
		        finalValue = this.effectsSequence[i](finalValue, finalValue.t);
		      } else {
		        finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
		      }
		    }
		    if (currentValue !== finalValue) {
		      this.setCurrentData(finalValue);
		    }
		    this.v = this.currentData;
		    this.pv = this.v;
		    this.lock = false;
		    this.frameId = this.elem.globalData.frameId;
		  };
		  TextProperty.prototype.getKeyframeValue = function () {
		    var textKeys = this.data.d.k;
		    var frameNum = this.elem.comp.renderedFrame;
		    var i = 0;
		    var len = textKeys.length;
		    while (i <= len - 1) {
		      if (i === len - 1 || textKeys[i + 1].t > frameNum) {
		        break;
		      }
		      i += 1;
		    }
		    if (this.keysIndex !== i) {
		      this.keysIndex = i;
		    }
		    return this.data.d.k[this.keysIndex].s;
		  };
		  TextProperty.prototype.buildFinalText = function (text) {
		    var charactersArray = [];
		    var i = 0;
		    var len = text.length;
		    var charCode;
		    var secondCharCode;
		    var shouldCombine = false;
		    var shouldCombineNext = false;
		    var currentChars = '';
		    while (i < len) {
		      shouldCombine = shouldCombineNext;
		      shouldCombineNext = false;
		      charCode = text.charCodeAt(i);
		      currentChars = text.charAt(i);
		      if (FontManager.isCombinedCharacter(charCode)) {
		        shouldCombine = true;
		        // It's a potential surrogate pair (this is the High surrogate)
		      } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
		        if (FontManager.isRegionalFlag(text, i)) {
		          currentChars = text.substr(i, 14);
		        } else {
		          secondCharCode = text.charCodeAt(i + 1);
		          // It's a surrogate pair (this is the Low surrogate)
		          if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
		            if (FontManager.isModifier(charCode, secondCharCode)) {
		              currentChars = text.substr(i, 2);
		              shouldCombine = true;
		            } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {
		              currentChars = text.substr(i, 4);
		            } else {
		              currentChars = text.substr(i, 2);
		            }
		          }
		        }
		      } else if (charCode > 0xDBFF) {
		        secondCharCode = text.charCodeAt(i + 1);
		        if (FontManager.isVariationSelector(charCode)) {
		          shouldCombine = true;
		        }
		      } else if (FontManager.isZeroWidthJoiner(charCode)) {
		        shouldCombine = true;
		        shouldCombineNext = true;
		      }
		      if (shouldCombine) {
		        charactersArray[charactersArray.length - 1] += currentChars;
		        shouldCombine = false;
		      } else {
		        charactersArray.push(currentChars);
		      }
		      i += currentChars.length;
		    }
		    return charactersArray;
		  };
		  TextProperty.prototype.completeTextData = function (documentData) {
		    documentData.__complete = true;
		    var fontManager = this.elem.globalData.fontManager;
		    var data = this.data;
		    var letters = [];
		    var i;
		    var len;
		    var newLineFlag;
		    var index = 0;
		    var val;
		    var anchorGrouping = data.m.g;
		    var currentSize = 0;
		    var currentPos = 0;
		    var currentLine = 0;
		    var lineWidths = [];
		    var lineWidth = 0;
		    var maxLineWidth = 0;
		    var j;
		    var jLen;
		    var fontData = fontManager.getFontByName(documentData.f);
		    var charData;
		    var cLength = 0;
		    var fontProps = getFontProperties(fontData);
		    documentData.fWeight = fontProps.weight;
		    documentData.fStyle = fontProps.style;
		    documentData.finalSize = documentData.s;
		    documentData.finalText = this.buildFinalText(documentData.t);
		    len = documentData.finalText.length;
		    documentData.finalLineHeight = documentData.lh;
		    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
		    var charCode;
		    if (documentData.sz) {
		      var flag = true;
		      var boxWidth = documentData.sz[0];
		      var boxHeight = documentData.sz[1];
		      var currentHeight;
		      var finalText;
		      while (flag) {
		        finalText = this.buildFinalText(documentData.t);
		        currentHeight = 0;
		        lineWidth = 0;
		        len = finalText.length;
		        trackingOffset = documentData.tr / 1000 * documentData.finalSize;
		        var lastSpaceIndex = -1;
		        for (i = 0; i < len; i += 1) {
		          charCode = finalText[i].charCodeAt(0);
		          newLineFlag = false;
		          if (finalText[i] === ' ') {
		            lastSpaceIndex = i;
		          } else if (charCode === 13 || charCode === 3) {
		            lineWidth = 0;
		            newLineFlag = true;
		            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
		          }
		          if (fontManager.chars) {
		            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
		            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
		          } else {
		            // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
		            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
		          }
		          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
		            if (lastSpaceIndex === -1) {
		              len += 1;
		            } else {
		              i = lastSpaceIndex;
		            }
		            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
		            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
		            // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
		            lastSpaceIndex = -1;
		            lineWidth = 0;
		          } else {
		            lineWidth += cLength;
		            lineWidth += trackingOffset;
		          }
		        }
		        currentHeight += fontData.ascent * documentData.finalSize / 100;
		        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
		          documentData.finalSize -= 1;
		          documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
		        } else {
		          documentData.finalText = finalText;
		          len = documentData.finalText.length;
		          flag = false;
		        }
		      }
		    }
		    lineWidth = -trackingOffset;
		    cLength = 0;
		    var uncollapsedSpaces = 0;
		    var currentChar;
		    for (i = 0; i < len; i += 1) {
		      newLineFlag = false;
		      currentChar = documentData.finalText[i];
		      charCode = currentChar.charCodeAt(0);
		      if (charCode === 13 || charCode === 3) {
		        uncollapsedSpaces = 0;
		        lineWidths.push(lineWidth);
		        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
		        lineWidth = -2 * trackingOffset;
		        val = '';
		        newLineFlag = true;
		        currentLine += 1;
		      } else {
		        val = currentChar;
		      }
		      if (fontManager.chars) {
		        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
		        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
		      } else {
		        // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
		        // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
		        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
		      }

		      //
		      if (currentChar === ' ') {
		        uncollapsedSpaces += cLength + trackingOffset;
		      } else {
		        lineWidth += cLength + trackingOffset + uncollapsedSpaces;
		        uncollapsedSpaces = 0;
		      }
		      letters.push({
		        l: cLength,
		        an: cLength,
		        add: currentSize,
		        n: newLineFlag,
		        anIndexes: [],
		        val: val,
		        line: currentLine,
		        animatorJustifyOffset: 0
		      });
		      if (anchorGrouping == 2) {
		        // eslint-disable-line eqeqeq
		        currentSize += cLength;
		        if (val === '' || val === ' ' || i === len - 1) {
		          if (val === '' || val === ' ') {
		            currentSize -= cLength;
		          }
		          while (currentPos <= i) {
		            letters[currentPos].an = currentSize;
		            letters[currentPos].ind = index;
		            letters[currentPos].extra = cLength;
		            currentPos += 1;
		          }
		          index += 1;
		          currentSize = 0;
		        }
		      } else if (anchorGrouping == 3) {
		        // eslint-disable-line eqeqeq
		        currentSize += cLength;
		        if (val === '' || i === len - 1) {
		          if (val === '') {
		            currentSize -= cLength;
		          }
		          while (currentPos <= i) {
		            letters[currentPos].an = currentSize;
		            letters[currentPos].ind = index;
		            letters[currentPos].extra = cLength;
		            currentPos += 1;
		          }
		          currentSize = 0;
		          index += 1;
		        }
		      } else {
		        letters[index].ind = index;
		        letters[index].extra = 0;
		        index += 1;
		      }
		    }
		    documentData.l = letters;
		    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
		    lineWidths.push(lineWidth);
		    if (documentData.sz) {
		      documentData.boxWidth = documentData.sz[0];
		      documentData.justifyOffset = 0;
		    } else {
		      documentData.boxWidth = maxLineWidth;
		      switch (documentData.j) {
		        case 1:
		          documentData.justifyOffset = -documentData.boxWidth;
		          break;
		        case 2:
		          documentData.justifyOffset = -documentData.boxWidth / 2;
		          break;
		        default:
		          documentData.justifyOffset = 0;
		      }
		    }
		    documentData.lineWidths = lineWidths;
		    var animators = data.a;
		    var animatorData;
		    var letterData;
		    jLen = animators.length;
		    var based;
		    var ind;
		    var indexes = [];
		    for (j = 0; j < jLen; j += 1) {
		      animatorData = animators[j];
		      if (animatorData.a.sc) {
		        documentData.strokeColorAnim = true;
		      }
		      if (animatorData.a.sw) {
		        documentData.strokeWidthAnim = true;
		      }
		      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
		        documentData.fillColorAnim = true;
		      }
		      ind = 0;
		      based = animatorData.s.b;
		      for (i = 0; i < len; i += 1) {
		        letterData = letters[i];
		        letterData.anIndexes[j] = ind;
		        if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
		          // eslint-disable-line eqeqeq
		          if (animatorData.s.rn === 1) {
		            indexes.push(ind);
		          }
		          ind += 1;
		        }
		      }
		      data.a[j].s.totalChars = ind;
		      var currentInd = -1;
		      var newInd;
		      if (animatorData.s.rn === 1) {
		        for (i = 0; i < len; i += 1) {
		          letterData = letters[i];
		          if (currentInd != letterData.anIndexes[j]) {
		            // eslint-disable-line eqeqeq
		            currentInd = letterData.anIndexes[j];
		            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
		          }
		          letterData.anIndexes[j] = newInd;
		        }
		      }
		    }
		    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
		    documentData.ls = documentData.ls || 0;
		    documentData.ascent = fontData.ascent * documentData.finalSize / 100;
		  };
		  TextProperty.prototype.updateDocumentData = function (newData, index) {
		    index = index === undefined ? this.keysIndex : index;
		    var dData = this.copyData({}, this.data.d.k[index].s);
		    dData = this.copyData(dData, newData);
		    this.data.d.k[index].s = dData;
		    this.recalculate(index);
		    this.setCurrentData(dData);
		    this.elem.addDynamicProperty(this);
		  };
		  TextProperty.prototype.recalculate = function (index) {
		    var dData = this.data.d.k[index].s;
		    dData.__complete = false;
		    this.keysIndex = 0;
		    this._isFirstFrame = true;
		    this.getValue(dData);
		  };
		  TextProperty.prototype.canResizeFont = function (_canResize) {
		    this.canResize = _canResize;
		    this.recalculate(this.keysIndex);
		    this.elem.addDynamicProperty(this);
		  };
		  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
		    this.minimumFontSize = Math.floor(_fontValue) || 1;
		    this.recalculate(this.keysIndex);
		    this.elem.addDynamicProperty(this);
		  };

		  var TextSelectorProp = function () {
		    var max = Math.max;
		    var min = Math.min;
		    var floor = Math.floor;
		    function TextSelectorPropFactory(elem, data) {
		      this._currentTextLength = -1;
		      this.k = false;
		      this.data = data;
		      this.elem = elem;
		      this.comp = elem.comp;
		      this.finalS = 0;
		      this.finalE = 0;
		      this.initDynamicPropertyContainer(elem);
		      this.s = PropertyFactory.getProp(elem, data.s || {
		        k: 0
		      }, 0, 0, this);
		      if ('e' in data) {
		        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
		      } else {
		        this.e = {
		          v: 100
		        };
		      }
		      this.o = PropertyFactory.getProp(elem, data.o || {
		        k: 0
		      }, 0, 0, this);
		      this.xe = PropertyFactory.getProp(elem, data.xe || {
		        k: 0
		      }, 0, 0, this);
		      this.ne = PropertyFactory.getProp(elem, data.ne || {
		        k: 0
		      }, 0, 0, this);
		      this.sm = PropertyFactory.getProp(elem, data.sm || {
		        k: 100
		      }, 0, 0, this);
		      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
		      if (!this.dynamicProperties.length) {
		        this.getValue();
		      }
		    }
		    TextSelectorPropFactory.prototype = {
		      getMult: function getMult(ind) {
		        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
		          this.getValue();
		        }
		        var x1 = 0;
		        var y1 = 0;
		        var x2 = 1;
		        var y2 = 1;
		        if (this.ne.v > 0) {
		          x1 = this.ne.v / 100.0;
		        } else {
		          y1 = -this.ne.v / 100.0;
		        }
		        if (this.xe.v > 0) {
		          x2 = 1.0 - this.xe.v / 100.0;
		        } else {
		          y2 = 1.0 + this.xe.v / 100.0;
		        }
		        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
		        var mult = 0;
		        var s = this.finalS;
		        var e = this.finalE;
		        var type = this.data.sh;
		        if (type === 2) {
		          if (e === s) {
		            mult = ind >= e ? 1 : 0;
		          } else {
		            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
		          }
		          mult = easer(mult);
		        } else if (type === 3) {
		          if (e === s) {
		            mult = ind >= e ? 0 : 1;
		          } else {
		            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
		          }
		          mult = easer(mult);
		        } else if (type === 4) {
		          if (e === s) {
		            mult = 0;
		          } else {
		            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
		            if (mult < 0.5) {
		              mult *= 2;
		            } else {
		              mult = 1 - 2 * (mult - 0.5);
		            }
		          }
		          mult = easer(mult);
		        } else if (type === 5) {
		          if (e === s) {
		            mult = 0;
		          } else {
		            var tot = e - s;
		            /* ind += 0.5;
		                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
		            ind = min(max(0, ind + 0.5 - s), e - s);
		            var x = -tot / 2 + ind;
		            var a = tot / 2;
		            mult = Math.sqrt(1 - x * x / (a * a));
		          }
		          mult = easer(mult);
		        } else if (type === 6) {
		          if (e === s) {
		            mult = 0;
		          } else {
		            ind = min(max(0, ind + 0.5 - s), e - s);
		            mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
		          }
		          mult = easer(mult);
		        } else {
		          if (ind >= floor(s)) {
		            if (ind - s < 0) {
		              mult = max(0, min(min(e, 1) - (s - ind), 1));
		            } else {
		              mult = max(0, min(e - ind, 1));
		            }
		          }
		          mult = easer(mult);
		        }
		        // Smoothness implementation.
		        // The smoothness represents a reduced range of the original [0; 1] range.
		        // if smoothness is 25%, the new range will be [0.375; 0.625]
		        // Steps are:
		        // - find the lower value of the new range (threshold)
		        // - if multiplier is smaller than that value, floor it to 0
		        // - if it is larger,
		        //     - subtract the threshold
		        //     - divide it by the smoothness (this will return the range to [0; 1])
		        // Note: If it doesn't work on some scenarios, consider applying it before the easer.
		        if (this.sm.v !== 100) {
		          var smoothness = this.sm.v * 0.01;
		          if (smoothness === 0) {
		            smoothness = 0.00000001;
		          }
		          var threshold = 0.5 - smoothness * 0.5;
		          if (mult < threshold) {
		            mult = 0;
		          } else {
		            mult = (mult - threshold) / smoothness;
		            if (mult > 1) {
		              mult = 1;
		            }
		          }
		        }
		        return mult * this.a.v;
		      },
		      getValue: function getValue(newCharsFlag) {
		        this.iterateDynamicProperties();
		        this._mdf = newCharsFlag || this._mdf;
		        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
		        if (newCharsFlag && this.data.r === 2) {
		          this.e.v = this._currentTextLength;
		        }
		        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
		        var o = this.o.v / divisor;
		        var s = this.s.v / divisor + o;
		        var e = this.e.v / divisor + o;
		        if (s > e) {
		          var _s = s;
		          s = e;
		          e = _s;
		        }
		        this.finalS = s;
		        this.finalE = e;
		      }
		    };
		    extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
		    function getTextSelectorProp(elem, data, arr) {
		      return new TextSelectorPropFactory(elem, data);
		    }
		    return {
		      getTextSelectorProp: getTextSelectorProp
		    };
		  }();

		  function TextAnimatorDataProperty(elem, animatorProps, container) {
		    var defaultData = {
		      propType: false
		    };
		    var getProp = PropertyFactory.getProp;
		    var textAnimatorAnimatables = animatorProps.a;
		    this.a = {
		      r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
		      rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
		      ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
		      sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
		      sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
		      s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
		      a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
		      o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
		      p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
		      sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
		      sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
		      fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
		      fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
		      fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
		      fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
		      t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
		    };
		    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
		    this.s.t = animatorProps.s.t;
		  }

		  function TextAnimatorProperty(textData, renderType, elem) {
		    this._isFirstFrame = true;
		    this._hasMaskedPath = false;
		    this._frameId = -1;
		    this._textData = textData;
		    this._renderType = renderType;
		    this._elem = elem;
		    this._animatorsData = createSizedArray(this._textData.a.length);
		    this._pathData = {};
		    this._moreOptions = {
		      alignment: {}
		    };
		    this.renderedLetters = [];
		    this.lettersChangedFlag = false;
		    this.initDynamicPropertyContainer(elem);
		  }
		  TextAnimatorProperty.prototype.searchProperties = function () {
		    var i;
		    var len = this._textData.a.length;
		    var animatorProps;
		    var getProp = PropertyFactory.getProp;
		    for (i = 0; i < len; i += 1) {
		      animatorProps = this._textData.a[i];
		      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
		    }
		    if (this._textData.p && 'm' in this._textData.p) {
		      this._pathData = {
		        a: getProp(this._elem, this._textData.p.a, 0, 0, this),
		        f: getProp(this._elem, this._textData.p.f, 0, 0, this),
		        l: getProp(this._elem, this._textData.p.l, 0, 0, this),
		        r: getProp(this._elem, this._textData.p.r, 0, 0, this),
		        p: getProp(this._elem, this._textData.p.p, 0, 0, this),
		        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
		      };
		      this._hasMaskedPath = true;
		    } else {
		      this._hasMaskedPath = false;
		    }
		    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
		  };
		  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
		    this.lettersChangedFlag = lettersChangedFlag;
		    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
		      return;
		    }
		    this._isFirstFrame = false;
		    var alignment = this._moreOptions.alignment.v;
		    var animators = this._animatorsData;
		    var textData = this._textData;
		    var matrixHelper = this.mHelper;
		    var renderType = this._renderType;
		    var renderedLettersCount = this.renderedLetters.length;
		    var xPos;
		    var yPos;
		    var i;
		    var len;
		    var letters = documentData.l;
		    var pathInfo;
		    var currentLength;
		    var currentPoint;
		    var segmentLength;
		    var flag;
		    var pointInd;
		    var segmentInd;
		    var prevPoint;
		    var points;
		    var segments;
		    var partialLength;
		    var totalLength;
		    var perc;
		    var tanAngle;
		    var mask;
		    if (this._hasMaskedPath) {
		      mask = this._pathData.m;
		      if (!this._pathData.n || this._pathData._mdf) {
		        var paths = mask.v;
		        if (this._pathData.r.v) {
		          paths = paths.reverse();
		        }
		        // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
		        pathInfo = {
		          tLength: 0,
		          segments: []
		        };
		        len = paths._length - 1;
		        var bezierData;
		        totalLength = 0;
		        for (i = 0; i < len; i += 1) {
		          bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
		          pathInfo.tLength += bezierData.segmentLength;
		          pathInfo.segments.push(bezierData);
		          totalLength += bezierData.segmentLength;
		        }
		        i = len;
		        if (mask.v.c) {
		          bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
		          pathInfo.tLength += bezierData.segmentLength;
		          pathInfo.segments.push(bezierData);
		          totalLength += bezierData.segmentLength;
		        }
		        this._pathData.pi = pathInfo;
		      }
		      pathInfo = this._pathData.pi;
		      currentLength = this._pathData.f.v;
		      segmentInd = 0;
		      pointInd = 1;
		      segmentLength = 0;
		      flag = true;
		      segments = pathInfo.segments;
		      if (currentLength < 0 && mask.v.c) {
		        if (pathInfo.tLength < Math.abs(currentLength)) {
		          currentLength = -Math.abs(currentLength) % pathInfo.tLength;
		        }
		        segmentInd = segments.length - 1;
		        points = segments[segmentInd].points;
		        pointInd = points.length - 1;
		        while (currentLength < 0) {
		          currentLength += points[pointInd].partialLength;
		          pointInd -= 1;
		          if (pointInd < 0) {
		            segmentInd -= 1;
		            points = segments[segmentInd].points;
		            pointInd = points.length - 1;
		          }
		        }
		      }
		      points = segments[segmentInd].points;
		      prevPoint = points[pointInd - 1];
		      currentPoint = points[pointInd];
		      partialLength = currentPoint.partialLength;
		    }
		    len = letters.length;
		    xPos = 0;
		    yPos = 0;
		    var yOff = documentData.finalSize * 1.2 * 0.714;
		    var firstLine = true;
		    var animatorProps;
		    var animatorSelector;
		    var j;
		    var jLen;
		    var letterValue;
		    jLen = animators.length;
		    var mult;
		    var ind = -1;
		    var offf;
		    var xPathPos;
		    var yPathPos;
		    var initPathPos = currentLength;
		    var initSegmentInd = segmentInd;
		    var initPointInd = pointInd;
		    var currentLine = -1;
		    var elemOpacity;
		    var sc;
		    var sw;
		    var fc;
		    var k;
		    var letterSw;
		    var letterSc;
		    var letterFc;
		    var letterM = '';
		    var letterP = this.defaultPropsArray;
		    var letterO;

		    //
		    if (documentData.j === 2 || documentData.j === 1) {
		      var animatorJustifyOffset = 0;
		      var animatorFirstCharOffset = 0;
		      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
		      var lastIndex = 0;
		      var isNewLine = true;
		      for (i = 0; i < len; i += 1) {
		        if (letters[i].n) {
		          if (animatorJustifyOffset) {
		            animatorJustifyOffset += animatorFirstCharOffset;
		          }
		          while (lastIndex < i) {
		            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
		            lastIndex += 1;
		          }
		          animatorJustifyOffset = 0;
		          isNewLine = true;
		        } else {
		          for (j = 0; j < jLen; j += 1) {
		            animatorProps = animators[j].a;
		            if (animatorProps.t.propType) {
		              if (isNewLine && documentData.j === 2) {
		                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
		              }
		              animatorSelector = animators[j].s;
		              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		              if (mult.length) {
		                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
		              } else {
		                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
		              }
		            }
		          }
		          isNewLine = false;
		        }
		      }
		      if (animatorJustifyOffset) {
		        animatorJustifyOffset += animatorFirstCharOffset;
		      }
		      while (lastIndex < i) {
		        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
		        lastIndex += 1;
		      }
		    }
		    //

		    for (i = 0; i < len; i += 1) {
		      matrixHelper.reset();
		      elemOpacity = 1;
		      if (letters[i].n) {
		        xPos = 0;
		        yPos += documentData.yOffset;
		        yPos += firstLine ? 1 : 0;
		        currentLength = initPathPos;
		        firstLine = false;
		        if (this._hasMaskedPath) {
		          segmentInd = initSegmentInd;
		          pointInd = initPointInd;
		          points = segments[segmentInd].points;
		          prevPoint = points[pointInd - 1];
		          currentPoint = points[pointInd];
		          partialLength = currentPoint.partialLength;
		          segmentLength = 0;
		        }
		        letterM = '';
		        letterFc = '';
		        letterSw = '';
		        letterO = '';
		        letterP = this.defaultPropsArray;
		      } else {
		        if (this._hasMaskedPath) {
		          if (currentLine !== letters[i].line) {
		            switch (documentData.j) {
		              case 1:
		                currentLength += totalLength - documentData.lineWidths[letters[i].line];
		                break;
		              case 2:
		                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
		                break;
		            }
		            currentLine = letters[i].line;
		          }
		          if (ind !== letters[i].ind) {
		            if (letters[ind]) {
		              currentLength += letters[ind].extra;
		            }
		            currentLength += letters[i].an / 2;
		            ind = letters[i].ind;
		          }
		          currentLength += alignment[0] * letters[i].an * 0.005;
		          var animatorOffset = 0;
		          for (j = 0; j < jLen; j += 1) {
		            animatorProps = animators[j].a;
		            if (animatorProps.p.propType) {
		              animatorSelector = animators[j].s;
		              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		              if (mult.length) {
		                animatorOffset += animatorProps.p.v[0] * mult[0];
		              } else {
		                animatorOffset += animatorProps.p.v[0] * mult;
		              }
		            }
		            if (animatorProps.a.propType) {
		              animatorSelector = animators[j].s;
		              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		              if (mult.length) {
		                animatorOffset += animatorProps.a.v[0] * mult[0];
		              } else {
		                animatorOffset += animatorProps.a.v[0] * mult;
		              }
		            }
		          }
		          flag = true;
		          // Force alignment only works with a single line for now
		          if (this._pathData.a.v) {
		            currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
		            currentLength += this._pathData.f.v;
		          }
		          while (flag) {
		            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
		              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
		              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
		              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
		              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
		              flag = false;
		            } else if (points) {
		              segmentLength += currentPoint.partialLength;
		              pointInd += 1;
		              if (pointInd >= points.length) {
		                pointInd = 0;
		                segmentInd += 1;
		                if (!segments[segmentInd]) {
		                  if (mask.v.c) {
		                    pointInd = 0;
		                    segmentInd = 0;
		                    points = segments[segmentInd].points;
		                  } else {
		                    segmentLength -= currentPoint.partialLength;
		                    points = null;
		                  }
		                } else {
		                  points = segments[segmentInd].points;
		                }
		              }
		              if (points) {
		                prevPoint = currentPoint;
		                currentPoint = points[pointInd];
		                partialLength = currentPoint.partialLength;
		              }
		            }
		          }
		          offf = letters[i].an / 2 - letters[i].add;
		          matrixHelper.translate(-offf, 0, 0);
		        } else {
		          offf = letters[i].an / 2 - letters[i].add;
		          matrixHelper.translate(-offf, 0, 0);

		          // Grouping alignment
		          matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
		        }
		        for (j = 0; j < jLen; j += 1) {
		          animatorProps = animators[j].a;
		          if (animatorProps.t.propType) {
		            animatorSelector = animators[j].s;
		            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		            // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
		            if (xPos !== 0 || documentData.j !== 0) {
		              if (this._hasMaskedPath) {
		                if (mult.length) {
		                  currentLength += animatorProps.t.v * mult[0];
		                } else {
		                  currentLength += animatorProps.t.v * mult;
		                }
		              } else if (mult.length) {
		                xPos += animatorProps.t.v * mult[0];
		              } else {
		                xPos += animatorProps.t.v * mult;
		              }
		            }
		          }
		        }
		        if (documentData.strokeWidthAnim) {
		          sw = documentData.sw || 0;
		        }
		        if (documentData.strokeColorAnim) {
		          if (documentData.sc) {
		            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
		          } else {
		            sc = [0, 0, 0];
		          }
		        }
		        if (documentData.fillColorAnim && documentData.fc) {
		          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
		        }
		        for (j = 0; j < jLen; j += 1) {
		          animatorProps = animators[j].a;
		          if (animatorProps.a.propType) {
		            animatorSelector = animators[j].s;
		            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		            if (mult.length) {
		              matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
		            } else {
		              matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
		            }
		          }
		        }
		        for (j = 0; j < jLen; j += 1) {
		          animatorProps = animators[j].a;
		          if (animatorProps.s.propType) {
		            animatorSelector = animators[j].s;
		            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		            if (mult.length) {
		              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
		            } else {
		              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
		            }
		          }
		        }
		        for (j = 0; j < jLen; j += 1) {
		          animatorProps = animators[j].a;
		          animatorSelector = animators[j].s;
		          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		          if (animatorProps.sk.propType) {
		            if (mult.length) {
		              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
		            } else {
		              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
		            }
		          }
		          if (animatorProps.r.propType) {
		            if (mult.length) {
		              matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
		            } else {
		              matrixHelper.rotateZ(-animatorProps.r.v * mult);
		            }
		          }
		          if (animatorProps.ry.propType) {
		            if (mult.length) {
		              matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
		            } else {
		              matrixHelper.rotateY(animatorProps.ry.v * mult);
		            }
		          }
		          if (animatorProps.rx.propType) {
		            if (mult.length) {
		              matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
		            } else {
		              matrixHelper.rotateX(animatorProps.rx.v * mult);
		            }
		          }
		          if (animatorProps.o.propType) {
		            if (mult.length) {
		              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
		            } else {
		              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
		            }
		          }
		          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
		            if (mult.length) {
		              sw += animatorProps.sw.v * mult[0];
		            } else {
		              sw += animatorProps.sw.v * mult;
		            }
		          }
		          if (documentData.strokeColorAnim && animatorProps.sc.propType) {
		            for (k = 0; k < 3; k += 1) {
		              if (mult.length) {
		                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
		              } else {
		                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
		              }
		            }
		          }
		          if (documentData.fillColorAnim && documentData.fc) {
		            if (animatorProps.fc.propType) {
		              for (k = 0; k < 3; k += 1) {
		                if (mult.length) {
		                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
		                } else {
		                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
		                }
		              }
		            }
		            if (animatorProps.fh.propType) {
		              if (mult.length) {
		                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
		              } else {
		                fc = addHueToRGB(fc, animatorProps.fh.v * mult);
		              }
		            }
		            if (animatorProps.fs.propType) {
		              if (mult.length) {
		                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
		              } else {
		                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
		              }
		            }
		            if (animatorProps.fb.propType) {
		              if (mult.length) {
		                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
		              } else {
		                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
		              }
		            }
		          }
		        }
		        for (j = 0; j < jLen; j += 1) {
		          animatorProps = animators[j].a;
		          if (animatorProps.p.propType) {
		            animatorSelector = animators[j].s;
		            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
		            if (this._hasMaskedPath) {
		              if (mult.length) {
		                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
		              } else {
		                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
		              }
		            } else if (mult.length) {
		              matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
		            } else {
		              matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
		            }
		          }
		        }
		        if (documentData.strokeWidthAnim) {
		          letterSw = sw < 0 ? 0 : sw;
		        }
		        if (documentData.strokeColorAnim) {
		          letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
		        }
		        if (documentData.fillColorAnim && documentData.fc) {
		          letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
		        }
		        if (this._hasMaskedPath) {
		          matrixHelper.translate(0, -documentData.ls);
		          matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
		          if (this._pathData.p.v) {
		            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
		            var rot = Math.atan(tanAngle) * 180 / Math.PI;
		            if (currentPoint.point[0] < prevPoint.point[0]) {
		              rot += 180;
		            }
		            matrixHelper.rotate(-rot * Math.PI / 180);
		          }
		          matrixHelper.translate(xPathPos, yPathPos, 0);
		          currentLength -= alignment[0] * letters[i].an * 0.005;
		          if (letters[i + 1] && ind !== letters[i + 1].ind) {
		            currentLength += letters[i].an / 2;
		            currentLength += documentData.tr * 0.001 * documentData.finalSize;
		          }
		        } else {
		          matrixHelper.translate(xPos, yPos, 0);
		          if (documentData.ps) {
		            // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
		            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
		          }
		          switch (documentData.j) {
		            case 1:
		              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
		              break;
		            case 2:
		              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
		              break;
		          }
		          matrixHelper.translate(0, -documentData.ls);
		          matrixHelper.translate(offf, 0, 0);
		          matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
		          xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
		        }
		        if (renderType === 'html') {
		          letterM = matrixHelper.toCSS();
		        } else if (renderType === 'svg') {
		          letterM = matrixHelper.to2dCSS();
		        } else {
		          letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
		        }
		        letterO = elemOpacity;
		      }
		      if (renderedLettersCount <= i) {
		        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
		        this.renderedLetters.push(letterValue);
		        renderedLettersCount += 1;
		        this.lettersChangedFlag = true;
		      } else {
		        letterValue = this.renderedLetters[i];
		        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
		      }
		    }
		  };
		  TextAnimatorProperty.prototype.getValue = function () {
		    if (this._elem.globalData.frameId === this._frameId) {
		      return;
		    }
		    this._frameId = this._elem.globalData.frameId;
		    this.iterateDynamicProperties();
		  };
		  TextAnimatorProperty.prototype.mHelper = new Matrix();
		  TextAnimatorProperty.prototype.defaultPropsArray = [];
		  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

		  function ITextElement() {}
		  ITextElement.prototype.initElement = function (data, globalData, comp) {
		    this.lettersChangedFlag = true;
		    this.initFrame();
		    this.initBaseData(data, globalData, comp);
		    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
		    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
		    this.initTransform(data, globalData, comp);
		    this.initHierarchy();
		    this.initRenderable();
		    this.initRendererElement();
		    this.createContainerElements();
		    this.createRenderableComponents();
		    this.createContent();
		    this.hide();
		    this.textAnimator.searchProperties(this.dynamicProperties);
		  };
		  ITextElement.prototype.prepareFrame = function (num) {
		    this._mdf = false;
		    this.prepareRenderableFrame(num);
		    this.prepareProperties(num, this.isInRange);
		  };
		  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
		    var j;
		    var jLen = shapes.length;
		    var pathNodes;
		    var shapeStr = '';
		    for (j = 0; j < jLen; j += 1) {
		      if (shapes[j].ty === 'sh') {
		        pathNodes = shapes[j].ks.k;
		        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
		      }
		    }
		    return shapeStr;
		  };
		  ITextElement.prototype.updateDocumentData = function (newData, index) {
		    this.textProperty.updateDocumentData(newData, index);
		  };
		  ITextElement.prototype.canResizeFont = function (_canResize) {
		    this.textProperty.canResizeFont(_canResize);
		  };
		  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
		    this.textProperty.setMinimumFontSize(_fontSize);
		  };
		  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
		    if (documentData.ps) {
		      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
		    }
		    matrixHelper.translate(0, -documentData.ls, 0);
		    switch (documentData.j) {
		      case 1:
		        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
		        break;
		      case 2:
		        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
		        break;
		    }
		    matrixHelper.translate(xPos, yPos, 0);
		  };
		  ITextElement.prototype.buildColor = function (colorData) {
		    return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
		  };
		  ITextElement.prototype.emptyProp = new LetterProps();
		  ITextElement.prototype.destroy = function () {};
		  ITextElement.prototype.validateText = function () {
		    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
		      this.buildNewText();
		      this.textProperty._isFirstFrame = false;
		      this.textProperty._mdf = false;
		    }
		  };

		  var emptyShapeData = {
		    shapes: []
		  };
		  function SVGTextLottieElement(data, globalData, comp) {
		    this.textSpans = [];
		    this.renderType = 'svg';
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
		  SVGTextLottieElement.prototype.createContent = function () {
		    if (this.data.singleShape && !this.globalData.fontManager.chars) {
		      this.textContainer = createNS('text');
		    }
		  };
		  SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
		    var i = 0;
		    var len = textArray.length;
		    var textContents = [];
		    var currentTextContent = '';
		    while (i < len) {
		      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
		        textContents.push(currentTextContent);
		        currentTextContent = '';
		      } else {
		        currentTextContent += textArray[i];
		      }
		      i += 1;
		    }
		    textContents.push(currentTextContent);
		    return textContents;
		  };
		  SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {
		    // data should probably be cloned to apply scale separately to each instance of a text on different layers
		    // but since text internal content gets only rendered once and then it's never rerendered,
		    // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
		    // Avoiding cloning is preferred since cloning each character shape data is expensive
		    if (data.shapes && data.shapes.length) {
		      var shape = data.shapes[0];
		      if (shape.it) {
		        var shapeItem = shape.it[shape.it.length - 1];
		        if (shapeItem.s) {
		          shapeItem.s.k[0] = scale;
		          shapeItem.s.k[1] = scale;
		        }
		      }
		    }
		    return data;
		  };
		  SVGTextLottieElement.prototype.buildNewText = function () {
		    this.addDynamicProperty(this);
		    var i;
		    var len;
		    var documentData = this.textProperty.currentData;
		    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
		    if (documentData.fc) {
		      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
		    } else {
		      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
		    }
		    if (documentData.sc) {
		      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
		      this.layerElement.setAttribute('stroke-width', documentData.sw);
		    }
		    this.layerElement.setAttribute('font-size', documentData.finalSize);
		    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
		    if (fontData.fClass) {
		      this.layerElement.setAttribute('class', fontData.fClass);
		    } else {
		      this.layerElement.setAttribute('font-family', fontData.fFamily);
		      var fWeight = documentData.fWeight;
		      var fStyle = documentData.fStyle;
		      this.layerElement.setAttribute('font-style', fStyle);
		      this.layerElement.setAttribute('font-weight', fWeight);
		    }
		    this.layerElement.setAttribute('aria-label', documentData.t);
		    var letters = documentData.l || [];
		    var usesGlyphs = !!this.globalData.fontManager.chars;
		    len = letters.length;
		    var tSpan;
		    var matrixHelper = this.mHelper;
		    var shapeStr = '';
		    var singleShape = this.data.singleShape;
		    var xPos = 0;
		    var yPos = 0;
		    var firstLine = true;
		    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
		    if (singleShape && !usesGlyphs && !documentData.sz) {
		      var tElement = this.textContainer;
		      var justify = 'start';
		      switch (documentData.j) {
		        case 1:
		          justify = 'end';
		          break;
		        case 2:
		          justify = 'middle';
		          break;
		        default:
		          justify = 'start';
		          break;
		      }
		      tElement.setAttribute('text-anchor', justify);
		      tElement.setAttribute('letter-spacing', trackingOffset);
		      var textContent = this.buildTextContents(documentData.finalText);
		      len = textContent.length;
		      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
		      for (i = 0; i < len; i += 1) {
		        tSpan = this.textSpans[i].span || createNS('tspan');
		        tSpan.textContent = textContent[i];
		        tSpan.setAttribute('x', 0);
		        tSpan.setAttribute('y', yPos);
		        tSpan.style.display = 'inherit';
		        tElement.appendChild(tSpan);
		        if (!this.textSpans[i]) {
		          this.textSpans[i] = {
		            span: null,
		            glyph: null
		          };
		        }
		        this.textSpans[i].span = tSpan;
		        yPos += documentData.finalLineHeight;
		      }
		      this.layerElement.appendChild(tElement);
		    } else {
		      var cachedSpansLength = this.textSpans.length;
		      var charData;
		      for (i = 0; i < len; i += 1) {
		        if (!this.textSpans[i]) {
		          this.textSpans[i] = {
		            span: null,
		            childSpan: null,
		            glyph: null
		          };
		        }
		        if (!usesGlyphs || !singleShape || i === 0) {
		          tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');
		          if (cachedSpansLength <= i) {
		            tSpan.setAttribute('stroke-linecap', 'butt');
		            tSpan.setAttribute('stroke-linejoin', 'round');
		            tSpan.setAttribute('stroke-miterlimit', '4');
		            this.textSpans[i].span = tSpan;
		            if (usesGlyphs) {
		              var childSpan = createNS('g');
		              tSpan.appendChild(childSpan);
		              this.textSpans[i].childSpan = childSpan;
		            }
		            this.textSpans[i].span = tSpan;
		            this.layerElement.appendChild(tSpan);
		          }
		          tSpan.style.display = 'inherit';
		        }
		        matrixHelper.reset();
		        if (singleShape) {
		          if (letters[i].n) {
		            xPos = -trackingOffset;
		            yPos += documentData.yOffset;
		            yPos += firstLine ? 1 : 0;
		            firstLine = false;
		          }
		          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
		          xPos += letters[i].l || 0;
		          // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
		          xPos += trackingOffset;
		        }
		        if (usesGlyphs) {
		          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
		          var glyphElement;
		          // t === 1 means the character has been replaced with an animated shaped
		          if (charData.t === 1) {
		            glyphElement = new SVGCompElement(charData.data, this.globalData, this);
		          } else {
		            var data = emptyShapeData;
		            if (charData.data && charData.data.shapes) {
		              data = this.buildShapeData(charData.data, documentData.finalSize);
		            }
		            glyphElement = new SVGShapeElement(data, this.globalData, this);
		          }
		          if (this.textSpans[i].glyph) {
		            var glyph = this.textSpans[i].glyph;
		            this.textSpans[i].childSpan.removeChild(glyph.layerElement);
		            glyph.destroy();
		          }
		          this.textSpans[i].glyph = glyphElement;
		          glyphElement._debug = true;
		          glyphElement.prepareFrame(0);
		          glyphElement.renderFrame();
		          this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);
		          // when using animated shapes, the layer will be scaled instead of replacing the internal scale
		          // this might have issues with strokes and might need a different solution
		          if (charData.t === 1) {
		            this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');
		          }
		        } else {
		          if (singleShape) {
		            tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
		          }
		          tSpan.textContent = letters[i].val;
		          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
		        }
		        //
		      }
		      if (singleShape && tSpan) {
		        tSpan.setAttribute('d', shapeStr);
		      }
		    }
		    while (i < this.textSpans.length) {
		      this.textSpans[i].span.style.display = 'none';
		      i += 1;
		    }
		    this._sizeChanged = true;
		  };
		  SVGTextLottieElement.prototype.sourceRectAtTime = function () {
		    this.prepareFrame(this.comp.renderedFrame - this.data.st);
		    this.renderInnerContent();
		    if (this._sizeChanged) {
		      this._sizeChanged = false;
		      var textBox = this.layerElement.getBBox();
		      this.bbox = {
		        top: textBox.y,
		        left: textBox.x,
		        width: textBox.width,
		        height: textBox.height
		      };
		    }
		    return this.bbox;
		  };
		  SVGTextLottieElement.prototype.getValue = function () {
		    var i;
		    var len = this.textSpans.length;
		    var glyphElement;
		    this.renderedFrame = this.comp.renderedFrame;
		    for (i = 0; i < len; i += 1) {
		      glyphElement = this.textSpans[i].glyph;
		      if (glyphElement) {
		        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
		        if (glyphElement._mdf) {
		          this._mdf = true;
		        }
		      }
		    }
		  };
		  SVGTextLottieElement.prototype.renderInnerContent = function () {
		    this.validateText();
		    if (!this.data.singleShape || this._mdf) {
		      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
		      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
		        this._sizeChanged = true;
		        var i;
		        var len;
		        var renderedLetters = this.textAnimator.renderedLetters;
		        var letters = this.textProperty.currentData.l;
		        len = letters.length;
		        var renderedLetter;
		        var textSpan;
		        var glyphElement;
		        for (i = 0; i < len; i += 1) {
		          if (!letters[i].n) {
		            renderedLetter = renderedLetters[i];
		            textSpan = this.textSpans[i].span;
		            glyphElement = this.textSpans[i].glyph;
		            if (glyphElement) {
		              glyphElement.renderFrame();
		            }
		            if (renderedLetter._mdf.m) {
		              textSpan.setAttribute('transform', renderedLetter.m);
		            }
		            if (renderedLetter._mdf.o) {
		              textSpan.setAttribute('opacity', renderedLetter.o);
		            }
		            if (renderedLetter._mdf.sw) {
		              textSpan.setAttribute('stroke-width', renderedLetter.sw);
		            }
		            if (renderedLetter._mdf.sc) {
		              textSpan.setAttribute('stroke', renderedLetter.sc);
		            }
		            if (renderedLetter._mdf.fc) {
		              textSpan.setAttribute('fill', renderedLetter.fc);
		            }
		          }
		        }
		      }
		    }
		  };

		  function ISolidElement(data, globalData, comp) {
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([IImageElement], ISolidElement);
		  ISolidElement.prototype.createContent = function () {
		    var rect = createNS('rect');
		    /// /rect.style.width = this.data.sw;
		    /// /rect.style.height = this.data.sh;
		    /// /rect.style.fill = this.data.sc;
		    rect.setAttribute('width', this.data.sw);
		    rect.setAttribute('height', this.data.sh);
		    rect.setAttribute('fill', this.data.sc);
		    this.layerElement.appendChild(rect);
		  };

		  function NullElement(data, globalData, comp) {
		    this.initFrame();
		    this.initBaseData(data, globalData, comp);
		    this.initFrame();
		    this.initTransform(data, globalData, comp);
		    this.initHierarchy();
		  }
		  NullElement.prototype.prepareFrame = function (num) {
		    this.prepareProperties(num, true);
		  };
		  NullElement.prototype.renderFrame = function () {};
		  NullElement.prototype.getBaseElement = function () {
		    return null;
		  };
		  NullElement.prototype.destroy = function () {};
		  NullElement.prototype.sourceRectAtTime = function () {};
		  NullElement.prototype.hide = function () {};
		  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

		  function SVGRendererBase() {}
		  extendPrototype([BaseRenderer], SVGRendererBase);
		  SVGRendererBase.prototype.createNull = function (data) {
		    return new NullElement(data, this.globalData, this);
		  };
		  SVGRendererBase.prototype.createShape = function (data) {
		    return new SVGShapeElement(data, this.globalData, this);
		  };
		  SVGRendererBase.prototype.createText = function (data) {
		    return new SVGTextLottieElement(data, this.globalData, this);
		  };
		  SVGRendererBase.prototype.createImage = function (data) {
		    return new IImageElement(data, this.globalData, this);
		  };
		  SVGRendererBase.prototype.createSolid = function (data) {
		    return new ISolidElement(data, this.globalData, this);
		  };
		  SVGRendererBase.prototype.configAnimation = function (animData) {
		    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
		    this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
		    if (this.renderConfig.viewBoxSize) {
		      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
		    } else {
		      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
		    }
		    if (!this.renderConfig.viewBoxOnly) {
		      this.svgElement.setAttribute('width', animData.w);
		      this.svgElement.setAttribute('height', animData.h);
		      this.svgElement.style.width = '100%';
		      this.svgElement.style.height = '100%';
		      this.svgElement.style.transform = 'translate3d(0,0,0)';
		      this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
		    }
		    if (this.renderConfig.width) {
		      this.svgElement.setAttribute('width', this.renderConfig.width);
		    }
		    if (this.renderConfig.height) {
		      this.svgElement.setAttribute('height', this.renderConfig.height);
		    }
		    if (this.renderConfig.className) {
		      this.svgElement.setAttribute('class', this.renderConfig.className);
		    }
		    if (this.renderConfig.id) {
		      this.svgElement.setAttribute('id', this.renderConfig.id);
		    }
		    if (this.renderConfig.focusable !== undefined) {
		      this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
		    }
		    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
		    // this.layerElement.style.transform = 'translate3d(0,0,0)';
		    // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
		    this.animationItem.wrapper.appendChild(this.svgElement);
		    // Mask animation
		    var defs = this.globalData.defs;
		    this.setupGlobalData(animData, defs);
		    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
		    this.data = animData;
		    var maskElement = createNS('clipPath');
		    var rect = createNS('rect');
		    rect.setAttribute('width', animData.w);
		    rect.setAttribute('height', animData.h);
		    rect.setAttribute('x', 0);
		    rect.setAttribute('y', 0);
		    var maskId = createElementID();
		    maskElement.setAttribute('id', maskId);
		    maskElement.appendChild(rect);
		    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');
		    defs.appendChild(maskElement);
		    this.layers = animData.layers;
		    this.elements = createSizedArray(animData.layers.length);
		  };
		  SVGRendererBase.prototype.destroy = function () {
		    if (this.animationItem.wrapper) {
		      this.animationItem.wrapper.innerText = '';
		    }
		    this.layerElement = null;
		    this.globalData.defs = null;
		    var i;
		    var len = this.layers ? this.layers.length : 0;
		    for (i = 0; i < len; i += 1) {
		      if (this.elements[i] && this.elements[i].destroy) {
		        this.elements[i].destroy();
		      }
		    }
		    this.elements.length = 0;
		    this.destroyed = true;
		    this.animationItem = null;
		  };
		  SVGRendererBase.prototype.updateContainerSize = function () {};
		  SVGRendererBase.prototype.findIndexByInd = function (ind) {
		    var i = 0;
		    var len = this.layers.length;
		    for (i = 0; i < len; i += 1) {
		      if (this.layers[i].ind === ind) {
		        return i;
		      }
		    }
		    return -1;
		  };
		  SVGRendererBase.prototype.buildItem = function (pos) {
		    var elements = this.elements;
		    if (elements[pos] || this.layers[pos].ty === 99) {
		      return;
		    }
		    elements[pos] = true;
		    var element = this.createItem(this.layers[pos]);
		    elements[pos] = element;
		    if (getExpressionsPlugin()) {
		      if (this.layers[pos].ty === 0) {
		        this.globalData.projectInterface.registerComposition(element);
		      }
		      element.initExpressions();
		    }
		    this.appendElementInPos(element, pos);
		    if (this.layers[pos].tt) {
		      var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
		      if (elementIndex === -1) {
		        return;
		      }
		      if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
		        this.buildItem(elementIndex);
		        this.addPendingElement(element);
		      } else {
		        var matteElement = elements[elementIndex];
		        var matteMask = matteElement.getMatte(this.layers[pos].tt);
		        element.setMatte(matteMask);
		      }
		    }
		  };
		  SVGRendererBase.prototype.checkPendingElements = function () {
		    while (this.pendingElements.length) {
		      var element = this.pendingElements.pop();
		      element.checkParenting();
		      if (element.data.tt) {
		        var i = 0;
		        var len = this.elements.length;
		        while (i < len) {
		          if (this.elements[i] === element) {
		            var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
		            var matteElement = this.elements[elementIndex];
		            var matteMask = matteElement.getMatte(this.layers[i].tt);
		            element.setMatte(matteMask);
		            break;
		          }
		          i += 1;
		        }
		      }
		    }
		  };
		  SVGRendererBase.prototype.renderFrame = function (num) {
		    if (this.renderedFrame === num || this.destroyed) {
		      return;
		    }
		    if (num === null) {
		      num = this.renderedFrame;
		    } else {
		      this.renderedFrame = num;
		    }
		    // console.log('-------');
		    // console.log('FRAME ',num);
		    this.globalData.frameNum = num;
		    this.globalData.frameId += 1;
		    this.globalData.projectInterface.currentFrame = num;
		    this.globalData._mdf = false;
		    var i;
		    var len = this.layers.length;
		    if (!this.completeLayers) {
		      this.checkLayers(num);
		    }
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.completeLayers || this.elements[i]) {
		        this.elements[i].prepareFrame(num - this.layers[i].st);
		      }
		    }
		    if (this.globalData._mdf) {
		      for (i = 0; i < len; i += 1) {
		        if (this.completeLayers || this.elements[i]) {
		          this.elements[i].renderFrame();
		        }
		      }
		    }
		  };
		  SVGRendererBase.prototype.appendElementInPos = function (element, pos) {
		    var newElement = element.getBaseElement();
		    if (!newElement) {
		      return;
		    }
		    var i = 0;
		    var nextElement;
		    while (i < pos) {
		      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
		        nextElement = this.elements[i].getBaseElement();
		      }
		      i += 1;
		    }
		    if (nextElement) {
		      this.layerElement.insertBefore(newElement, nextElement);
		    } else {
		      this.layerElement.appendChild(newElement);
		    }
		  };
		  SVGRendererBase.prototype.hide = function () {
		    this.layerElement.style.display = 'none';
		  };
		  SVGRendererBase.prototype.show = function () {
		    this.layerElement.style.display = 'block';
		  };

		  function ICompElement() {}
		  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
		  ICompElement.prototype.initElement = function (data, globalData, comp) {
		    this.initFrame();
		    this.initBaseData(data, globalData, comp);
		    this.initTransform(data, globalData, comp);
		    this.initRenderable();
		    this.initHierarchy();
		    this.initRendererElement();
		    this.createContainerElements();
		    this.createRenderableComponents();
		    if (this.data.xt || !globalData.progressiveLoad) {
		      this.buildAllItems();
		    }
		    this.hide();
		  };

		  /* ICompElement.prototype.hide = function(){
		      if(!this.hidden){
		          this.hideElement();
		          var i,len = this.elements.length;
		          for( i = 0; i < len; i+=1 ){
		              if(this.elements[i]){
		                  this.elements[i].hide();
		              }
		          }
		      }
		  }; */

		  ICompElement.prototype.prepareFrame = function (num) {
		    this._mdf = false;
		    this.prepareRenderableFrame(num);
		    this.prepareProperties(num, this.isInRange);
		    if (!this.isInRange && !this.data.xt) {
		      return;
		    }
		    if (!this.tm._placeholder) {
		      var timeRemapped = this.tm.v;
		      if (timeRemapped === this.data.op) {
		        timeRemapped = this.data.op - 1;
		      }
		      this.renderedFrame = timeRemapped;
		    } else {
		      this.renderedFrame = num / this.data.sr;
		    }
		    var i;
		    var len = this.elements.length;
		    if (!this.completeLayers) {
		      this.checkLayers(this.renderedFrame);
		    }
		    // This iteration needs to be backwards because of how expressions connect between each other
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.completeLayers || this.elements[i]) {
		        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
		        if (this.elements[i]._mdf) {
		          this._mdf = true;
		        }
		      }
		    }
		  };
		  ICompElement.prototype.renderInnerContent = function () {
		    var i;
		    var len = this.layers.length;
		    for (i = 0; i < len; i += 1) {
		      if (this.completeLayers || this.elements[i]) {
		        this.elements[i].renderFrame();
		      }
		    }
		  };
		  ICompElement.prototype.setElements = function (elems) {
		    this.elements = elems;
		  };
		  ICompElement.prototype.getElements = function () {
		    return this.elements;
		  };
		  ICompElement.prototype.destroyElements = function () {
		    var i;
		    var len = this.layers.length;
		    for (i = 0; i < len; i += 1) {
		      if (this.elements[i]) {
		        this.elements[i].destroy();
		      }
		    }
		  };
		  ICompElement.prototype.destroy = function () {
		    this.destroyElements();
		    this.destroyBaseElement();
		  };

		  function SVGCompElement(data, globalData, comp) {
		    this.layers = data.layers;
		    this.supports3d = true;
		    this.completeLayers = false;
		    this.pendingElements = [];
		    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
		    this.initElement(data, globalData, comp);
		    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
		      _placeholder: true
		    };
		  }
		  extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
		  SVGCompElement.prototype.createComp = function (data) {
		    return new SVGCompElement(data, this.globalData, this);
		  };

		  function SVGRenderer(animationItem, config) {
		    this.animationItem = animationItem;
		    this.layers = null;
		    this.renderedFrame = -1;
		    this.svgElement = createNS('svg');
		    var ariaLabel = '';
		    if (config && config.title) {
		      var titleElement = createNS('title');
		      var titleId = createElementID();
		      titleElement.setAttribute('id', titleId);
		      titleElement.textContent = config.title;
		      this.svgElement.appendChild(titleElement);
		      ariaLabel += titleId;
		    }
		    if (config && config.description) {
		      var descElement = createNS('desc');
		      var descId = createElementID();
		      descElement.setAttribute('id', descId);
		      descElement.textContent = config.description;
		      this.svgElement.appendChild(descElement);
		      ariaLabel += ' ' + descId;
		    }
		    if (ariaLabel) {
		      this.svgElement.setAttribute('aria-labelledby', ariaLabel);
		    }
		    var defs = createNS('defs');
		    this.svgElement.appendChild(defs);
		    var maskElement = createNS('g');
		    this.svgElement.appendChild(maskElement);
		    this.layerElement = maskElement;
		    this.renderConfig = {
		      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
		      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
		      contentVisibility: config && config.contentVisibility || 'visible',
		      progressiveLoad: config && config.progressiveLoad || false,
		      hideOnTransparent: !(config && config.hideOnTransparent === false),
		      viewBoxOnly: config && config.viewBoxOnly || false,
		      viewBoxSize: config && config.viewBoxSize || false,
		      className: config && config.className || '',
		      id: config && config.id || '',
		      focusable: config && config.focusable,
		      filterSize: {
		        width: config && config.filterSize && config.filterSize.width || '100%',
		        height: config && config.filterSize && config.filterSize.height || '100%',
		        x: config && config.filterSize && config.filterSize.x || '0%',
		        y: config && config.filterSize && config.filterSize.y || '0%'
		      },
		      width: config && config.width,
		      height: config && config.height,
		      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
		    };
		    this.globalData = {
		      _mdf: false,
		      frameNum: -1,
		      defs: defs,
		      renderConfig: this.renderConfig
		    };
		    this.elements = [];
		    this.pendingElements = [];
		    this.destroyed = false;
		    this.rendererType = 'svg';
		  }
		  extendPrototype([SVGRendererBase], SVGRenderer);
		  SVGRenderer.prototype.createComp = function (data) {
		    return new SVGCompElement(data, this.globalData, this);
		  };

		  function ShapeTransformManager() {
		    this.sequences = {};
		    this.sequenceList = [];
		    this.transform_key_count = 0;
		  }
		  ShapeTransformManager.prototype = {
		    addTransformSequence: function addTransformSequence(transforms) {
		      var i;
		      var len = transforms.length;
		      var key = '_';
		      for (i = 0; i < len; i += 1) {
		        key += transforms[i].transform.key + '_';
		      }
		      var sequence = this.sequences[key];
		      if (!sequence) {
		        sequence = {
		          transforms: [].concat(transforms),
		          finalTransform: new Matrix(),
		          _mdf: false
		        };
		        this.sequences[key] = sequence;
		        this.sequenceList.push(sequence);
		      }
		      return sequence;
		    },
		    processSequence: function processSequence(sequence, isFirstFrame) {
		      var i = 0;
		      var len = sequence.transforms.length;
		      var _mdf = isFirstFrame;
		      while (i < len && !isFirstFrame) {
		        if (sequence.transforms[i].transform.mProps._mdf) {
		          _mdf = true;
		          break;
		        }
		        i += 1;
		      }
		      if (_mdf) {
		        sequence.finalTransform.reset();
		        for (i = len - 1; i >= 0; i -= 1) {
		          sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
		        }
		      }
		      sequence._mdf = _mdf;
		    },
		    processSequences: function processSequences(isFirstFrame) {
		      var i;
		      var len = this.sequenceList.length;
		      for (i = 0; i < len; i += 1) {
		        this.processSequence(this.sequenceList[i], isFirstFrame);
		      }
		    },
		    getNewKey: function getNewKey() {
		      this.transform_key_count += 1;
		      return '_' + this.transform_key_count;
		    }
		  };

		  var lumaLoader = function lumaLoader() {
		    var id = '__lottie_element_luma_buffer';
		    var lumaBuffer = null;
		    var lumaBufferCtx = null;
		    var svg = null;

		    // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
		    // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
		    // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
		    // Naming it solution 2 to mark the extra comment lines.
		    /*
		    var svgString = [
		      '<svg xmlns="http://www.w3.org/2000/svg">',
		      '<filter id="' + id + '">',
		      '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
		      '0.3, 0.3, 0.3, 0, 0, ',
		      '0.3, 0.3, 0.3, 0, 0, ',
		      '0.3, 0.3, 0.3, 0, 0, ',
		      '0.3, 0.3, 0.3, 0, 0',
		      '"/>',
		      '</filter>',
		      '</svg>',
		    ].join('');
		    var blob = new Blob([svgString], { type: 'image/svg+xml' });
		    var url = URL.createObjectURL(blob);
		    */

		    function createLumaSvgFilter() {
		      var _svg = createNS('svg');
		      var fil = createNS('filter');
		      var matrix = createNS('feColorMatrix');
		      fil.setAttribute('id', id);
		      matrix.setAttribute('type', 'matrix');
		      matrix.setAttribute('color-interpolation-filters', 'sRGB');
		      matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');
		      fil.appendChild(matrix);
		      _svg.appendChild(fil);
		      _svg.setAttribute('id', id + '_svg');
		      if (featureSupport.svgLumaHidden) {
		        _svg.style.display = 'none';
		      }
		      return _svg;
		    }
		    function loadLuma() {
		      if (!lumaBuffer) {
		        svg = createLumaSvgFilter();
		        document.body.appendChild(svg);
		        lumaBuffer = createTag('canvas');
		        lumaBufferCtx = lumaBuffer.getContext('2d');
		        // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
		        lumaBufferCtx.filter = 'url(#' + id + ')';
		        lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';
		        lumaBufferCtx.fillRect(0, 0, 1, 1);
		      }
		    }
		    function getLuma(canvas) {
		      if (!lumaBuffer) {
		        loadLuma();
		      }
		      lumaBuffer.width = canvas.width;
		      lumaBuffer.height = canvas.height;
		      // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
		      lumaBufferCtx.filter = 'url(#' + id + ')';
		      return lumaBuffer;
		    }
		    return {
		      load: loadLuma,
		      get: getLuma
		    };
		  };
		  function createCanvas(width, height) {
		    if (featureSupport.offscreenCanvas) {
		      return new OffscreenCanvas(width, height);
		    }
		    var canvas = createTag('canvas');
		    canvas.width = width;
		    canvas.height = height;
		    return canvas;
		  }
		  var assetLoader = function () {
		    return {
		      loadLumaCanvas: lumaLoader.load,
		      getLumaCanvas: lumaLoader.get,
		      createCanvas: createCanvas
		    };
		  }();

		  var registeredEffects = {};
		  function CVEffects(elem) {
		    var i;
		    var len = elem.data.ef ? elem.data.ef.length : 0;
		    this.filters = [];
		    var filterManager;
		    for (i = 0; i < len; i += 1) {
		      filterManager = null;
		      var type = elem.data.ef[i].ty;
		      if (registeredEffects[type]) {
		        var Effect = registeredEffects[type].effect;
		        filterManager = new Effect(elem.effectsManager.effectElements[i], elem);
		      }
		      if (filterManager) {
		        this.filters.push(filterManager);
		      }
		    }
		    if (this.filters.length) {
		      elem.addRenderableComponent(this);
		    }
		  }
		  CVEffects.prototype.renderFrame = function (_isFirstFrame) {
		    var i;
		    var len = this.filters.length;
		    for (i = 0; i < len; i += 1) {
		      this.filters[i].renderFrame(_isFirstFrame);
		    }
		  };
		  CVEffects.prototype.getEffects = function (type) {
		    var i;
		    var len = this.filters.length;
		    var effects = [];
		    for (i = 0; i < len; i += 1) {
		      if (this.filters[i].type === type) {
		        effects.push(this.filters[i]);
		      }
		    }
		    return effects;
		  };
		  function registerEffect(id, effect) {
		    registeredEffects[id] = {
		      effect: effect
		    };
		  }

		  function CVMaskElement(data, element) {
		    this.data = data;
		    this.element = element;
		    this.masksProperties = this.data.masksProperties || [];
		    this.viewData = createSizedArray(this.masksProperties.length);
		    var i;
		    var len = this.masksProperties.length;
		    var hasMasks = false;
		    for (i = 0; i < len; i += 1) {
		      if (this.masksProperties[i].mode !== 'n') {
		        hasMasks = true;
		      }
		      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
		    }
		    this.hasMasks = hasMasks;
		    if (hasMasks) {
		      this.element.addRenderableComponent(this);
		    }
		  }
		  CVMaskElement.prototype.renderFrame = function () {
		    if (!this.hasMasks) {
		      return;
		    }
		    var transform = this.element.finalTransform.mat;
		    var ctx = this.element.canvasContext;
		    var i;
		    var len = this.masksProperties.length;
		    var pt;
		    var pts;
		    var data;
		    ctx.beginPath();
		    for (i = 0; i < len; i += 1) {
		      if (this.masksProperties[i].mode !== 'n') {
		        if (this.masksProperties[i].inv) {
		          ctx.moveTo(0, 0);
		          ctx.lineTo(this.element.globalData.compSize.w, 0);
		          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
		          ctx.lineTo(0, this.element.globalData.compSize.h);
		          ctx.lineTo(0, 0);
		        }
		        data = this.viewData[i].v;
		        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
		        ctx.moveTo(pt[0], pt[1]);
		        var j;
		        var jLen = data._length;
		        for (j = 1; j < jLen; j += 1) {
		          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
		          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
		        }
		        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
		        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
		      }
		    }
		    this.element.globalData.renderer.save(true);
		    ctx.clip();
		  };
		  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
		  CVMaskElement.prototype.destroy = function () {
		    this.element = null;
		  };

		  function CVBaseElement() {}
		  var operationsMap = {
		    1: 'source-in',
		    2: 'source-out',
		    3: 'source-in',
		    4: 'source-out'
		  };
		  CVBaseElement.prototype = {
		    createElements: function createElements() {},
		    initRendererElement: function initRendererElement() {},
		    createContainerElements: function createContainerElements() {
		      // If the layer is masked we will use two buffers to store each different states of the drawing
		      // This solution is not ideal for several reason. But unfortunately, because of the recursive
		      // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
		      // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
		      // It might be challenging because the layer most likely is transformed in some way
		      if (this.data.tt >= 1) {
		        this.buffers = [];
		        var canvasContext = this.globalData.canvasContext;
		        var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
		        this.buffers.push(bufferCanvas);
		        var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
		        this.buffers.push(bufferCanvas2);
		        if (this.data.tt >= 3 && !document._isProxy) {
		          assetLoader.loadLumaCanvas();
		        }
		      }
		      this.canvasContext = this.globalData.canvasContext;
		      this.transformCanvas = this.globalData.transformCanvas;
		      this.renderableEffectsManager = new CVEffects(this);
		      this.searchEffectTransforms();
		    },
		    createContent: function createContent() {},
		    setBlendMode: function setBlendMode() {
		      var globalData = this.globalData;
		      if (globalData.blendMode !== this.data.bm) {
		        globalData.blendMode = this.data.bm;
		        var blendModeValue = getBlendMode(this.data.bm);
		        globalData.canvasContext.globalCompositeOperation = blendModeValue;
		      }
		    },
		    createRenderableComponents: function createRenderableComponents() {
		      this.maskManager = new CVMaskElement(this.data, this);
		      this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
		    },
		    hideElement: function hideElement() {
		      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
		        this.hidden = true;
		      }
		    },
		    showElement: function showElement() {
		      if (this.isInRange && !this.isTransparent) {
		        this.hidden = false;
		        this._isFirstFrame = true;
		        this.maskManager._isFirstFrame = true;
		      }
		    },
		    clearCanvas: function clearCanvas(canvasContext) {
		      canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
		    },
		    prepareLayer: function prepareLayer() {
		      if (this.data.tt >= 1) {
		        var buffer = this.buffers[0];
		        var bufferCtx = buffer.getContext('2d');
		        this.clearCanvas(bufferCtx);
		        // on the first buffer we store the current state of the global drawing
		        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
		        // The next four lines are to clear the canvas
		        // TODO: Check if there is a way to clear the canvas without resetting the transform
		        this.currentTransform = this.canvasContext.getTransform();
		        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
		        this.clearCanvas(this.canvasContext);
		        this.canvasContext.setTransform(this.currentTransform);
		      }
		    },
		    exitLayer: function exitLayer() {
		      if (this.data.tt >= 1) {
		        var buffer = this.buffers[1];
		        // On the second buffer we store the current state of the global drawing
		        // that only contains the content of this layer
		        // (if it is a composition, it also includes the nested layers)
		        var bufferCtx = buffer.getContext('2d');
		        this.clearCanvas(bufferCtx);
		        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
		        // We clear the canvas again
		        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
		        this.clearCanvas(this.canvasContext);
		        this.canvasContext.setTransform(this.currentTransform);
		        // We draw the mask
		        var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);
		        mask.renderFrame(true);
		        // We draw the second buffer (that contains the content of this layer)
		        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);

		        // If the mask is a Luma matte, we need to do two extra painting operations
		        // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error
		        if (this.data.tt >= 3 && !document._isProxy) {
		          // We copy the painted mask to a buffer that has a color matrix filter applied to it
		          // that applies the rgb values to the alpha channel
		          var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
		          var lumaBufferCtx = lumaBuffer.getContext('2d');
		          lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
		          this.clearCanvas(this.canvasContext);
		          // we repaint the context with the mask applied to it
		          this.canvasContext.drawImage(lumaBuffer, 0, 0);
		        }
		        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
		        this.canvasContext.drawImage(buffer, 0, 0);
		        // We finally draw the first buffer (that contains the content of the global drawing)
		        // We use destination-over to draw the global drawing below the current layer
		        this.canvasContext.globalCompositeOperation = 'destination-over';
		        this.canvasContext.drawImage(this.buffers[0], 0, 0);
		        this.canvasContext.setTransform(this.currentTransform);
		        // We reset the globalCompositeOperation to source-over, the standard type of operation
		        this.canvasContext.globalCompositeOperation = 'source-over';
		      }
		    },
		    renderFrame: function renderFrame(forceRender) {
		      if (this.hidden || this.data.hd) {
		        return;
		      }
		      if (this.data.td === 1 && !forceRender) {
		        return;
		      }
		      this.renderTransform();
		      this.renderRenderable();
		      this.renderLocalTransform();
		      this.setBlendMode();
		      var forceRealStack = this.data.ty === 0;
		      this.prepareLayer();
		      this.globalData.renderer.save(forceRealStack);
		      this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
		      this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
		      this.renderInnerContent();
		      this.globalData.renderer.restore(forceRealStack);
		      this.exitLayer();
		      if (this.maskManager.hasMasks) {
		        this.globalData.renderer.restore(true);
		      }
		      if (this._isFirstFrame) {
		        this._isFirstFrame = false;
		      }
		    },
		    destroy: function destroy() {
		      this.canvasContext = null;
		      this.data = null;
		      this.globalData = null;
		      this.maskManager.destroy();
		    },
		    mHelper: new Matrix()
		  };
		  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
		  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

		  function CVShapeData(element, data, styles, transformsManager) {
		    this.styledShapes = [];
		    this.tr = [0, 0, 0, 0, 0, 0];
		    var ty = 4;
		    if (data.ty === 'rc') {
		      ty = 5;
		    } else if (data.ty === 'el') {
		      ty = 6;
		    } else if (data.ty === 'sr') {
		      ty = 7;
		    }
		    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
		    var i;
		    var len = styles.length;
		    var styledShape;
		    for (i = 0; i < len; i += 1) {
		      if (!styles[i].closed) {
		        styledShape = {
		          transforms: transformsManager.addTransformSequence(styles[i].transforms),
		          trNodes: []
		        };
		        this.styledShapes.push(styledShape);
		        styles[i].elements.push(styledShape);
		      }
		    }
		  }
		  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

		  function CVShapeElement(data, globalData, comp) {
		    this.shapes = [];
		    this.shapesData = data.shapes;
		    this.stylesList = [];
		    this.itemsData = [];
		    this.prevViewData = [];
		    this.shapeModifiers = [];
		    this.processedElements = [];
		    this.transformsManager = new ShapeTransformManager();
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
		  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
		  CVShapeElement.prototype.transformHelper = {
		    opacity: 1,
		    _opMdf: false
		  };
		  CVShapeElement.prototype.dashResetter = [];
		  CVShapeElement.prototype.createContent = function () {
		    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
		  };
		  CVShapeElement.prototype.createStyleElement = function (data, transforms) {
		    var styleElem = {
		      data: data,
		      type: data.ty,
		      preTransforms: this.transformsManager.addTransformSequence(transforms),
		      transforms: [],
		      elements: [],
		      closed: data.hd === true
		    };
		    var elementData = {};
		    if (data.ty === 'fl' || data.ty === 'st') {
		      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
		      if (!elementData.c.k) {
		        styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
		      }
		    } else if (data.ty === 'gf' || data.ty === 'gs') {
		      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
		      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
		      elementData.h = PropertyFactory.getProp(this, data.h || {
		        k: 0
		      }, 0, 0.01, this);
		      elementData.a = PropertyFactory.getProp(this, data.a || {
		        k: 0
		      }, 0, degToRads, this);
		      elementData.g = new GradientProperty(this, data.g, this);
		    }
		    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
		    if (data.ty === 'st' || data.ty === 'gs') {
		      styleElem.lc = lineCapEnum[data.lc || 2];
		      styleElem.lj = lineJoinEnum[data.lj || 2];
		      if (data.lj == 1) {
		        // eslint-disable-line eqeqeq
		        styleElem.ml = data.ml;
		      }
		      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
		      if (!elementData.w.k) {
		        styleElem.wi = elementData.w.v;
		      }
		      if (data.d) {
		        var d = new DashProperty(this, data.d, 'canvas', this);
		        elementData.d = d;
		        if (!elementData.d.k) {
		          styleElem.da = elementData.d.dashArray;
		          styleElem["do"] = elementData.d.dashoffset[0];
		        }
		      }
		    } else {
		      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
		    }
		    this.stylesList.push(styleElem);
		    elementData.style = styleElem;
		    return elementData;
		  };
		  CVShapeElement.prototype.createGroupElement = function () {
		    var elementData = {
		      it: [],
		      prevViewData: []
		    };
		    return elementData;
		  };
		  CVShapeElement.prototype.createTransformElement = function (data) {
		    var elementData = {
		      transform: {
		        opacity: 1,
		        _opMdf: false,
		        key: this.transformsManager.getNewKey(),
		        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
		        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
		      }
		    };
		    return elementData;
		  };
		  CVShapeElement.prototype.createShapeElement = function (data) {
		    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
		    this.shapes.push(elementData);
		    this.addShapeToModifiers(elementData);
		    return elementData;
		  };
		  CVShapeElement.prototype.reloadShapes = function () {
		    this._isFirstFrame = true;
		    var i;
		    var len = this.itemsData.length;
		    for (i = 0; i < len; i += 1) {
		      this.prevViewData[i] = this.itemsData[i];
		    }
		    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
		    len = this.dynamicProperties.length;
		    for (i = 0; i < len; i += 1) {
		      this.dynamicProperties[i].getValue();
		    }
		    this.renderModifiers();
		    this.transformsManager.processSequences(this._isFirstFrame);
		  };
		  CVShapeElement.prototype.addTransformToStyleList = function (transform) {
		    var i;
		    var len = this.stylesList.length;
		    for (i = 0; i < len; i += 1) {
		      if (!this.stylesList[i].closed) {
		        this.stylesList[i].transforms.push(transform);
		      }
		    }
		  };
		  CVShapeElement.prototype.removeTransformFromStyleList = function () {
		    var i;
		    var len = this.stylesList.length;
		    for (i = 0; i < len; i += 1) {
		      if (!this.stylesList[i].closed) {
		        this.stylesList[i].transforms.pop();
		      }
		    }
		  };
		  CVShapeElement.prototype.closeStyles = function (styles) {
		    var i;
		    var len = styles.length;
		    for (i = 0; i < len; i += 1) {
		      styles[i].closed = true;
		    }
		  };
		  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
		    var i;
		    var len = arr.length - 1;
		    var j;
		    var jLen;
		    var ownStyles = [];
		    var ownModifiers = [];
		    var processedPos;
		    var modifier;
		    var currentTransform;
		    var ownTransforms = [].concat(transforms);
		    for (i = len; i >= 0; i -= 1) {
		      processedPos = this.searchProcessedElement(arr[i]);
		      if (!processedPos) {
		        arr[i]._shouldRender = shouldRender;
		      } else {
		        itemsData[i] = prevViewData[processedPos - 1];
		      }
		      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
		        if (!processedPos) {
		          itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
		        } else {
		          itemsData[i].style.closed = false;
		        }
		        ownStyles.push(itemsData[i].style);
		      } else if (arr[i].ty === 'gr') {
		        if (!processedPos) {
		          itemsData[i] = this.createGroupElement(arr[i]);
		        } else {
		          jLen = itemsData[i].it.length;
		          for (j = 0; j < jLen; j += 1) {
		            itemsData[i].prevViewData[j] = itemsData[i].it[j];
		          }
		        }
		        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
		      } else if (arr[i].ty === 'tr') {
		        if (!processedPos) {
		          currentTransform = this.createTransformElement(arr[i]);
		          itemsData[i] = currentTransform;
		        }
		        ownTransforms.push(itemsData[i]);
		        this.addTransformToStyleList(itemsData[i]);
		      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
		        if (!processedPos) {
		          itemsData[i] = this.createShapeElement(arr[i]);
		        }
		      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
		        if (!processedPos) {
		          modifier = ShapeModifiers.getModifier(arr[i].ty);
		          modifier.init(this, arr[i]);
		          itemsData[i] = modifier;
		          this.shapeModifiers.push(modifier);
		        } else {
		          modifier = itemsData[i];
		          modifier.closed = false;
		        }
		        ownModifiers.push(modifier);
		      } else if (arr[i].ty === 'rp') {
		        if (!processedPos) {
		          modifier = ShapeModifiers.getModifier(arr[i].ty);
		          itemsData[i] = modifier;
		          modifier.init(this, arr, i, itemsData);
		          this.shapeModifiers.push(modifier);
		          shouldRender = false;
		        } else {
		          modifier = itemsData[i];
		          modifier.closed = true;
		        }
		        ownModifiers.push(modifier);
		      }
		      this.addProcessedElement(arr[i], i + 1);
		    }
		    this.removeTransformFromStyleList();
		    this.closeStyles(ownStyles);
		    len = ownModifiers.length;
		    for (i = 0; i < len; i += 1) {
		      ownModifiers[i].closed = true;
		    }
		  };
		  CVShapeElement.prototype.renderInnerContent = function () {
		    this.transformHelper.opacity = 1;
		    this.transformHelper._opMdf = false;
		    this.renderModifiers();
		    this.transformsManager.processSequences(this._isFirstFrame);
		    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
		  };
		  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
		    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
		      groupTransform.opacity = parentTransform.opacity;
		      groupTransform.opacity *= groupTransform.op.v;
		      groupTransform._opMdf = true;
		    }
		  };
		  CVShapeElement.prototype.drawLayer = function () {
		    var i;
		    var len = this.stylesList.length;
		    var j;
		    var jLen;
		    var k;
		    var kLen;
		    var elems;
		    var nodes;
		    var renderer = this.globalData.renderer;
		    var ctx = this.globalData.canvasContext;
		    var type;
		    var currentStyle;
		    for (i = 0; i < len; i += 1) {
		      currentStyle = this.stylesList[i];
		      type = currentStyle.type;

		      // Skipping style when
		      // Stroke width equals 0
		      // style should not be rendered (extra unused repeaters)
		      // current opacity equals 0
		      // global opacity equals 0
		      if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
		        renderer.save();
		        elems = currentStyle.elements;
		        if (type === 'st' || type === 'gs') {
		          renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd);
		          // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
		          renderer.ctxLineWidth(currentStyle.wi);
		          // ctx.lineWidth = currentStyle.wi;
		          renderer.ctxLineCap(currentStyle.lc);
		          // ctx.lineCap = currentStyle.lc;
		          renderer.ctxLineJoin(currentStyle.lj);
		          // ctx.lineJoin = currentStyle.lj;
		          renderer.ctxMiterLimit(currentStyle.ml || 0);
		          // ctx.miterLimit = currentStyle.ml || 0;
		        } else {
		          renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd);
		          // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
		        }
		        renderer.ctxOpacity(currentStyle.coOp);
		        if (type !== 'st' && type !== 'gs') {
		          ctx.beginPath();
		        }
		        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
		        jLen = elems.length;
		        for (j = 0; j < jLen; j += 1) {
		          if (type === 'st' || type === 'gs') {
		            ctx.beginPath();
		            if (currentStyle.da) {
		              ctx.setLineDash(currentStyle.da);
		              ctx.lineDashOffset = currentStyle["do"];
		            }
		          }
		          nodes = elems[j].trNodes;
		          kLen = nodes.length;
		          for (k = 0; k < kLen; k += 1) {
		            if (nodes[k].t === 'm') {
		              ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
		            } else if (nodes[k].t === 'c') {
		              ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
		            } else {
		              ctx.closePath();
		            }
		          }
		          if (type === 'st' || type === 'gs') {
		            // ctx.stroke();
		            renderer.ctxStroke();
		            if (currentStyle.da) {
		              ctx.setLineDash(this.dashResetter);
		            }
		          }
		        }
		        if (type !== 'st' && type !== 'gs') {
		          // ctx.fill(currentStyle.r);
		          this.globalData.renderer.ctxFill(currentStyle.r);
		        }
		        renderer.restore();
		      }
		    }
		  };
		  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
		    var i;
		    var len = items.length - 1;
		    var groupTransform;
		    groupTransform = parentTransform;
		    for (i = len; i >= 0; i -= 1) {
		      if (items[i].ty === 'tr') {
		        groupTransform = data[i].transform;
		        this.renderShapeTransform(parentTransform, groupTransform);
		      } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
		        this.renderPath(items[i], data[i]);
		      } else if (items[i].ty === 'fl') {
		        this.renderFill(items[i], data[i], groupTransform);
		      } else if (items[i].ty === 'st') {
		        this.renderStroke(items[i], data[i], groupTransform);
		      } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
		        this.renderGradientFill(items[i], data[i], groupTransform);
		      } else if (items[i].ty === 'gr') {
		        this.renderShape(groupTransform, items[i].it, data[i].it);
		      } else if (items[i].ty === 'tm') ;
		    }
		    if (isMain) {
		      this.drawLayer();
		    }
		  };
		  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
		    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
		      var shapeNodes = styledShape.trNodes;
		      var paths = shape.paths;
		      var i;
		      var len;
		      var j;
		      var jLen = paths._length;
		      shapeNodes.length = 0;
		      var groupTransformMat = styledShape.transforms.finalTransform;
		      for (j = 0; j < jLen; j += 1) {
		        var pathNodes = paths.shapes[j];
		        if (pathNodes && pathNodes.v) {
		          len = pathNodes._length;
		          for (i = 1; i < len; i += 1) {
		            if (i === 1) {
		              shapeNodes.push({
		                t: 'm',
		                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
		              });
		            }
		            shapeNodes.push({
		              t: 'c',
		              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
		            });
		          }
		          if (len === 1) {
		            shapeNodes.push({
		              t: 'm',
		              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
		            });
		          }
		          if (pathNodes.c && len) {
		            shapeNodes.push({
		              t: 'c',
		              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
		            });
		            shapeNodes.push({
		              t: 'z'
		            });
		          }
		        }
		      }
		      styledShape.trNodes = shapeNodes;
		    }
		  };
		  CVShapeElement.prototype.renderPath = function (pathData, itemData) {
		    if (pathData.hd !== true && pathData._shouldRender) {
		      var i;
		      var len = itemData.styledShapes.length;
		      for (i = 0; i < len; i += 1) {
		        this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
		      }
		    }
		  };
		  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
		    var styleElem = itemData.style;
		    if (itemData.c._mdf || this._isFirstFrame) {
		      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
		    }
		    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
		      styleElem.coOp = itemData.o.v * groupTransform.opacity;
		    }
		  };
		  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
		    var styleElem = itemData.style;
		    var grd;
		    if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
		      var ctx = this.globalData.canvasContext;
		      var pt1 = itemData.s.v;
		      var pt2 = itemData.e.v;
		      if (styleData.t === 1) {
		        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
		      } else {
		        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
		        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
		        var percent = itemData.h.v;
		        if (percent >= 1) {
		          percent = 0.99;
		        } else if (percent <= -1) {
		          percent = -0.99;
		        }
		        var dist = rad * percent;
		        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
		        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
		        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
		      }
		      var i;
		      var len = styleData.g.p;
		      var cValues = itemData.g.c;
		      var opacity = 1;
		      for (i = 0; i < len; i += 1) {
		        if (itemData.g._hasOpacity && itemData.g._collapsable) {
		          opacity = itemData.g.o[i * 2 + 1];
		        }
		        grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
		      }
		      styleElem.grd = grd;
		    }
		    styleElem.coOp = itemData.o.v * groupTransform.opacity;
		  };
		  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
		    var styleElem = itemData.style;
		    var d = itemData.d;
		    if (d && (d._mdf || this._isFirstFrame)) {
		      styleElem.da = d.dashArray;
		      styleElem["do"] = d.dashoffset[0];
		    }
		    if (itemData.c._mdf || this._isFirstFrame) {
		      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
		    }
		    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
		      styleElem.coOp = itemData.o.v * groupTransform.opacity;
		    }
		    if (itemData.w._mdf || this._isFirstFrame) {
		      styleElem.wi = itemData.w.v;
		    }
		  };
		  CVShapeElement.prototype.destroy = function () {
		    this.shapesData = null;
		    this.globalData = null;
		    this.canvasContext = null;
		    this.stylesList.length = 0;
		    this.itemsData.length = 0;
		  };

		  function CVTextElement(data, globalData, comp) {
		    this.textSpans = [];
		    this.yOffset = 0;
		    this.fillColorAnim = false;
		    this.strokeColorAnim = false;
		    this.strokeWidthAnim = false;
		    this.stroke = false;
		    this.fill = false;
		    this.justifyOffset = 0;
		    this.currentRender = null;
		    this.renderType = 'canvas';
		    this.values = {
		      fill: 'rgba(0,0,0,0)',
		      stroke: 'rgba(0,0,0,0)',
		      sWidth: 0,
		      fValue: ''
		    };
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
		  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');
		  CVTextElement.prototype.buildNewText = function () {
		    var documentData = this.textProperty.currentData;
		    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
		    var hasFill = false;
		    if (documentData.fc) {
		      hasFill = true;
		      this.values.fill = this.buildColor(documentData.fc);
		    } else {
		      this.values.fill = 'rgba(0,0,0,0)';
		    }
		    this.fill = hasFill;
		    var hasStroke = false;
		    if (documentData.sc) {
		      hasStroke = true;
		      this.values.stroke = this.buildColor(documentData.sc);
		      this.values.sWidth = documentData.sw;
		    }
		    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
		    var i;
		    var len;
		    var letters = documentData.l;
		    var matrixHelper = this.mHelper;
		    this.stroke = hasStroke;
		    this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
		    len = documentData.finalText.length;
		    // this.tHelper.font = this.values.fValue;
		    var charData;
		    var shapeData;
		    var k;
		    var kLen;
		    var shapes;
		    var j;
		    var jLen;
		    var pathNodes;
		    var commands;
		    var pathArr;
		    var singleShape = this.data.singleShape;
		    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
		    var xPos = 0;
		    var yPos = 0;
		    var firstLine = true;
		    var cnt = 0;
		    for (i = 0; i < len; i += 1) {
		      charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
		      shapeData = charData && charData.data || {};
		      matrixHelper.reset();
		      if (singleShape && letters[i].n) {
		        xPos = -trackingOffset;
		        yPos += documentData.yOffset;
		        yPos += firstLine ? 1 : 0;
		        firstLine = false;
		      }
		      shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
		      jLen = shapes.length;
		      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
		      if (singleShape) {
		        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
		      }
		      commands = createSizedArray(jLen - 1);
		      var commandsCounter = 0;
		      for (j = 0; j < jLen; j += 1) {
		        if (shapes[j].ty === 'sh') {
		          kLen = shapes[j].ks.k.i.length;
		          pathNodes = shapes[j].ks.k;
		          pathArr = [];
		          for (k = 1; k < kLen; k += 1) {
		            if (k === 1) {
		              pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
		            }
		            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
		          }
		          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
		          commands[commandsCounter] = pathArr;
		          commandsCounter += 1;
		        }
		      }
		      if (singleShape) {
		        xPos += letters[i].l;
		        xPos += trackingOffset;
		      }
		      if (this.textSpans[cnt]) {
		        this.textSpans[cnt].elem = commands;
		      } else {
		        this.textSpans[cnt] = {
		          elem: commands
		        };
		      }
		      cnt += 1;
		    }
		  };
		  CVTextElement.prototype.renderInnerContent = function () {
		    this.validateText();
		    var ctx = this.canvasContext;
		    ctx.font = this.values.fValue;
		    this.globalData.renderer.ctxLineCap('butt');
		    // ctx.lineCap = 'butt';
		    this.globalData.renderer.ctxLineJoin('miter');
		    // ctx.lineJoin = 'miter';
		    this.globalData.renderer.ctxMiterLimit(4);
		    // ctx.miterLimit = 4;

		    if (!this.data.singleShape) {
		      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
		    }
		    var i;
		    var len;
		    var j;
		    var jLen;
		    var k;
		    var kLen;
		    var renderedLetters = this.textAnimator.renderedLetters;
		    var letters = this.textProperty.currentData.l;
		    len = letters.length;
		    var renderedLetter;
		    var lastFill = null;
		    var lastStroke = null;
		    var lastStrokeW = null;
		    var commands;
		    var pathArr;
		    var renderer = this.globalData.renderer;
		    for (i = 0; i < len; i += 1) {
		      if (!letters[i].n) {
		        renderedLetter = renderedLetters[i];
		        if (renderedLetter) {
		          renderer.save();
		          renderer.ctxTransform(renderedLetter.p);
		          renderer.ctxOpacity(renderedLetter.o);
		        }
		        if (this.fill) {
		          if (renderedLetter && renderedLetter.fc) {
		            if (lastFill !== renderedLetter.fc) {
		              renderer.ctxFillStyle(renderedLetter.fc);
		              lastFill = renderedLetter.fc;
		              // ctx.fillStyle = renderedLetter.fc;
		            }
		          } else if (lastFill !== this.values.fill) {
		            lastFill = this.values.fill;
		            renderer.ctxFillStyle(this.values.fill);
		            // ctx.fillStyle = this.values.fill;
		          }
		          commands = this.textSpans[i].elem;
		          jLen = commands.length;
		          this.globalData.canvasContext.beginPath();
		          for (j = 0; j < jLen; j += 1) {
		            pathArr = commands[j];
		            kLen = pathArr.length;
		            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
		            for (k = 2; k < kLen; k += 6) {
		              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
		            }
		          }
		          this.globalData.canvasContext.closePath();
		          renderer.ctxFill();
		          // this.globalData.canvasContext.fill();
		          /// ctx.fillText(this.textSpans[i].val,0,0);
		        }
		        if (this.stroke) {
		          if (renderedLetter && renderedLetter.sw) {
		            if (lastStrokeW !== renderedLetter.sw) {
		              lastStrokeW = renderedLetter.sw;
		              renderer.ctxLineWidth(renderedLetter.sw);
		              // ctx.lineWidth = renderedLetter.sw;
		            }
		          } else if (lastStrokeW !== this.values.sWidth) {
		            lastStrokeW = this.values.sWidth;
		            renderer.ctxLineWidth(this.values.sWidth);
		            // ctx.lineWidth = this.values.sWidth;
		          }
		          if (renderedLetter && renderedLetter.sc) {
		            if (lastStroke !== renderedLetter.sc) {
		              lastStroke = renderedLetter.sc;
		              renderer.ctxStrokeStyle(renderedLetter.sc);
		              // ctx.strokeStyle = renderedLetter.sc;
		            }
		          } else if (lastStroke !== this.values.stroke) {
		            lastStroke = this.values.stroke;
		            renderer.ctxStrokeStyle(this.values.stroke);
		            // ctx.strokeStyle = this.values.stroke;
		          }
		          commands = this.textSpans[i].elem;
		          jLen = commands.length;
		          this.globalData.canvasContext.beginPath();
		          for (j = 0; j < jLen; j += 1) {
		            pathArr = commands[j];
		            kLen = pathArr.length;
		            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
		            for (k = 2; k < kLen; k += 6) {
		              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
		            }
		          }
		          this.globalData.canvasContext.closePath();
		          renderer.ctxStroke();
		          // this.globalData.canvasContext.stroke();
		          /// ctx.strokeText(letters[i].val,0,0);
		        }
		        if (renderedLetter) {
		          this.globalData.renderer.restore();
		        }
		      }
		    }
		  };

		  function CVImageElement(data, globalData, comp) {
		    this.assetData = globalData.getAssetData(data.refId);
		    this.img = globalData.imageLoader.getAsset(this.assetData);
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
		  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
		  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
		  CVImageElement.prototype.createContent = function () {
		    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
		      var canvas = createTag('canvas');
		      canvas.width = this.assetData.w;
		      canvas.height = this.assetData.h;
		      var ctx = canvas.getContext('2d');
		      var imgW = this.img.width;
		      var imgH = this.img.height;
		      var imgRel = imgW / imgH;
		      var canvasRel = this.assetData.w / this.assetData.h;
		      var widthCrop;
		      var heightCrop;
		      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
		      if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
		        heightCrop = imgH;
		        widthCrop = heightCrop * canvasRel;
		      } else {
		        widthCrop = imgW;
		        heightCrop = widthCrop / canvasRel;
		      }
		      ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
		      this.img = canvas;
		    }
		  };
		  CVImageElement.prototype.renderInnerContent = function () {
		    this.canvasContext.drawImage(this.img, 0, 0);
		  };
		  CVImageElement.prototype.destroy = function () {
		    this.img = null;
		  };

		  function CVSolidElement(data, globalData, comp) {
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
		  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
		  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
		  CVSolidElement.prototype.renderInnerContent = function () {
		    // var ctx = this.canvasContext;
		    this.globalData.renderer.ctxFillStyle(this.data.sc);
		    // ctx.fillStyle = this.data.sc;
		    this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
		    // ctx.fillRect(0, 0, this.data.sw, this.data.sh);
		    //
		  };

		  function CanvasRendererBase() {}
		  extendPrototype([BaseRenderer], CanvasRendererBase);
		  CanvasRendererBase.prototype.createShape = function (data) {
		    return new CVShapeElement(data, this.globalData, this);
		  };
		  CanvasRendererBase.prototype.createText = function (data) {
		    return new CVTextElement(data, this.globalData, this);
		  };
		  CanvasRendererBase.prototype.createImage = function (data) {
		    return new CVImageElement(data, this.globalData, this);
		  };
		  CanvasRendererBase.prototype.createSolid = function (data) {
		    return new CVSolidElement(data, this.globalData, this);
		  };
		  CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
		  CanvasRendererBase.prototype.ctxTransform = function (props) {
		    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
		      return;
		    }
		    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
		  };
		  CanvasRendererBase.prototype.ctxOpacity = function (op) {
		    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
		  };
		  CanvasRendererBase.prototype.ctxFillStyle = function (value) {
		    this.canvasContext.fillStyle = value;
		  };
		  CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {
		    this.canvasContext.strokeStyle = value;
		  };
		  CanvasRendererBase.prototype.ctxLineWidth = function (value) {
		    this.canvasContext.lineWidth = value;
		  };
		  CanvasRendererBase.prototype.ctxLineCap = function (value) {
		    this.canvasContext.lineCap = value;
		  };
		  CanvasRendererBase.prototype.ctxLineJoin = function (value) {
		    this.canvasContext.lineJoin = value;
		  };
		  CanvasRendererBase.prototype.ctxMiterLimit = function (value) {
		    this.canvasContext.miterLimit = value;
		  };
		  CanvasRendererBase.prototype.ctxFill = function (rule) {
		    this.canvasContext.fill(rule);
		  };
		  CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {
		    this.canvasContext.fillRect(x, y, w, h);
		  };
		  CanvasRendererBase.prototype.ctxStroke = function () {
		    this.canvasContext.stroke();
		  };
		  CanvasRendererBase.prototype.reset = function () {
		    if (!this.renderConfig.clearCanvas) {
		      this.canvasContext.restore();
		      return;
		    }
		    this.contextData.reset();
		  };
		  CanvasRendererBase.prototype.save = function () {
		    this.canvasContext.save();
		  };
		  CanvasRendererBase.prototype.restore = function (actionFlag) {
		    if (!this.renderConfig.clearCanvas) {
		      this.canvasContext.restore();
		      return;
		    }
		    if (actionFlag) {
		      this.globalData.blendMode = 'source-over';
		    }
		    this.contextData.restore(actionFlag);
		  };
		  CanvasRendererBase.prototype.configAnimation = function (animData) {
		    if (this.animationItem.wrapper) {
		      this.animationItem.container = createTag('canvas');
		      var containerStyle = this.animationItem.container.style;
		      containerStyle.width = '100%';
		      containerStyle.height = '100%';
		      var origin = '0px 0px 0px';
		      containerStyle.transformOrigin = origin;
		      containerStyle.mozTransformOrigin = origin;
		      containerStyle.webkitTransformOrigin = origin;
		      containerStyle['-webkit-transform'] = origin;
		      containerStyle.contentVisibility = this.renderConfig.contentVisibility;
		      this.animationItem.wrapper.appendChild(this.animationItem.container);
		      this.canvasContext = this.animationItem.container.getContext('2d');
		      if (this.renderConfig.className) {
		        this.animationItem.container.setAttribute('class', this.renderConfig.className);
		      }
		      if (this.renderConfig.id) {
		        this.animationItem.container.setAttribute('id', this.renderConfig.id);
		      }
		    } else {
		      this.canvasContext = this.renderConfig.context;
		    }
		    this.contextData.setContext(this.canvasContext);
		    this.data = animData;
		    this.layers = animData.layers;
		    this.transformCanvas = {
		      w: animData.w,
		      h: animData.h,
		      sx: 0,
		      sy: 0,
		      tx: 0,
		      ty: 0
		    };
		    this.setupGlobalData(animData, document.body);
		    this.globalData.canvasContext = this.canvasContext;
		    this.globalData.renderer = this;
		    this.globalData.isDashed = false;
		    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
		    this.globalData.transformCanvas = this.transformCanvas;
		    this.elements = createSizedArray(animData.layers.length);
		    this.updateContainerSize();
		  };
		  CanvasRendererBase.prototype.updateContainerSize = function (width, height) {
		    this.reset();
		    var elementWidth;
		    var elementHeight;
		    if (width) {
		      elementWidth = width;
		      elementHeight = height;
		      this.canvasContext.canvas.width = elementWidth;
		      this.canvasContext.canvas.height = elementHeight;
		    } else {
		      if (this.animationItem.wrapper && this.animationItem.container) {
		        elementWidth = this.animationItem.wrapper.offsetWidth;
		        elementHeight = this.animationItem.wrapper.offsetHeight;
		      } else {
		        elementWidth = this.canvasContext.canvas.width;
		        elementHeight = this.canvasContext.canvas.height;
		      }
		      this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
		      this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
		    }
		    var elementRel;
		    var animationRel;
		    if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
		      var par = this.renderConfig.preserveAspectRatio.split(' ');
		      var fillType = par[1] || 'meet';
		      var pos = par[0] || 'xMidYMid';
		      var xPos = pos.substr(0, 4);
		      var yPos = pos.substr(4);
		      elementRel = elementWidth / elementHeight;
		      animationRel = this.transformCanvas.w / this.transformCanvas.h;
		      if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
		        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
		        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
		      } else {
		        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
		        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
		      }
		      if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
		        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
		      } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
		        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
		      } else {
		        this.transformCanvas.tx = 0;
		      }
		      if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
		        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
		      } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
		        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
		      } else {
		        this.transformCanvas.ty = 0;
		      }
		    } else if (this.renderConfig.preserveAspectRatio === 'none') {
		      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
		      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
		      this.transformCanvas.tx = 0;
		      this.transformCanvas.ty = 0;
		    } else {
		      this.transformCanvas.sx = this.renderConfig.dpr;
		      this.transformCanvas.sy = this.renderConfig.dpr;
		      this.transformCanvas.tx = 0;
		      this.transformCanvas.ty = 0;
		    }
		    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
		    /* var i, len = this.elements.length;
		      for(i=0;i<len;i+=1){
		          if(this.elements[i] && this.elements[i].data.ty === 0){
		              this.elements[i].resize(this.globalData.transformCanvas);
		          }
		      } */
		    this.ctxTransform(this.transformCanvas.props);
		    this.canvasContext.beginPath();
		    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
		    this.canvasContext.closePath();
		    this.canvasContext.clip();
		    this.renderFrame(this.renderedFrame, true);
		  };
		  CanvasRendererBase.prototype.destroy = function () {
		    if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
		      this.animationItem.wrapper.innerText = '';
		    }
		    var i;
		    var len = this.layers ? this.layers.length : 0;
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.elements[i] && this.elements[i].destroy) {
		        this.elements[i].destroy();
		      }
		    }
		    this.elements.length = 0;
		    this.globalData.canvasContext = null;
		    this.animationItem.container = null;
		    this.destroyed = true;
		  };
		  CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
		    if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
		      return;
		    }
		    this.renderedFrame = num;
		    this.globalData.frameNum = num - this.animationItem._isFirstFrame;
		    this.globalData.frameId += 1;
		    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
		    this.globalData.projectInterface.currentFrame = num;

		    // console.log('--------');
		    // console.log('NEW: ',num);
		    var i;
		    var len = this.layers.length;
		    if (!this.completeLayers) {
		      this.checkLayers(num);
		    }
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.completeLayers || this.elements[i]) {
		        this.elements[i].prepareFrame(num - this.layers[i].st);
		      }
		    }
		    if (this.globalData._mdf) {
		      if (this.renderConfig.clearCanvas === true) {
		        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
		      } else {
		        this.save();
		      }
		      for (i = len - 1; i >= 0; i -= 1) {
		        if (this.completeLayers || this.elements[i]) {
		          this.elements[i].renderFrame();
		        }
		      }
		      if (this.renderConfig.clearCanvas !== true) {
		        this.restore();
		      }
		    }
		  };
		  CanvasRendererBase.prototype.buildItem = function (pos) {
		    var elements = this.elements;
		    if (elements[pos] || this.layers[pos].ty === 99) {
		      return;
		    }
		    var element = this.createItem(this.layers[pos], this, this.globalData);
		    elements[pos] = element;
		    element.initExpressions();
		    /* if(this.layers[pos].ty === 0){
		          element.resize(this.globalData.transformCanvas);
		      } */
		  };
		  CanvasRendererBase.prototype.checkPendingElements = function () {
		    while (this.pendingElements.length) {
		      var element = this.pendingElements.pop();
		      element.checkParenting();
		    }
		  };
		  CanvasRendererBase.prototype.hide = function () {
		    this.animationItem.container.style.display = 'none';
		  };
		  CanvasRendererBase.prototype.show = function () {
		    this.animationItem.container.style.display = 'block';
		  };

		  function CanvasContext() {
		    this.opacity = -1;
		    this.transform = createTypedArray('float32', 16);
		    this.fillStyle = '';
		    this.strokeStyle = '';
		    this.lineWidth = '';
		    this.lineCap = '';
		    this.lineJoin = '';
		    this.miterLimit = '';
		    this.id = Math.random();
		  }
		  function CVContextData() {
		    this.stack = [];
		    this.cArrPos = 0;
		    this.cTr = new Matrix();
		    var i;
		    var len = 15;
		    for (i = 0; i < len; i += 1) {
		      var canvasContext = new CanvasContext();
		      this.stack[i] = canvasContext;
		    }
		    this._length = len;
		    this.nativeContext = null;
		    this.transformMat = new Matrix();
		    this.currentOpacity = 1;
		    //
		    this.currentFillStyle = '';
		    this.appliedFillStyle = '';
		    //
		    this.currentStrokeStyle = '';
		    this.appliedStrokeStyle = '';
		    //
		    this.currentLineWidth = '';
		    this.appliedLineWidth = '';
		    //
		    this.currentLineCap = '';
		    this.appliedLineCap = '';
		    //
		    this.currentLineJoin = '';
		    this.appliedLineJoin = '';
		    //
		    this.appliedMiterLimit = '';
		    this.currentMiterLimit = '';
		  }
		  CVContextData.prototype.duplicate = function () {
		    var newLength = this._length * 2;
		    var i = 0;
		    for (i = this._length; i < newLength; i += 1) {
		      this.stack[i] = new CanvasContext();
		    }
		    this._length = newLength;
		  };
		  CVContextData.prototype.reset = function () {
		    this.cArrPos = 0;
		    this.cTr.reset();
		    this.stack[this.cArrPos].opacity = 1;
		  };
		  CVContextData.prototype.restore = function (forceRestore) {
		    this.cArrPos -= 1;
		    var currentContext = this.stack[this.cArrPos];
		    var transform = currentContext.transform;
		    var i;
		    var arr = this.cTr.props;
		    for (i = 0; i < 16; i += 1) {
		      arr[i] = transform[i];
		    }
		    if (forceRestore) {
		      this.nativeContext.restore();
		      var prevStack = this.stack[this.cArrPos + 1];
		      this.appliedFillStyle = prevStack.fillStyle;
		      this.appliedStrokeStyle = prevStack.strokeStyle;
		      this.appliedLineWidth = prevStack.lineWidth;
		      this.appliedLineCap = prevStack.lineCap;
		      this.appliedLineJoin = prevStack.lineJoin;
		      this.appliedMiterLimit = prevStack.miterLimit;
		    }
		    this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);
		    if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
		      this.nativeContext.globalAlpha = currentContext.opacity;
		      this.currentOpacity = currentContext.opacity;
		    }
		    this.currentFillStyle = currentContext.fillStyle;
		    this.currentStrokeStyle = currentContext.strokeStyle;
		    this.currentLineWidth = currentContext.lineWidth;
		    this.currentLineCap = currentContext.lineCap;
		    this.currentLineJoin = currentContext.lineJoin;
		    this.currentMiterLimit = currentContext.miterLimit;
		  };
		  CVContextData.prototype.save = function (saveOnNativeFlag) {
		    if (saveOnNativeFlag) {
		      this.nativeContext.save();
		    }
		    var props = this.cTr.props;
		    if (this._length <= this.cArrPos) {
		      this.duplicate();
		    }
		    var currentStack = this.stack[this.cArrPos];
		    var i;
		    for (i = 0; i < 16; i += 1) {
		      currentStack.transform[i] = props[i];
		    }
		    this.cArrPos += 1;
		    var newStack = this.stack[this.cArrPos];
		    newStack.opacity = currentStack.opacity;
		    newStack.fillStyle = currentStack.fillStyle;
		    newStack.strokeStyle = currentStack.strokeStyle;
		    newStack.lineWidth = currentStack.lineWidth;
		    newStack.lineCap = currentStack.lineCap;
		    newStack.lineJoin = currentStack.lineJoin;
		    newStack.miterLimit = currentStack.miterLimit;
		  };
		  CVContextData.prototype.setOpacity = function (value) {
		    this.stack[this.cArrPos].opacity = value;
		  };
		  CVContextData.prototype.setContext = function (value) {
		    this.nativeContext = value;
		  };
		  CVContextData.prototype.fillStyle = function (value) {
		    if (this.stack[this.cArrPos].fillStyle !== value) {
		      this.currentFillStyle = value;
		      this.stack[this.cArrPos].fillStyle = value;
		    }
		  };
		  CVContextData.prototype.strokeStyle = function (value) {
		    if (this.stack[this.cArrPos].strokeStyle !== value) {
		      this.currentStrokeStyle = value;
		      this.stack[this.cArrPos].strokeStyle = value;
		    }
		  };
		  CVContextData.prototype.lineWidth = function (value) {
		    if (this.stack[this.cArrPos].lineWidth !== value) {
		      this.currentLineWidth = value;
		      this.stack[this.cArrPos].lineWidth = value;
		    }
		  };
		  CVContextData.prototype.lineCap = function (value) {
		    if (this.stack[this.cArrPos].lineCap !== value) {
		      this.currentLineCap = value;
		      this.stack[this.cArrPos].lineCap = value;
		    }
		  };
		  CVContextData.prototype.lineJoin = function (value) {
		    if (this.stack[this.cArrPos].lineJoin !== value) {
		      this.currentLineJoin = value;
		      this.stack[this.cArrPos].lineJoin = value;
		    }
		  };
		  CVContextData.prototype.miterLimit = function (value) {
		    if (this.stack[this.cArrPos].miterLimit !== value) {
		      this.currentMiterLimit = value;
		      this.stack[this.cArrPos].miterLimit = value;
		    }
		  };
		  CVContextData.prototype.transform = function (props) {
		    this.transformMat.cloneFromProps(props);
		    // Taking the last transform value from the stored stack of transforms
		    var currentTransform = this.cTr;
		    // Applying the last transform value after the new transform to respect the order of transformations
		    this.transformMat.multiply(currentTransform);
		    // Storing the new transformed value in the stored transform
		    currentTransform.cloneFromProps(this.transformMat.props);
		    var trProps = currentTransform.props;
		    // Applying the new transform to the canvas
		    this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
		  };
		  CVContextData.prototype.opacity = function (op) {
		    var currentOpacity = this.stack[this.cArrPos].opacity;
		    currentOpacity *= op < 0 ? 0 : op;
		    if (this.stack[this.cArrPos].opacity !== currentOpacity) {
		      if (this.currentOpacity !== op) {
		        this.nativeContext.globalAlpha = op;
		        this.currentOpacity = op;
		      }
		      this.stack[this.cArrPos].opacity = currentOpacity;
		    }
		  };
		  CVContextData.prototype.fill = function (rule) {
		    if (this.appliedFillStyle !== this.currentFillStyle) {
		      this.appliedFillStyle = this.currentFillStyle;
		      this.nativeContext.fillStyle = this.appliedFillStyle;
		    }
		    this.nativeContext.fill(rule);
		  };
		  CVContextData.prototype.fillRect = function (x, y, w, h) {
		    if (this.appliedFillStyle !== this.currentFillStyle) {
		      this.appliedFillStyle = this.currentFillStyle;
		      this.nativeContext.fillStyle = this.appliedFillStyle;
		    }
		    this.nativeContext.fillRect(x, y, w, h);
		  };
		  CVContextData.prototype.stroke = function () {
		    if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
		      this.appliedStrokeStyle = this.currentStrokeStyle;
		      this.nativeContext.strokeStyle = this.appliedStrokeStyle;
		    }
		    if (this.appliedLineWidth !== this.currentLineWidth) {
		      this.appliedLineWidth = this.currentLineWidth;
		      this.nativeContext.lineWidth = this.appliedLineWidth;
		    }
		    if (this.appliedLineCap !== this.currentLineCap) {
		      this.appliedLineCap = this.currentLineCap;
		      this.nativeContext.lineCap = this.appliedLineCap;
		    }
		    if (this.appliedLineJoin !== this.currentLineJoin) {
		      this.appliedLineJoin = this.currentLineJoin;
		      this.nativeContext.lineJoin = this.appliedLineJoin;
		    }
		    if (this.appliedMiterLimit !== this.currentMiterLimit) {
		      this.appliedMiterLimit = this.currentMiterLimit;
		      this.nativeContext.miterLimit = this.appliedMiterLimit;
		    }
		    this.nativeContext.stroke();
		  };

		  function CVCompElement(data, globalData, comp) {
		    this.completeLayers = false;
		    this.layers = data.layers;
		    this.pendingElements = [];
		    this.elements = createSizedArray(this.layers.length);
		    this.initElement(data, globalData, comp);
		    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
		      _placeholder: true
		    };
		  }
		  extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
		  CVCompElement.prototype.renderInnerContent = function () {
		    var ctx = this.canvasContext;
		    ctx.beginPath();
		    ctx.moveTo(0, 0);
		    ctx.lineTo(this.data.w, 0);
		    ctx.lineTo(this.data.w, this.data.h);
		    ctx.lineTo(0, this.data.h);
		    ctx.lineTo(0, 0);
		    ctx.clip();
		    var i;
		    var len = this.layers.length;
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.completeLayers || this.elements[i]) {
		        this.elements[i].renderFrame();
		      }
		    }
		  };
		  CVCompElement.prototype.destroy = function () {
		    var i;
		    var len = this.layers.length;
		    for (i = len - 1; i >= 0; i -= 1) {
		      if (this.elements[i]) {
		        this.elements[i].destroy();
		      }
		    }
		    this.layers = null;
		    this.elements = null;
		  };
		  CVCompElement.prototype.createComp = function (data) {
		    return new CVCompElement(data, this.globalData, this);
		  };

		  function CanvasRenderer(animationItem, config) {
		    this.animationItem = animationItem;
		    this.renderConfig = {
		      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
		      context: config && config.context || null,
		      progressiveLoad: config && config.progressiveLoad || false,
		      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
		      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
		      contentVisibility: config && config.contentVisibility || 'visible',
		      className: config && config.className || '',
		      id: config && config.id || '',
		      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
		    };
		    this.renderConfig.dpr = config && config.dpr || 1;
		    if (this.animationItem.wrapper) {
		      this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
		    }
		    this.renderedFrame = -1;
		    this.globalData = {
		      frameNum: -1,
		      _mdf: false,
		      renderConfig: this.renderConfig,
		      currentGlobalAlpha: -1
		    };
		    this.contextData = new CVContextData();
		    this.elements = [];
		    this.pendingElements = [];
		    this.transformMat = new Matrix();
		    this.completeLayers = false;
		    this.rendererType = 'canvas';
		    if (this.renderConfig.clearCanvas) {
		      this.ctxTransform = this.contextData.transform.bind(this.contextData);
		      this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
		      this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
		      this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
		      this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
		      this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
		      this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
		      this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
		      this.ctxFill = this.contextData.fill.bind(this.contextData);
		      this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
		      this.ctxStroke = this.contextData.stroke.bind(this.contextData);
		      this.save = this.contextData.save.bind(this.contextData);
		    }
		  }
		  extendPrototype([CanvasRendererBase], CanvasRenderer);
		  CanvasRenderer.prototype.createComp = function (data) {
		    return new CVCompElement(data, this.globalData, this);
		  };

		  function HBaseElement() {}
		  HBaseElement.prototype = {
		    checkBlendMode: function checkBlendMode() {},
		    initRendererElement: function initRendererElement() {
		      this.baseElement = createTag(this.data.tg || 'div');
		      if (this.data.hasMask) {
		        this.svgElement = createNS('svg');
		        this.layerElement = createNS('g');
		        this.maskedElement = this.layerElement;
		        this.svgElement.appendChild(this.layerElement);
		        this.baseElement.appendChild(this.svgElement);
		      } else {
		        this.layerElement = this.baseElement;
		      }
		      styleDiv(this.baseElement);
		    },
		    createContainerElements: function createContainerElements() {
		      this.renderableEffectsManager = new CVEffects(this);
		      this.transformedElement = this.baseElement;
		      this.maskedElement = this.layerElement;
		      if (this.data.ln) {
		        this.layerElement.setAttribute('id', this.data.ln);
		      }
		      if (this.data.cl) {
		        this.layerElement.setAttribute('class', this.data.cl);
		      }
		      if (this.data.bm !== 0) {
		        this.setBlendMode();
		      }
		    },
		    renderElement: function renderElement() {
		      var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
		      if (this.finalTransform._matMdf) {
		        var matrixValue = this.finalTransform.mat.toCSS();
		        transformedElementStyle.transform = matrixValue;
		        transformedElementStyle.webkitTransform = matrixValue;
		      }
		      if (this.finalTransform._opMdf) {
		        transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
		      }
		    },
		    renderFrame: function renderFrame() {
		      // If it is exported as hidden (data.hd === true) no need to render
		      // If it is not visible no need to render
		      if (this.data.hd || this.hidden) {
		        return;
		      }
		      this.renderTransform();
		      this.renderRenderable();
		      this.renderElement();
		      this.renderInnerContent();
		      if (this._isFirstFrame) {
		        this._isFirstFrame = false;
		      }
		    },
		    destroy: function destroy() {
		      this.layerElement = null;
		      this.transformedElement = null;
		      if (this.matteElement) {
		        this.matteElement = null;
		      }
		      if (this.maskManager) {
		        this.maskManager.destroy();
		        this.maskManager = null;
		      }
		    },
		    createRenderableComponents: function createRenderableComponents() {
		      this.maskManager = new MaskElement(this.data, this, this.globalData);
		    },
		    addEffects: function addEffects() {},
		    setMatte: function setMatte() {}
		  };
		  HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
		  HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
		  HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;

		  function HSolidElement(data, globalData, comp) {
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
		  HSolidElement.prototype.createContent = function () {
		    var rect;
		    if (this.data.hasMask) {
		      rect = createNS('rect');
		      rect.setAttribute('width', this.data.sw);
		      rect.setAttribute('height', this.data.sh);
		      rect.setAttribute('fill', this.data.sc);
		      this.svgElement.setAttribute('width', this.data.sw);
		      this.svgElement.setAttribute('height', this.data.sh);
		    } else {
		      rect = createTag('div');
		      rect.style.width = this.data.sw + 'px';
		      rect.style.height = this.data.sh + 'px';
		      rect.style.backgroundColor = this.data.sc;
		    }
		    this.layerElement.appendChild(rect);
		  };

		  function HShapeElement(data, globalData, comp) {
		    // List of drawable elements
		    this.shapes = [];
		    // Full shape data
		    this.shapesData = data.shapes;
		    // List of styles that will be applied to shapes
		    this.stylesList = [];
		    // List of modifiers that will be applied to shapes
		    this.shapeModifiers = [];
		    // List of items in shape tree
		    this.itemsData = [];
		    // List of items in previous shape tree
		    this.processedElements = [];
		    // List of animated components
		    this.animatedContents = [];
		    this.shapesContainer = createNS('g');
		    this.initElement(data, globalData, comp);
		    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
		    // List of elements that have been created
		    this.prevViewData = [];
		    this.currentBBox = {
		      x: 999999,
		      y: -999999,
		      h: 0,
		      w: 0
		    };
		  }
		  extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
		  HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
		  HShapeElement.prototype.createContent = function () {
		    var cont;
		    this.baseElement.style.fontSize = 0;
		    if (this.data.hasMask) {
		      this.layerElement.appendChild(this.shapesContainer);
		      cont = this.svgElement;
		    } else {
		      cont = createNS('svg');
		      var size = this.comp.data ? this.comp.data : this.globalData.compSize;
		      cont.setAttribute('width', size.w);
		      cont.setAttribute('height', size.h);
		      cont.appendChild(this.shapesContainer);
		      this.layerElement.appendChild(cont);
		    }
		    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
		    this.filterUniqueShapes();
		    this.shapeCont = cont;
		  };
		  HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
		    var i;
		    var len = transformers.length;
		    for (i = 0; i < len; i += 1) {
		      point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
		    }
		    return point;
		  };
		  HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
		    var shape = item.sh.v;
		    var transformers = item.transformers;
		    var i;
		    var len = shape._length;
		    var vPoint;
		    var oPoint;
		    var nextIPoint;
		    var nextVPoint;
		    if (len <= 1) {
		      return;
		    }
		    for (i = 0; i < len - 1; i += 1) {
		      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
		      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
		      nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
		      nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
		      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
		    }
		    if (shape.c) {
		      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
		      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
		      nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
		      nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
		      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
		    }
		  };
		  HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
		    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
		    var bounds = this.shapeBoundingBox;
		    boundingBox.x = bmMin(bounds.left, boundingBox.x);
		    boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
		    boundingBox.y = bmMin(bounds.top, boundingBox.y);
		    boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
		  };
		  HShapeElement.prototype.shapeBoundingBox = {
		    left: 0,
		    right: 0,
		    top: 0,
		    bottom: 0
		  };
		  HShapeElement.prototype.tempBoundingBox = {
		    x: 0,
		    xMax: 0,
		    y: 0,
		    yMax: 0,
		    width: 0,
		    height: 0
		  };
		  HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
		    var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
		    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
		      // eslint-disable-line no-plusplus
		      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
		      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
		      c = 3 * p1[i] - 3 * p0[i];
		      b |= 0; // eslint-disable-line no-bitwise
		      a |= 0; // eslint-disable-line no-bitwise
		      c |= 0; // eslint-disable-line no-bitwise

		      if (a === 0 && b === 0) ; else if (a === 0) {
		        t = -c / b;
		        if (t > 0 && t < 1) {
		          bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
		        }
		      } else {
		        b2ac = b * b - 4 * c * a;
		        if (b2ac >= 0) {
		          t1 = (-b + bmSqrt(b2ac)) / (2 * a);
		          if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
		          t2 = (-b - bmSqrt(b2ac)) / (2 * a);
		          if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
		        }
		      }
		    }
		    this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
		    this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
		    this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
		    this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
		  };
		  HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
		    return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
		  };
		  HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
		    var i;
		    var len = itemsData.length;
		    for (i = 0; i < len; i += 1) {
		      if (itemsData[i] && itemsData[i].sh) {
		        this.calculateShapeBoundingBox(itemsData[i], boundingBox);
		      } else if (itemsData[i] && itemsData[i].it) {
		        this.calculateBoundingBox(itemsData[i].it, boundingBox);
		      } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
		        this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
		      }
		    }
		  };
		  HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {
		    var width = 0;
		    if (widthProperty.keyframes) {
		      for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
		        var kfw = widthProperty.keyframes[i].s;
		        if (kfw > width) {
		          width = kfw;
		        }
		      }
		      width *= widthProperty.mult;
		    } else {
		      width = widthProperty.v * widthProperty.mult;
		    }
		    boundingBox.x -= width;
		    boundingBox.xMax += width;
		    boundingBox.y -= width;
		    boundingBox.yMax += width;
		  };
		  HShapeElement.prototype.currentBoxContains = function (box) {
		    return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
		  };
		  HShapeElement.prototype.renderInnerContent = function () {
		    this._renderShapeFrame();
		    if (!this.hidden && (this._isFirstFrame || this._mdf)) {
		      var tempBoundingBox = this.tempBoundingBox;
		      var max = 999999;
		      tempBoundingBox.x = max;
		      tempBoundingBox.xMax = -max;
		      tempBoundingBox.y = max;
		      tempBoundingBox.yMax = -max;
		      this.calculateBoundingBox(this.itemsData, tempBoundingBox);
		      tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
		      tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
		      // var tempBoundingBox = this.shapeCont.getBBox();
		      if (this.currentBoxContains(tempBoundingBox)) {
		        return;
		      }
		      var changed = false;
		      if (this.currentBBox.w !== tempBoundingBox.width) {
		        this.currentBBox.w = tempBoundingBox.width;
		        this.shapeCont.setAttribute('width', tempBoundingBox.width);
		        changed = true;
		      }
		      if (this.currentBBox.h !== tempBoundingBox.height) {
		        this.currentBBox.h = tempBoundingBox.height;
		        this.shapeCont.setAttribute('height', tempBoundingBox.height);
		        changed = true;
		      }
		      if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
		        this.currentBBox.w = tempBoundingBox.width;
		        this.currentBBox.h = tempBoundingBox.height;
		        this.currentBBox.x = tempBoundingBox.x;
		        this.currentBBox.y = tempBoundingBox.y;
		        this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
		        var shapeStyle = this.shapeCont.style;
		        var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
		        shapeStyle.transform = shapeTransform;
		        shapeStyle.webkitTransform = shapeTransform;
		      }
		    }
		  };

		  function HTextElement(data, globalData, comp) {
		    this.textSpans = [];
		    this.textPaths = [];
		    this.currentBBox = {
		      x: 999999,
		      y: -999999,
		      h: 0,
		      w: 0
		    };
		    this.renderType = 'svg';
		    this.isMasked = false;
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
		  HTextElement.prototype.createContent = function () {
		    this.isMasked = this.checkMasks();
		    if (this.isMasked) {
		      this.renderType = 'svg';
		      this.compW = this.comp.data.w;
		      this.compH = this.comp.data.h;
		      this.svgElement.setAttribute('width', this.compW);
		      this.svgElement.setAttribute('height', this.compH);
		      var g = createNS('g');
		      this.maskedElement.appendChild(g);
		      this.innerElem = g;
		    } else {
		      this.renderType = 'html';
		      this.innerElem = this.layerElement;
		    }
		    this.checkParenting();
		  };
		  HTextElement.prototype.buildNewText = function () {
		    var documentData = this.textProperty.currentData;
		    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
		    var innerElemStyle = this.innerElem.style;
		    var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
		    innerElemStyle.fill = textColor;
		    innerElemStyle.color = textColor;
		    if (documentData.sc) {
		      innerElemStyle.stroke = this.buildColor(documentData.sc);
		      innerElemStyle.strokeWidth = documentData.sw + 'px';
		    }
		    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
		    if (!this.globalData.fontManager.chars) {
		      innerElemStyle.fontSize = documentData.finalSize + 'px';
		      innerElemStyle.lineHeight = documentData.finalSize + 'px';
		      if (fontData.fClass) {
		        this.innerElem.className = fontData.fClass;
		      } else {
		        innerElemStyle.fontFamily = fontData.fFamily;
		        var fWeight = documentData.fWeight;
		        var fStyle = documentData.fStyle;
		        innerElemStyle.fontStyle = fStyle;
		        innerElemStyle.fontWeight = fWeight;
		      }
		    }
		    var i;
		    var len;
		    var letters = documentData.l;
		    len = letters.length;
		    var tSpan;
		    var tParent;
		    var tCont;
		    var matrixHelper = this.mHelper;
		    var shapes;
		    var shapeStr = '';
		    var cnt = 0;
		    for (i = 0; i < len; i += 1) {
		      if (this.globalData.fontManager.chars) {
		        if (!this.textPaths[cnt]) {
		          tSpan = createNS('path');
		          tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
		          tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
		          tSpan.setAttribute('stroke-miterlimit', '4');
		        } else {
		          tSpan = this.textPaths[cnt];
		        }
		        if (!this.isMasked) {
		          if (this.textSpans[cnt]) {
		            tParent = this.textSpans[cnt];
		            tCont = tParent.children[0];
		          } else {
		            tParent = createTag('div');
		            tParent.style.lineHeight = 0;
		            tCont = createNS('svg');
		            tCont.appendChild(tSpan);
		            styleDiv(tParent);
		          }
		        }
		      } else if (!this.isMasked) {
		        if (this.textSpans[cnt]) {
		          tParent = this.textSpans[cnt];
		          tSpan = this.textPaths[cnt];
		        } else {
		          tParent = createTag('span');
		          styleDiv(tParent);
		          tSpan = createTag('span');
		          styleDiv(tSpan);
		          tParent.appendChild(tSpan);
		        }
		      } else {
		        tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
		      }
		      // tSpan.setAttribute('visibility', 'hidden');
		      if (this.globalData.fontManager.chars) {
		        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
		        var shapeData;
		        if (charData) {
		          shapeData = charData.data;
		        } else {
		          shapeData = null;
		        }
		        matrixHelper.reset();
		        if (shapeData && shapeData.shapes && shapeData.shapes.length) {
		          shapes = shapeData.shapes[0].it;
		          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
		          shapeStr = this.createPathShape(matrixHelper, shapes);
		          tSpan.setAttribute('d', shapeStr);
		        }
		        if (!this.isMasked) {
		          this.innerElem.appendChild(tParent);
		          if (shapeData && shapeData.shapes) {
		            // document.body.appendChild is needed to get exact measure of shape
		            document.body.appendChild(tCont);
		            var boundingBox = tCont.getBBox();
		            tCont.setAttribute('width', boundingBox.width + 2);
		            tCont.setAttribute('height', boundingBox.height + 2);
		            tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
		            var tContStyle = tCont.style;
		            var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
		            tContStyle.transform = tContTranslation;
		            tContStyle.webkitTransform = tContTranslation;
		            letters[i].yOffset = boundingBox.y - 1;
		          } else {
		            tCont.setAttribute('width', 1);
		            tCont.setAttribute('height', 1);
		          }
		          tParent.appendChild(tCont);
		        } else {
		          this.innerElem.appendChild(tSpan);
		        }
		      } else {
		        tSpan.textContent = letters[i].val;
		        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
		        if (!this.isMasked) {
		          this.innerElem.appendChild(tParent);
		          //
		          var tStyle = tSpan.style;
		          var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
		          tStyle.transform = tSpanTranslation;
		          tStyle.webkitTransform = tSpanTranslation;
		        } else {
		          this.innerElem.appendChild(tSpan);
		        }
		      }
		      //
		      if (!this.isMasked) {
		        this.textSpans[cnt] = tParent;
		      } else {
		        this.textSpans[cnt] = tSpan;
		      }
		      this.textSpans[cnt].style.display = 'block';
		      this.textPaths[cnt] = tSpan;
		      cnt += 1;
		    }
		    while (cnt < this.textSpans.length) {
		      this.textSpans[cnt].style.display = 'none';
		      cnt += 1;
		    }
		  };
		  HTextElement.prototype.renderInnerContent = function () {
		    this.validateText();
		    var svgStyle;
		    if (this.data.singleShape) {
		      if (!this._isFirstFrame && !this.lettersChangedFlag) {
		        return;
		      }
		      if (this.isMasked && this.finalTransform._matMdf) {
		        // Todo Benchmark if using this is better than getBBox
		        this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
		        svgStyle = this.svgElement.style;
		        var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
		        svgStyle.transform = translation;
		        svgStyle.webkitTransform = translation;
		      }
		    }
		    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
		    if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
		      return;
		    }
		    var i;
		    var len;
		    var count = 0;
		    var renderedLetters = this.textAnimator.renderedLetters;
		    var letters = this.textProperty.currentData.l;
		    len = letters.length;
		    var renderedLetter;
		    var textSpan;
		    var textPath;
		    for (i = 0; i < len; i += 1) {
		      if (letters[i].n) {
		        count += 1;
		      } else {
		        textSpan = this.textSpans[i];
		        textPath = this.textPaths[i];
		        renderedLetter = renderedLetters[count];
		        count += 1;
		        if (renderedLetter._mdf.m) {
		          if (!this.isMasked) {
		            textSpan.style.webkitTransform = renderedLetter.m;
		            textSpan.style.transform = renderedLetter.m;
		          } else {
		            textSpan.setAttribute('transform', renderedLetter.m);
		          }
		        }
		        /// /textSpan.setAttribute('opacity',renderedLetter.o);
		        textSpan.style.opacity = renderedLetter.o;
		        if (renderedLetter.sw && renderedLetter._mdf.sw) {
		          textPath.setAttribute('stroke-width', renderedLetter.sw);
		        }
		        if (renderedLetter.sc && renderedLetter._mdf.sc) {
		          textPath.setAttribute('stroke', renderedLetter.sc);
		        }
		        if (renderedLetter.fc && renderedLetter._mdf.fc) {
		          textPath.setAttribute('fill', renderedLetter.fc);
		          textPath.style.color = renderedLetter.fc;
		        }
		      }
		    }
		    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
		      var boundingBox = this.innerElem.getBBox();
		      if (this.currentBBox.w !== boundingBox.width) {
		        this.currentBBox.w = boundingBox.width;
		        this.svgElement.setAttribute('width', boundingBox.width);
		      }
		      if (this.currentBBox.h !== boundingBox.height) {
		        this.currentBBox.h = boundingBox.height;
		        this.svgElement.setAttribute('height', boundingBox.height);
		      }
		      var margin = 1;
		      if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
		        this.currentBBox.w = boundingBox.width + margin * 2;
		        this.currentBBox.h = boundingBox.height + margin * 2;
		        this.currentBBox.x = boundingBox.x - margin;
		        this.currentBBox.y = boundingBox.y - margin;
		        this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
		        svgStyle = this.svgElement.style;
		        var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
		        svgStyle.transform = svgTransform;
		        svgStyle.webkitTransform = svgTransform;
		      }
		    }
		  };

		  function HCameraElement(data, globalData, comp) {
		    this.initFrame();
		    this.initBaseData(data, globalData, comp);
		    this.initHierarchy();
		    var getProp = PropertyFactory.getProp;
		    this.pe = getProp(this, data.pe, 0, 0, this);
		    if (data.ks.p.s) {
		      this.px = getProp(this, data.ks.p.x, 1, 0, this);
		      this.py = getProp(this, data.ks.p.y, 1, 0, this);
		      this.pz = getProp(this, data.ks.p.z, 1, 0, this);
		    } else {
		      this.p = getProp(this, data.ks.p, 1, 0, this);
		    }
		    if (data.ks.a) {
		      this.a = getProp(this, data.ks.a, 1, 0, this);
		    }
		    if (data.ks.or.k.length && data.ks.or.k[0].to) {
		      var i;
		      var len = data.ks.or.k.length;
		      for (i = 0; i < len; i += 1) {
		        data.ks.or.k[i].to = null;
		        data.ks.or.k[i].ti = null;
		      }
		    }
		    this.or = getProp(this, data.ks.or, 1, degToRads, this);
		    this.or.sh = true;
		    this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
		    this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
		    this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
		    this.mat = new Matrix();
		    this._prevMat = new Matrix();
		    this._isFirstFrame = true;

		    // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
		    this.finalTransform = {
		      mProp: this
		    };
		  }
		  extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
		  HCameraElement.prototype.setup = function () {
		    var i;
		    var len = this.comp.threeDElements.length;
		    var comp;
		    var perspectiveStyle;
		    var containerStyle;
		    for (i = 0; i < len; i += 1) {
		      // [perspectiveElem,container]
		      comp = this.comp.threeDElements[i];
		      if (comp.type === '3d') {
		        perspectiveStyle = comp.perspectiveElem.style;
		        containerStyle = comp.container.style;
		        var perspective = this.pe.v + 'px';
		        var origin = '0px 0px 0px';
		        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
		        perspectiveStyle.perspective = perspective;
		        perspectiveStyle.webkitPerspective = perspective;
		        containerStyle.transformOrigin = origin;
		        containerStyle.mozTransformOrigin = origin;
		        containerStyle.webkitTransformOrigin = origin;
		        perspectiveStyle.transform = matrix;
		        perspectiveStyle.webkitTransform = matrix;
		      }
		    }
		  };
		  HCameraElement.prototype.createElements = function () {};
		  HCameraElement.prototype.hide = function () {};
		  HCameraElement.prototype.renderFrame = function () {
		    var _mdf = this._isFirstFrame;
		    var i;
		    var len;
		    if (this.hierarchy) {
		      len = this.hierarchy.length;
		      for (i = 0; i < len; i += 1) {
		        _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
		      }
		    }
		    if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
		      this.mat.reset();
		      if (this.hierarchy) {
		        len = this.hierarchy.length - 1;
		        for (i = len; i >= 0; i -= 1) {
		          var mTransf = this.hierarchy[i].finalTransform.mProp;
		          this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
		          this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
		          this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
		          this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
		          this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
		        }
		      }
		      if (this.p) {
		        this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
		      } else {
		        this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
		      }
		      if (this.a) {
		        var diffVector;
		        if (this.p) {
		          diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
		        } else {
		          diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
		        }
		        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
		        // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
		        var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
		        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
		        var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
		        var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
		        this.mat.rotateY(mRotationY).rotateX(-mRotationX);
		      }
		      this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
		      this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
		      this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
		      this.mat.translate(0, 0, this.pe.v);
		      var hasMatrixChanged = !this._prevMat.equals(this.mat);
		      if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
		        len = this.comp.threeDElements.length;
		        var comp;
		        var perspectiveStyle;
		        var containerStyle;
		        for (i = 0; i < len; i += 1) {
		          comp = this.comp.threeDElements[i];
		          if (comp.type === '3d') {
		            if (hasMatrixChanged) {
		              var matValue = this.mat.toCSS();
		              containerStyle = comp.container.style;
		              containerStyle.transform = matValue;
		              containerStyle.webkitTransform = matValue;
		            }
		            if (this.pe._mdf) {
		              perspectiveStyle = comp.perspectiveElem.style;
		              perspectiveStyle.perspective = this.pe.v + 'px';
		              perspectiveStyle.webkitPerspective = this.pe.v + 'px';
		            }
		          }
		        }
		        this.mat.clone(this._prevMat);
		      }
		    }
		    this._isFirstFrame = false;
		  };
		  HCameraElement.prototype.prepareFrame = function (num) {
		    this.prepareProperties(num, true);
		  };
		  HCameraElement.prototype.destroy = function () {};
		  HCameraElement.prototype.getBaseElement = function () {
		    return null;
		  };

		  function HImageElement(data, globalData, comp) {
		    this.assetData = globalData.getAssetData(data.refId);
		    this.initElement(data, globalData, comp);
		  }
		  extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
		  HImageElement.prototype.createContent = function () {
		    var assetPath = this.globalData.getAssetsPath(this.assetData);
		    var img = new Image();
		    if (this.data.hasMask) {
		      this.imageElem = createNS('image');
		      this.imageElem.setAttribute('width', this.assetData.w + 'px');
		      this.imageElem.setAttribute('height', this.assetData.h + 'px');
		      this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
		      this.layerElement.appendChild(this.imageElem);
		      this.baseElement.setAttribute('width', this.assetData.w);
		      this.baseElement.setAttribute('height', this.assetData.h);
		    } else {
		      this.layerElement.appendChild(img);
		    }
		    img.crossOrigin = 'anonymous';
		    img.src = assetPath;
		    if (this.data.ln) {
		      this.baseElement.setAttribute('id', this.data.ln);
		    }
		  };

		  function HybridRendererBase(animationItem, config) {
		    this.animationItem = animationItem;
		    this.layers = null;
		    this.renderedFrame = -1;
		    this.renderConfig = {
		      className: config && config.className || '',
		      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
		      hideOnTransparent: !(config && config.hideOnTransparent === false),
		      filterSize: {
		        width: config && config.filterSize && config.filterSize.width || '400%',
		        height: config && config.filterSize && config.filterSize.height || '400%',
		        x: config && config.filterSize && config.filterSize.x || '-100%',
		        y: config && config.filterSize && config.filterSize.y || '-100%'
		      }
		    };
		    this.globalData = {
		      _mdf: false,
		      frameNum: -1,
		      renderConfig: this.renderConfig
		    };
		    this.pendingElements = [];
		    this.elements = [];
		    this.threeDElements = [];
		    this.destroyed = false;
		    this.camera = null;
		    this.supports3d = true;
		    this.rendererType = 'html';
		  }
		  extendPrototype([BaseRenderer], HybridRendererBase);
		  HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
		  HybridRendererBase.prototype.checkPendingElements = function () {
		    while (this.pendingElements.length) {
		      var element = this.pendingElements.pop();
		      element.checkParenting();
		    }
		  };
		  HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
		    var newDOMElement = element.getBaseElement();
		    if (!newDOMElement) {
		      return;
		    }
		    var layer = this.layers[pos];
		    if (!layer.ddd || !this.supports3d) {
		      if (this.threeDElements) {
		        this.addTo3dContainer(newDOMElement, pos);
		      } else {
		        var i = 0;
		        var nextDOMElement;
		        var nextLayer;
		        var tmpDOMElement;
		        while (i < pos) {
		          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
		            nextLayer = this.elements[i];
		            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
		            nextDOMElement = tmpDOMElement || nextDOMElement;
		          }
		          i += 1;
		        }
		        if (nextDOMElement) {
		          if (!layer.ddd || !this.supports3d) {
		            this.layerElement.insertBefore(newDOMElement, nextDOMElement);
		          }
		        } else if (!layer.ddd || !this.supports3d) {
		          this.layerElement.appendChild(newDOMElement);
		        }
		      }
		    } else {
		      this.addTo3dContainer(newDOMElement, pos);
		    }
		  };
		  HybridRendererBase.prototype.createShape = function (data) {
		    if (!this.supports3d) {
		      return new SVGShapeElement(data, this.globalData, this);
		    }
		    return new HShapeElement(data, this.globalData, this);
		  };
		  HybridRendererBase.prototype.createText = function (data) {
		    if (!this.supports3d) {
		      return new SVGTextLottieElement(data, this.globalData, this);
		    }
		    return new HTextElement(data, this.globalData, this);
		  };
		  HybridRendererBase.prototype.createCamera = function (data) {
		    this.camera = new HCameraElement(data, this.globalData, this);
		    return this.camera;
		  };
		  HybridRendererBase.prototype.createImage = function (data) {
		    if (!this.supports3d) {
		      return new IImageElement(data, this.globalData, this);
		    }
		    return new HImageElement(data, this.globalData, this);
		  };
		  HybridRendererBase.prototype.createSolid = function (data) {
		    if (!this.supports3d) {
		      return new ISolidElement(data, this.globalData, this);
		    }
		    return new HSolidElement(data, this.globalData, this);
		  };
		  HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
		  HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
		    var i = 0;
		    var len = this.threeDElements.length;
		    while (i < len) {
		      if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
		        return this.threeDElements[i].perspectiveElem;
		      }
		      i += 1;
		    }
		    return null;
		  };
		  HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
		    var perspectiveElem = createTag('div');
		    var style;
		    var containerStyle;
		    styleDiv(perspectiveElem);
		    var container = createTag('div');
		    styleDiv(container);
		    if (type === '3d') {
		      style = perspectiveElem.style;
		      style.width = this.globalData.compSize.w + 'px';
		      style.height = this.globalData.compSize.h + 'px';
		      var center = '50% 50%';
		      style.webkitTransformOrigin = center;
		      style.mozTransformOrigin = center;
		      style.transformOrigin = center;
		      containerStyle = container.style;
		      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
		      containerStyle.transform = matrix;
		      containerStyle.webkitTransform = matrix;
		    }
		    perspectiveElem.appendChild(container);
		    // this.resizerElem.appendChild(perspectiveElem);
		    var threeDContainerData = {
		      container: container,
		      perspectiveElem: perspectiveElem,
		      startPos: pos,
		      endPos: pos,
		      type: type
		    };
		    this.threeDElements.push(threeDContainerData);
		    return threeDContainerData;
		  };
		  HybridRendererBase.prototype.build3dContainers = function () {
		    var i;
		    var len = this.layers.length;
		    var lastThreeDContainerData;
		    var currentContainer = '';
		    for (i = 0; i < len; i += 1) {
		      if (this.layers[i].ddd && this.layers[i].ty !== 3) {
		        if (currentContainer !== '3d') {
		          currentContainer = '3d';
		          lastThreeDContainerData = this.createThreeDContainer(i, '3d');
		        }
		        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
		      } else {
		        if (currentContainer !== '2d') {
		          currentContainer = '2d';
		          lastThreeDContainerData = this.createThreeDContainer(i, '2d');
		        }
		        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
		      }
		    }
		    len = this.threeDElements.length;
		    for (i = len - 1; i >= 0; i -= 1) {
		      this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
		    }
		  };
		  HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
		    var i = 0;
		    var len = this.threeDElements.length;
		    while (i < len) {
		      if (pos <= this.threeDElements[i].endPos) {
		        var j = this.threeDElements[i].startPos;
		        var nextElement;
		        while (j < pos) {
		          if (this.elements[j] && this.elements[j].getBaseElement) {
		            nextElement = this.elements[j].getBaseElement();
		          }
		          j += 1;
		        }
		        if (nextElement) {
		          this.threeDElements[i].container.insertBefore(elem, nextElement);
		        } else {
		          this.threeDElements[i].container.appendChild(elem);
		        }
		        break;
		      }
		      i += 1;
		    }
		  };
		  HybridRendererBase.prototype.configAnimation = function (animData) {
		    var resizerElem = createTag('div');
		    var wrapper = this.animationItem.wrapper;
		    var style = resizerElem.style;
		    style.width = animData.w + 'px';
		    style.height = animData.h + 'px';
		    this.resizerElem = resizerElem;
		    styleDiv(resizerElem);
		    style.transformStyle = 'flat';
		    style.mozTransformStyle = 'flat';
		    style.webkitTransformStyle = 'flat';
		    if (this.renderConfig.className) {
		      resizerElem.setAttribute('class', this.renderConfig.className);
		    }
		    wrapper.appendChild(resizerElem);
		    style.overflow = 'hidden';
		    var svg = createNS('svg');
		    svg.setAttribute('width', '1');
		    svg.setAttribute('height', '1');
		    styleDiv(svg);
		    this.resizerElem.appendChild(svg);
		    var defs = createNS('defs');
		    svg.appendChild(defs);
		    this.data = animData;
		    // Mask animation
		    this.setupGlobalData(animData, svg);
		    this.globalData.defs = defs;
		    this.layers = animData.layers;
		    this.layerElement = this.resizerElem;
		    this.build3dContainers();
		    this.updateContainerSize();
		  };
		  HybridRendererBase.prototype.destroy = function () {
		    if (this.animationItem.wrapper) {
		      this.animationItem.wrapper.innerText = '';
		    }
		    this.animationItem.container = null;
		    this.globalData.defs = null;
		    var i;
		    var len = this.layers ? this.layers.length : 0;
		    for (i = 0; i < len; i += 1) {
		      if (this.elements[i] && this.elements[i].destroy) {
		        this.elements[i].destroy();
		      }
		    }
		    this.elements.length = 0;
		    this.destroyed = true;
		    this.animationItem = null;
		  };
		  HybridRendererBase.prototype.updateContainerSize = function () {
		    var elementWidth = this.animationItem.wrapper.offsetWidth;
		    var elementHeight = this.animationItem.wrapper.offsetHeight;
		    var elementRel = elementWidth / elementHeight;
		    var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
		    var sx;
		    var sy;
		    var tx;
		    var ty;
		    if (animationRel > elementRel) {
		      sx = elementWidth / this.globalData.compSize.w;
		      sy = elementWidth / this.globalData.compSize.w;
		      tx = 0;
		      ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
		    } else {
		      sx = elementHeight / this.globalData.compSize.h;
		      sy = elementHeight / this.globalData.compSize.h;
		      tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
		      ty = 0;
		    }
		    var style = this.resizerElem.style;
		    style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
		    style.transform = style.webkitTransform;
		  };
		  HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
		  HybridRendererBase.prototype.hide = function () {
		    this.resizerElem.style.display = 'none';
		  };
		  HybridRendererBase.prototype.show = function () {
		    this.resizerElem.style.display = 'block';
		  };
		  HybridRendererBase.prototype.initItems = function () {
		    this.buildAllItems();
		    if (this.camera) {
		      this.camera.setup();
		    } else {
		      var cWidth = this.globalData.compSize.w;
		      var cHeight = this.globalData.compSize.h;
		      var i;
		      var len = this.threeDElements.length;
		      for (i = 0; i < len; i += 1) {
		        var style = this.threeDElements[i].perspectiveElem.style;
		        style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
		        style.perspective = style.webkitPerspective;
		      }
		    }
		  };
		  HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
		    var i;
		    var len = assets.length;
		    var floatingContainer = createTag('div');
		    for (i = 0; i < len; i += 1) {
		      if (assets[i].xt) {
		        var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
		        comp.initExpressions();
		        this.globalData.projectInterface.registerComposition(comp);
		      }
		    }
		  };

		  function HCompElement(data, globalData, comp) {
		    this.layers = data.layers;
		    this.supports3d = !data.hasMask;
		    this.completeLayers = false;
		    this.pendingElements = [];
		    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
		    this.initElement(data, globalData, comp);
		    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
		      _placeholder: true
		    };
		  }
		  extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
		  HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
		  HCompElement.prototype.createContainerElements = function () {
		    this._createBaseContainerElements();
		    // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
		    if (this.data.hasMask) {
		      this.svgElement.setAttribute('width', this.data.w);
		      this.svgElement.setAttribute('height', this.data.h);
		      this.transformedElement = this.baseElement;
		    } else {
		      this.transformedElement = this.layerElement;
		    }
		  };
		  HCompElement.prototype.addTo3dContainer = function (elem, pos) {
		    var j = 0;
		    var nextElement;
		    while (j < pos) {
		      if (this.elements[j] && this.elements[j].getBaseElement) {
		        nextElement = this.elements[j].getBaseElement();
		      }
		      j += 1;
		    }
		    if (nextElement) {
		      this.layerElement.insertBefore(elem, nextElement);
		    } else {
		      this.layerElement.appendChild(elem);
		    }
		  };
		  HCompElement.prototype.createComp = function (data) {
		    if (!this.supports3d) {
		      return new SVGCompElement(data, this.globalData, this);
		    }
		    return new HCompElement(data, this.globalData, this);
		  };

		  function HybridRenderer(animationItem, config) {
		    this.animationItem = animationItem;
		    this.layers = null;
		    this.renderedFrame = -1;
		    this.renderConfig = {
		      className: config && config.className || '',
		      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
		      hideOnTransparent: !(config && config.hideOnTransparent === false),
		      filterSize: {
		        width: config && config.filterSize && config.filterSize.width || '400%',
		        height: config && config.filterSize && config.filterSize.height || '400%',
		        x: config && config.filterSize && config.filterSize.x || '-100%',
		        y: config && config.filterSize && config.filterSize.y || '-100%'
		      },
		      runExpressions: !config || config.runExpressions === undefined || config.runExpressions
		    };
		    this.globalData = {
		      _mdf: false,
		      frameNum: -1,
		      renderConfig: this.renderConfig
		    };
		    this.pendingElements = [];
		    this.elements = [];
		    this.threeDElements = [];
		    this.destroyed = false;
		    this.camera = null;
		    this.supports3d = true;
		    this.rendererType = 'html';
		  }
		  extendPrototype([HybridRendererBase], HybridRenderer);
		  HybridRenderer.prototype.createComp = function (data) {
		    if (!this.supports3d) {
		      return new SVGCompElement(data, this.globalData, this);
		    }
		    return new HCompElement(data, this.globalData, this);
		  };

		  var CompExpressionInterface = function () {
		    return function (comp) {
		      function _thisLayerFunction(name) {
		        var i = 0;
		        var len = comp.layers.length;
		        while (i < len) {
		          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
		            return comp.elements[i].layerInterface;
		          }
		          i += 1;
		        }
		        return null;
		        // return {active:false};
		      }
		      Object.defineProperty(_thisLayerFunction, '_name', {
		        value: comp.data.nm
		      });
		      _thisLayerFunction.layer = _thisLayerFunction;
		      _thisLayerFunction.pixelAspect = 1;
		      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
		      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
		      _thisLayerFunction.pixelAspect = 1;
		      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
		      _thisLayerFunction.displayStartTime = 0;
		      _thisLayerFunction.numLayers = comp.layers.length;
		      return _thisLayerFunction;
		    };
		  }();

		  function _typeof$2(o) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$2(o); }
		  /* eslint-disable */
		  /*
		   Copyright 2014 David Bau.

		   Permission is hereby granted, free of charge, to any person obtaining
		   a copy of this software and associated documentation files (the
		   "Software"), to deal in the Software without restriction, including
		   without limitation the rights to use, copy, modify, merge, publish,
		   distribute, sublicense, and/or sell copies of the Software, and to
		   permit persons to whom the Software is furnished to do so, subject to
		   the following conditions:

		   The above copyright notice and this permission notice shall be
		   included in all copies or substantial portions of the Software.

		   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
		   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
		   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

		   */

		  function seedRandom(pool, math) {
		    //
		    // The following constants are related to IEEE 754 limits.
		    //
		    var global = this,
		      width = 256,
		      // each RC4 output is 0 <= x < 256
		      chunks = 6,
		      // at least six RC4 outputs for each double
		      digits = 52,
		      // there are 52 significant digits in a double
		      rngname = 'random',
		      // rngname: name for Math.random and Math.seedrandom
		      startdenom = math.pow(width, chunks),
		      significance = math.pow(2, digits),
		      overflow = significance * 2,
		      mask = width - 1,
		      nodecrypto; // node.js crypto module, initialized at the bottom.

		    //
		    // seedrandom()
		    // This is the seedrandom function described above.
		    //
		    function seedrandom(seed, options, callback) {
		      var key = [];
		      options = options === true ? {
		        entropy: true
		      } : options || {};

		      // Flatten the seed string or build one from local entropy if needed.
		      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key);

		      // Use the seed to initialize an ARC4 generator.
		      var arc4 = new ARC4(key);

		      // This function returns a random double in [0, 1) that contains
		      // randomness in every bit of the mantissa of the IEEE 754 value.
		      var prng = function prng() {
		        var n = arc4.g(chunks),
		          // Start with a numerator n < 2 ^ 48
		          d = startdenom,
		          //   and denominator d = 2 ^ 48.
		          x = 0; //   and no 'extra last byte'.
		        while (n < significance) {
		          // Fill up all significant digits by
		          n = (n + x) * width; //   shifting numerator and
		          d *= width; //   denominator and generating a
		          x = arc4.g(1); //   new least-significant-byte.
		        }
		        while (n >= overflow) {
		          // To avoid rounding up, before adding
		          n /= 2; //   last byte, shift everything
		          d /= 2; //   right using integer math until
		          x >>>= 1; //   we have exactly the desired bits.
		        }
		        return (n + x) / d; // Form the number within [0, 1).
		      };
		      prng.int32 = function () {
		        return arc4.g(4) | 0;
		      };
		      prng.quick = function () {
		        return arc4.g(4) / 0x100000000;
		      };
		      prng["double"] = prng;

		      // Mix the randomness into accumulated entropy.
		      mixkey(tostring(arc4.S), pool);

		      // Calling convention: what to return as a function of prng, seed, is_math.
		      return (options.pass || callback || function (prng, seed, is_math_call, state) {
		        if (state) {
		          // Load the arc4 state from the given state if it has an S array.
		          if (state.S) {
		            copy(state, arc4);
		          }
		          // Only provide the .state method if requested via options.state.
		          prng.state = function () {
		            return copy(arc4, {});
		          };
		        }

		        // If called as a method of Math (Math.seedrandom()), mutate
		        // Math.random because that is how seedrandom.js has worked since v1.0.
		        if (is_math_call) {
		          math[rngname] = prng;
		          return seed;
		        }

		        // Otherwise, it is a newer calling convention, so return the
		        // prng directly.
		        else return prng;
		      })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
		    }
		    math['seed' + rngname] = seedrandom;

		    //
		    // ARC4
		    //
		    // An ARC4 implementation.  The constructor takes a key in the form of
		    // an array of at most (width) integers that should be 0 <= x < (width).
		    //
		    // The g(count) method returns a pseudorandom integer that concatenates
		    // the next (count) outputs from ARC4.  Its return value is a number x
		    // that is in the range 0 <= x < (width ^ count).
		    //
		    function ARC4(key) {
		      var t,
		        keylen = key.length,
		        me = this,
		        i = 0,
		        j = me.i = me.j = 0,
		        s = me.S = [];

		      // The empty key [] is treated as [0].
		      if (!keylen) {
		        key = [keylen++];
		      }

		      // Set up S using the standard key scheduling algorithm.
		      while (i < width) {
		        s[i] = i++;
		      }
		      for (i = 0; i < width; i++) {
		        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
		        s[j] = t;
		      }

		      // The "g" method returns the next (count) outputs as one number.
		      me.g = function (count) {
		        // Using instance members instead of closure state nearly doubles speed.
		        var t,
		          r = 0,
		          i = me.i,
		          j = me.j,
		          s = me.S;
		        while (count--) {
		          t = s[i = mask & i + 1];
		          r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
		        }
		        me.i = i;
		        me.j = j;
		        return r;
		        // For robust unpredictability, the function call below automatically
		        // discards an initial batch of values.  This is called RC4-drop[256].
		        // See http://google.com/search?q=rsa+fluhrer+response&btnI
		      };
		    }

		    //
		    // copy()
		    // Copies internal state of ARC4 to or from a plain object.
		    //
		    function copy(f, t) {
		      t.i = f.i;
		      t.j = f.j;
		      t.S = f.S.slice();
		      return t;
		    }

		    //
		    // flatten()
		    // Converts an object tree to nested arrays of strings.
		    //
		    function flatten(obj, depth) {
		      var result = [],
		        typ = _typeof$2(obj),
		        prop;
		      if (depth && typ == 'object') {
		        for (prop in obj) {
		          try {
		            result.push(flatten(obj[prop], depth - 1));
		          } catch (e) {}
		        }
		      }
		      return result.length ? result : typ == 'string' ? obj : obj + '\0';
		    }

		    //
		    // mixkey()
		    // Mixes a string seed into a key that is an array of integers, and
		    // returns a shortened string seed that is equivalent to the result key.
		    //
		    function mixkey(seed, key) {
		      var stringseed = seed + '',
		        smear,
		        j = 0;
		      while (j < stringseed.length) {
		        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
		      }
		      return tostring(key);
		    }

		    //
		    // autoseed()
		    // Returns an object for autoseeding, using window.crypto and Node crypto
		    // module if available.
		    //
		    function autoseed() {
		      try {
		        if (nodecrypto) ;
		        var out = new Uint8Array(width);
		        (global.crypto || global.msCrypto).getRandomValues(out);
		        return tostring(out);
		      } catch (e) {
		        var browser = global.navigator,
		          plugins = browser && browser.plugins;
		        return [+new Date(), global, plugins, global.screen, tostring(pool)];
		      }
		    }

		    //
		    // tostring()
		    // Converts an array of charcodes to a string
		    //
		    function tostring(a) {
		      return String.fromCharCode.apply(0, a);
		    }

		    //
		    // When seedrandom.js is loaded, we immediately mix a few bits
		    // from the built-in RNG into the entropy pool.  Because we do
		    // not want to interfere with deterministic PRNG state later,
		    // seedrandom will not call math.random on its own again after
		    // initialization.
		    //
		    mixkey(math.random(), pool);

		    //
		    // Nodejs and AMD support: export the implementation as a module using
		    // either convention.
		    //

		    // End anonymous scope, and pass initial values.
		  }
		  function initialize$2(BMMath) {
		    seedRandom([], BMMath);
		  }

		  var propTypes = {
		    SHAPE: 'shape'
		  };

		  function _typeof$1(o) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$1(o); }
		  var ExpressionManager = function () {

		    var ob = {};
		    var Math = BMMath;
		    var window = null;
		    var document = null;
		    var XMLHttpRequest = null;
		    var fetch = null;
		    var frames = null;
		    var _lottieGlobal = {};
		    initialize$2(BMMath);
		    function resetFrame() {
		      _lottieGlobal = {};
		    }
		    function $bm_isInstanceOfArray(arr) {
		      return arr.constructor === Array || arr.constructor === Float32Array;
		    }
		    function isNumerable(tOfV, v) {
		      return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';
		    }
		    function $bm_neg(a) {
		      var tOfA = _typeof$1(a);
		      if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {
		        return -a;
		      }
		      if ($bm_isInstanceOfArray(a)) {
		        var i;
		        var lenA = a.length;
		        var retArr = [];
		        for (i = 0; i < lenA; i += 1) {
		          retArr[i] = -a[i];
		        }
		        return retArr;
		      }
		      if (a.propType) {
		        return a.v;
		      }
		      return -a;
		    }
		    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
		    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
		    var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;
		    function sum(a, b) {
		      var tOfA = _typeof$1(a);
		      var tOfB = _typeof$1(b);
		      if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {
		        return a + b;
		      }
		      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
		        a = a.slice(0);
		        a[0] += b;
		        return a;
		      }
		      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
		        b = b.slice(0);
		        b[0] = a + b[0];
		        return b;
		      }
		      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
		        var i = 0;
		        var lenA = a.length;
		        var lenB = b.length;
		        var retArr = [];
		        while (i < lenA || i < lenB) {
		          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
		            retArr[i] = a[i] + b[i];
		          } else {
		            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
		          }
		          i += 1;
		        }
		        return retArr;
		      }
		      return 0;
		    }
		    var add = sum;
		    function sub(a, b) {
		      var tOfA = _typeof$1(a);
		      var tOfB = _typeof$1(b);
		      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
		        if (tOfA === 'string') {
		          a = parseInt(a, 10);
		        }
		        if (tOfB === 'string') {
		          b = parseInt(b, 10);
		        }
		        return a - b;
		      }
		      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
		        a = a.slice(0);
		        a[0] -= b;
		        return a;
		      }
		      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
		        b = b.slice(0);
		        b[0] = a - b[0];
		        return b;
		      }
		      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
		        var i = 0;
		        var lenA = a.length;
		        var lenB = b.length;
		        var retArr = [];
		        while (i < lenA || i < lenB) {
		          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
		            retArr[i] = a[i] - b[i];
		          } else {
		            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
		          }
		          i += 1;
		        }
		        return retArr;
		      }
		      return 0;
		    }
		    function mul(a, b) {
		      var tOfA = _typeof$1(a);
		      var tOfB = _typeof$1(b);
		      var arr;
		      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
		        return a * b;
		      }
		      var i;
		      var len;
		      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
		        len = a.length;
		        arr = createTypedArray('float32', len);
		        for (i = 0; i < len; i += 1) {
		          arr[i] = a[i] * b;
		        }
		        return arr;
		      }
		      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
		        len = b.length;
		        arr = createTypedArray('float32', len);
		        for (i = 0; i < len; i += 1) {
		          arr[i] = a * b[i];
		        }
		        return arr;
		      }
		      return 0;
		    }
		    function div(a, b) {
		      var tOfA = _typeof$1(a);
		      var tOfB = _typeof$1(b);
		      var arr;
		      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
		        return a / b;
		      }
		      var i;
		      var len;
		      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
		        len = a.length;
		        arr = createTypedArray('float32', len);
		        for (i = 0; i < len; i += 1) {
		          arr[i] = a[i] / b;
		        }
		        return arr;
		      }
		      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
		        len = b.length;
		        arr = createTypedArray('float32', len);
		        for (i = 0; i < len; i += 1) {
		          arr[i] = a / b[i];
		        }
		        return arr;
		      }
		      return 0;
		    }
		    function mod(a, b) {
		      if (typeof a === 'string') {
		        a = parseInt(a, 10);
		      }
		      if (typeof b === 'string') {
		        b = parseInt(b, 10);
		      }
		      return a % b;
		    }
		    var $bm_sum = sum;
		    var $bm_sub = sub;
		    var $bm_mul = mul;
		    var $bm_div = div;
		    var $bm_mod = mod;
		    function clamp(num, min, max) {
		      if (min > max) {
		        var mm = max;
		        max = min;
		        min = mm;
		      }
		      return Math.min(Math.max(num, min), max);
		    }
		    function radiansToDegrees(val) {
		      return val / degToRads;
		    }
		    var radians_to_degrees = radiansToDegrees;
		    function degreesToRadians(val) {
		      return val * degToRads;
		    }
		    var degrees_to_radians = radiansToDegrees;
		    var helperLengthArray = [0, 0, 0, 0, 0, 0];
		    function length(arr1, arr2) {
		      if (typeof arr1 === 'number' || arr1 instanceof Number) {
		        arr2 = arr2 || 0;
		        return Math.abs(arr1 - arr2);
		      }
		      if (!arr2) {
		        arr2 = helperLengthArray;
		      }
		      var i;
		      var len = Math.min(arr1.length, arr2.length);
		      var addedLength = 0;
		      for (i = 0; i < len; i += 1) {
		        addedLength += Math.pow(arr2[i] - arr1[i], 2);
		      }
		      return Math.sqrt(addedLength);
		    }
		    function normalize(vec) {
		      return div(vec, length(vec));
		    }
		    function rgbToHsl(val) {
		      var r = val[0];
		      var g = val[1];
		      var b = val[2];
		      var max = Math.max(r, g, b);
		      var min = Math.min(r, g, b);
		      var h;
		      var s;
		      var l = (max + min) / 2;
		      if (max === min) {
		        h = 0; // achromatic
		        s = 0; // achromatic
		      } else {
		        var d = max - min;
		        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		        switch (max) {
		          case r:
		            h = (g - b) / d + (g < b ? 6 : 0);
		            break;
		          case g:
		            h = (b - r) / d + 2;
		            break;
		          case b:
		            h = (r - g) / d + 4;
		            break;
		        }
		        h /= 6;
		      }
		      return [h, s, l, val[3]];
		    }
		    function hue2rgb(p, q, t) {
		      if (t < 0) t += 1;
		      if (t > 1) t -= 1;
		      if (t < 1 / 6) return p + (q - p) * 6 * t;
		      if (t < 1 / 2) return q;
		      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
		      return p;
		    }
		    function hslToRgb(val) {
		      var h = val[0];
		      var s = val[1];
		      var l = val[2];
		      var r;
		      var g;
		      var b;
		      if (s === 0) {
		        r = l; // achromatic
		        b = l; // achromatic
		        g = l; // achromatic
		      } else {
		        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		        var p = 2 * l - q;
		        r = hue2rgb(p, q, h + 1 / 3);
		        g = hue2rgb(p, q, h);
		        b = hue2rgb(p, q, h - 1 / 3);
		      }
		      return [r, g, b, val[3]];
		    }
		    function linear(t, tMin, tMax, value1, value2) {
		      if (value1 === undefined || value2 === undefined) {
		        value1 = tMin;
		        value2 = tMax;
		        tMin = 0;
		        tMax = 1;
		      }
		      if (tMax < tMin) {
		        var _tMin = tMax;
		        tMax = tMin;
		        tMin = _tMin;
		      }
		      if (t <= tMin) {
		        return value1;
		      }
		      if (t >= tMax) {
		        return value2;
		      }
		      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
		      if (!value1.length) {
		        return value1 + (value2 - value1) * perc;
		      }
		      var i;
		      var len = value1.length;
		      var arr = createTypedArray('float32', len);
		      for (i = 0; i < len; i += 1) {
		        arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
		      }
		      return arr;
		    }
		    function random(min, max) {
		      if (max === undefined) {
		        if (min === undefined) {
		          min = 0;
		          max = 1;
		        } else {
		          max = min;
		          min = undefined;
		        }
		      }
		      if (max.length) {
		        var i;
		        var len = max.length;
		        if (!min) {
		          min = createTypedArray('float32', len);
		        }
		        var arr = createTypedArray('float32', len);
		        var rnd = BMMath.random();
		        for (i = 0; i < len; i += 1) {
		          arr[i] = min[i] + rnd * (max[i] - min[i]);
		        }
		        return arr;
		      }
		      if (min === undefined) {
		        min = 0;
		      }
		      var rndm = BMMath.random();
		      return min + rndm * (max - min);
		    }
		    function createPath(points, inTangents, outTangents, closed) {
		      var i;
		      var len = points.length;
		      var path = shapePool.newElement();
		      path.setPathData(!!closed, len);
		      var arrPlaceholder = [0, 0];
		      var inVertexPoint;
		      var outVertexPoint;
		      for (i = 0; i < len; i += 1) {
		        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
		        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
		        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
		      }
		      return path;
		    }
		    function initiateExpression(elem, data, property) {
		      // Bail out if we don't want expressions
		      function noOp(_value) {
		        return _value;
		      }
		      if (!elem.globalData.renderConfig.runExpressions) {
		        return noOp;
		      }
		      var val = data.x;
		      var needsVelocity = /velocity(?![\w\d])/.test(val);
		      var _needsRandom = val.indexOf('random') !== -1;
		      var elemType = elem.data.ty;
		      var transform;
		      var $bm_transform;
		      var content;
		      var effect;
		      var thisProperty = property;
		      thisProperty._name = elem.data.nm;
		      thisProperty.valueAtTime = thisProperty.getValueAtTime;
		      Object.defineProperty(thisProperty, 'value', {
		        get: function get() {
		          return thisProperty.v;
		        }
		      });
		      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
		      elem.comp.displayStartTime = 0;
		      var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
		      var outPoint = elem.data.op / elem.comp.globalData.frameRate;
		      var width = elem.data.sw ? elem.data.sw : 0;
		      var height = elem.data.sh ? elem.data.sh : 0;
		      var name = elem.data.nm;
		      var loopIn;
		      var loop_in;
		      var loopOut;
		      var loop_out;
		      var smooth;
		      var toWorld;
		      var fromWorld;
		      var fromComp;
		      var toComp;
		      var fromCompToSurface;
		      var position;
		      var rotation;
		      var anchorPoint;
		      var scale;
		      var thisLayer;
		      var thisComp;
		      var mask;
		      var valueAtTime;
		      var velocityAtTime;
		      var scoped_bm_rt;
		      // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
		      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
		      var numKeys = property.kf ? data.k.length : 0;
		      var active = !this.data || this.data.hd !== true;
		      var wiggle = function wiggle(freq, amp) {
		        var iWiggle;
		        var j;
		        var lenWiggle = this.pv.length ? this.pv.length : 1;
		        var addedAmps = createTypedArray('float32', lenWiggle);
		        freq = 5;
		        var iterations = Math.floor(time * freq);
		        iWiggle = 0;
		        j = 0;
		        while (iWiggle < iterations) {
		          // var rnd = BMMath.random();
		          for (j = 0; j < lenWiggle; j += 1) {
		            addedAmps[j] += -amp + amp * 2 * BMMath.random();
		            // addedAmps[j] += -amp + amp*2*rnd;
		          }
		          iWiggle += 1;
		        }
		        // var rnd2 = BMMath.random();
		        var periods = time * freq;
		        var perc = periods - Math.floor(periods);
		        var arr = createTypedArray('float32', lenWiggle);
		        if (lenWiggle > 1) {
		          for (j = 0; j < lenWiggle; j += 1) {
		            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
		            // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
		            // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
		          }
		          return arr;
		        }
		        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
		      }.bind(this);
		      if (thisProperty.loopIn) {
		        loopIn = thisProperty.loopIn.bind(thisProperty);
		        loop_in = loopIn;
		      }
		      if (thisProperty.loopOut) {
		        loopOut = thisProperty.loopOut.bind(thisProperty);
		        loop_out = loopOut;
		      }
		      if (thisProperty.smooth) {
		        smooth = thisProperty.smooth.bind(thisProperty);
		      }
		      function loopInDuration(type, duration) {
		        return loopIn(type, duration, true);
		      }
		      function loopOutDuration(type, duration) {
		        return loopOut(type, duration, true);
		      }
		      if (this.getValueAtTime) {
		        valueAtTime = this.getValueAtTime.bind(this);
		      }
		      if (this.getVelocityAtTime) {
		        velocityAtTime = this.getVelocityAtTime.bind(this);
		      }
		      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
		      function lookAt(elem1, elem2) {
		        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
		        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
		        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
		        return [yaw, pitch, 0];
		      }
		      function easeOut(t, tMin, tMax, val1, val2) {
		        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
		      }
		      function easeIn(t, tMin, tMax, val1, val2) {
		        return applyEase(easeInBez, t, tMin, tMax, val1, val2);
		      }
		      function ease(t, tMin, tMax, val1, val2) {
		        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
		      }
		      function applyEase(fn, t, tMin, tMax, val1, val2) {
		        if (val1 === undefined) {
		          val1 = tMin;
		          val2 = tMax;
		        } else {
		          t = (t - tMin) / (tMax - tMin);
		        }
		        if (t > 1) {
		          t = 1;
		        } else if (t < 0) {
		          t = 0;
		        }
		        var mult = fn(t);
		        if ($bm_isInstanceOfArray(val1)) {
		          var iKey;
		          var lenKey = val1.length;
		          var arr = createTypedArray('float32', lenKey);
		          for (iKey = 0; iKey < lenKey; iKey += 1) {
		            arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
		          }
		          return arr;
		        }
		        return (val2 - val1) * mult + val1;
		      }
		      function nearestKey(time) {
		        var iKey;
		        var lenKey = data.k.length;
		        var index;
		        var keyTime;
		        if (!data.k.length || typeof data.k[0] === 'number') {
		          index = 0;
		          keyTime = 0;
		        } else {
		          index = -1;
		          time *= elem.comp.globalData.frameRate;
		          if (time < data.k[0].t) {
		            index = 1;
		            keyTime = data.k[0].t;
		          } else {
		            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
		              if (time === data.k[iKey].t) {
		                index = iKey + 1;
		                keyTime = data.k[iKey].t;
		                break;
		              } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
		                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
		                  index = iKey + 2;
		                  keyTime = data.k[iKey + 1].t;
		                } else {
		                  index = iKey + 1;
		                  keyTime = data.k[iKey].t;
		                }
		                break;
		              }
		            }
		            if (index === -1) {
		              index = iKey + 1;
		              keyTime = data.k[iKey].t;
		            }
		          }
		        }
		        var obKey = {};
		        obKey.index = index;
		        obKey.time = keyTime / elem.comp.globalData.frameRate;
		        return obKey;
		      }
		      function key(ind) {
		        var obKey;
		        var iKey;
		        var lenKey;
		        if (!data.k.length || typeof data.k[0] === 'number') {
		          throw new Error('The property has no keyframe at index ' + ind);
		        }
		        ind -= 1;
		        obKey = {
		          time: data.k[ind].t / elem.comp.globalData.frameRate,
		          value: []
		        };
		        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;
		        lenKey = arr.length;
		        for (iKey = 0; iKey < lenKey; iKey += 1) {
		          obKey[iKey] = arr[iKey];
		          obKey.value[iKey] = arr[iKey];
		        }
		        return obKey;
		      }
		      function framesToTime(fr, fps) {
		        if (!fps) {
		          fps = elem.comp.globalData.frameRate;
		        }
		        return fr / fps;
		      }
		      function timeToFrames(t, fps) {
		        if (!t && t !== 0) {
		          t = time;
		        }
		        if (!fps) {
		          fps = elem.comp.globalData.frameRate;
		        }
		        return t * fps;
		      }
		      function seedRandom(seed) {
		        BMMath.seedrandom(randSeed + seed);
		      }
		      function sourceRectAtTime() {
		        return elem.sourceRectAtTime();
		      }
		      function substring(init, end) {
		        if (typeof value === 'string') {
		          if (end === undefined) {
		            return value.substring(init);
		          }
		          return value.substring(init, end);
		        }
		        return '';
		      }
		      function substr(init, end) {
		        if (typeof value === 'string') {
		          if (end === undefined) {
		            return value.substr(init);
		          }
		          return value.substr(init, end);
		        }
		        return '';
		      }
		      function posterizeTime(framesPerSecond) {
		        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
		        value = valueAtTime(time);
		      }
		      var time;
		      var velocity;
		      var value;
		      var text;
		      var textIndex;
		      var textTotal;
		      var selectorValue;
		      var index = elem.data.ind;
		      var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
		      var parent;
		      var randSeed = Math.floor(Math.random() * 1000000);
		      var globalData = elem.globalData;
		      function executeExpression(_value) {
		        // globalData.pushExpression();
		        value = _value;
		        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
		          return value;
		        }
		        if (this.propType === 'textSelector') {
		          textIndex = this.textIndex;
		          textTotal = this.textTotal;
		          selectorValue = this.selectorValue;
		        }
		        if (!thisLayer) {
		          text = elem.layerInterface.text;
		          thisLayer = elem.layerInterface;
		          thisComp = elem.comp.compInterface;
		          toWorld = thisLayer.toWorld.bind(thisLayer);
		          fromWorld = thisLayer.fromWorld.bind(thisLayer);
		          fromComp = thisLayer.fromComp.bind(thisLayer);
		          toComp = thisLayer.toComp.bind(thisLayer);
		          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
		          fromCompToSurface = fromComp;
		        }
		        if (!transform) {
		          transform = elem.layerInterface('ADBE Transform Group');
		          $bm_transform = transform;
		          if (transform) {
		            anchorPoint = transform.anchorPoint;
		            /* position = transform.position;
		                      rotation = transform.rotation;
		                      scale = transform.scale; */
		          }
		        }
		        if (elemType === 4 && !content) {
		          content = thisLayer('ADBE Root Vectors Group');
		        }
		        if (!effect) {
		          effect = thisLayer(4);
		        }
		        hasParent = !!(elem.hierarchy && elem.hierarchy.length);
		        if (hasParent && !parent) {
		          parent = elem.hierarchy[0].layerInterface;
		        }
		        time = this.comp.renderedFrame / this.comp.globalData.frameRate;
		        if (_needsRandom) {
		          seedRandom(randSeed + time);
		        }
		        if (needsVelocity) {
		          velocity = velocityAtTime(time);
		        }
		        expression_function();
		        this.frameExpressionId = elem.globalData.frameId;

		        // TODO: Check if it's possible to return on ShapeInterface the .v value
		        // Changed this to a ternary operation because Rollup failed compiling it correctly
		        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
		        return scoped_bm_rt;
		      }
		      // Bundlers will see these as dead code and unless we reference them
		      executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
		      return executeExpression;
		    }
		    ob.initiateExpression = initiateExpression;
		    ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
		    ob.resetFrame = resetFrame;
		    return ob;
		  }();

		  var Expressions = function () {
		    var ob = {};
		    ob.initExpressions = initExpressions;
		    ob.resetFrame = ExpressionManager.resetFrame;
		    function initExpressions(animation) {
		      var stackCount = 0;
		      var registers = [];
		      function pushExpression() {
		        stackCount += 1;
		      }
		      function popExpression() {
		        stackCount -= 1;
		        if (stackCount === 0) {
		          releaseInstances();
		        }
		      }
		      function registerExpressionProperty(expression) {
		        if (registers.indexOf(expression) === -1) {
		          registers.push(expression);
		        }
		      }
		      function releaseInstances() {
		        var i;
		        var len = registers.length;
		        for (i = 0; i < len; i += 1) {
		          registers[i].release();
		        }
		        registers.length = 0;
		      }
		      animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
		      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
		      animation.renderer.globalData.pushExpression = pushExpression;
		      animation.renderer.globalData.popExpression = popExpression;
		      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
		    }
		    return ob;
		  }();

		  var MaskManagerInterface = function () {
		    function MaskInterface(mask, data) {
		      this._mask = mask;
		      this._data = data;
		    }
		    Object.defineProperty(MaskInterface.prototype, 'maskPath', {
		      get: function get() {
		        if (this._mask.prop.k) {
		          this._mask.prop.getValue();
		        }
		        return this._mask.prop;
		      }
		    });
		    Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
		      get: function get() {
		        if (this._mask.op.k) {
		          this._mask.op.getValue();
		        }
		        return this._mask.op.v * 100;
		      }
		    });
		    var MaskManager = function MaskManager(maskManager) {
		      var _masksInterfaces = createSizedArray(maskManager.viewData.length);
		      var i;
		      var len = maskManager.viewData.length;
		      for (i = 0; i < len; i += 1) {
		        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
		      }
		      var maskFunction = function maskFunction(name) {
		        i = 0;
		        while (i < len) {
		          if (maskManager.masksProperties[i].nm === name) {
		            return _masksInterfaces[i];
		          }
		          i += 1;
		        }
		        return null;
		      };
		      return maskFunction;
		    };
		    return MaskManager;
		  }();

		  var ExpressionPropertyInterface = function () {
		    var defaultUnidimensionalValue = {
		      pv: 0,
		      v: 0,
		      mult: 1
		    };
		    var defaultMultidimensionalValue = {
		      pv: [0, 0, 0],
		      v: [0, 0, 0],
		      mult: 1
		    };
		    function completeProperty(expressionValue, property, type) {
		      Object.defineProperty(expressionValue, 'velocity', {
		        get: function get() {
		          return property.getVelocityAtTime(property.comp.currentFrame);
		        }
		      });
		      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
		      expressionValue.key = function (pos) {
		        if (!expressionValue.numKeys) {
		          return 0;
		        }
		        var value = '';
		        if ('s' in property.keyframes[pos - 1]) {
		          value = property.keyframes[pos - 1].s;
		        } else if ('e' in property.keyframes[pos - 2]) {
		          value = property.keyframes[pos - 2].e;
		        } else {
		          value = property.keyframes[pos - 2].s;
		        }
		        var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
		        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
		        valueProp.value = type === 'unidimensional' ? value[0] : value;
		        return valueProp;
		      };
		      expressionValue.valueAtTime = property.getValueAtTime;
		      expressionValue.speedAtTime = property.getSpeedAtTime;
		      expressionValue.velocityAtTime = property.getVelocityAtTime;
		      expressionValue.propertyGroup = property.propertyGroup;
		    }
		    function UnidimensionalPropertyInterface(property) {
		      if (!property || !('pv' in property)) {
		        property = defaultUnidimensionalValue;
		      }
		      var mult = 1 / property.mult;
		      var val = property.pv * mult;
		      var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
		      expressionValue.value = val;
		      completeProperty(expressionValue, property, 'unidimensional');
		      return function () {
		        if (property.k) {
		          property.getValue();
		        }
		        val = property.v * mult;
		        if (expressionValue.value !== val) {
		          expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
		          expressionValue.value = val;
		          expressionValue[0] = val;
		          completeProperty(expressionValue, property, 'unidimensional');
		        }
		        return expressionValue;
		      };
		    }
		    function MultidimensionalPropertyInterface(property) {
		      if (!property || !('pv' in property)) {
		        property = defaultMultidimensionalValue;
		      }
		      var mult = 1 / property.mult;
		      var len = property.data && property.data.l || property.pv.length;
		      var expressionValue = createTypedArray('float32', len);
		      var arrValue = createTypedArray('float32', len);
		      expressionValue.value = arrValue;
		      completeProperty(expressionValue, property, 'multidimensional');
		      return function () {
		        if (property.k) {
		          property.getValue();
		        }
		        for (var i = 0; i < len; i += 1) {
		          arrValue[i] = property.v[i] * mult;
		          expressionValue[i] = arrValue[i];
		        }
		        return expressionValue;
		      };
		    }

		    // TODO: try to avoid using this getter
		    function defaultGetter() {
		      return defaultUnidimensionalValue;
		    }
		    return function (property) {
		      if (!property) {
		        return defaultGetter;
		      }
		      if (property.propType === 'unidimensional') {
		        return UnidimensionalPropertyInterface(property);
		      }
		      return MultidimensionalPropertyInterface(property);
		    };
		  }();

		  var TransformExpressionInterface = function () {
		    return function (transform) {
		      function _thisFunction(name) {
		        switch (name) {
		          case 'scale':
		          case 'Scale':
		          case 'ADBE Scale':
		          case 6:
		            return _thisFunction.scale;
		          case 'rotation':
		          case 'Rotation':
		          case 'ADBE Rotation':
		          case 'ADBE Rotate Z':
		          case 10:
		            return _thisFunction.rotation;
		          case 'ADBE Rotate X':
		            return _thisFunction.xRotation;
		          case 'ADBE Rotate Y':
		            return _thisFunction.yRotation;
		          case 'position':
		          case 'Position':
		          case 'ADBE Position':
		          case 2:
		            return _thisFunction.position;
		          case 'ADBE Position_0':
		            return _thisFunction.xPosition;
		          case 'ADBE Position_1':
		            return _thisFunction.yPosition;
		          case 'ADBE Position_2':
		            return _thisFunction.zPosition;
		          case 'anchorPoint':
		          case 'AnchorPoint':
		          case 'Anchor Point':
		          case 'ADBE AnchorPoint':
		          case 1:
		            return _thisFunction.anchorPoint;
		          case 'opacity':
		          case 'Opacity':
		          case 11:
		            return _thisFunction.opacity;
		          default:
		            return null;
		        }
		      }
		      Object.defineProperty(_thisFunction, 'rotation', {
		        get: ExpressionPropertyInterface(transform.r || transform.rz)
		      });
		      Object.defineProperty(_thisFunction, 'zRotation', {
		        get: ExpressionPropertyInterface(transform.rz || transform.r)
		      });
		      Object.defineProperty(_thisFunction, 'xRotation', {
		        get: ExpressionPropertyInterface(transform.rx)
		      });
		      Object.defineProperty(_thisFunction, 'yRotation', {
		        get: ExpressionPropertyInterface(transform.ry)
		      });
		      Object.defineProperty(_thisFunction, 'scale', {
		        get: ExpressionPropertyInterface(transform.s)
		      });
		      var _px;
		      var _py;
		      var _pz;
		      var _transformFactory;
		      if (transform.p) {
		        _transformFactory = ExpressionPropertyInterface(transform.p);
		      } else {
		        _px = ExpressionPropertyInterface(transform.px);
		        _py = ExpressionPropertyInterface(transform.py);
		        if (transform.pz) {
		          _pz = ExpressionPropertyInterface(transform.pz);
		        }
		      }
		      Object.defineProperty(_thisFunction, 'position', {
		        get: function get() {
		          if (transform.p) {
		            return _transformFactory();
		          }
		          return [_px(), _py(), _pz ? _pz() : 0];
		        }
		      });
		      Object.defineProperty(_thisFunction, 'xPosition', {
		        get: ExpressionPropertyInterface(transform.px)
		      });
		      Object.defineProperty(_thisFunction, 'yPosition', {
		        get: ExpressionPropertyInterface(transform.py)
		      });
		      Object.defineProperty(_thisFunction, 'zPosition', {
		        get: ExpressionPropertyInterface(transform.pz)
		      });
		      Object.defineProperty(_thisFunction, 'anchorPoint', {
		        get: ExpressionPropertyInterface(transform.a)
		      });
		      Object.defineProperty(_thisFunction, 'opacity', {
		        get: ExpressionPropertyInterface(transform.o)
		      });
		      Object.defineProperty(_thisFunction, 'skew', {
		        get: ExpressionPropertyInterface(transform.sk)
		      });
		      Object.defineProperty(_thisFunction, 'skewAxis', {
		        get: ExpressionPropertyInterface(transform.sa)
		      });
		      Object.defineProperty(_thisFunction, 'orientation', {
		        get: ExpressionPropertyInterface(transform.or)
		      });
		      return _thisFunction;
		    };
		  }();

		  var LayerExpressionInterface = function () {
		    function getMatrix(time) {
		      var toWorldMat = new Matrix();
		      if (time !== undefined) {
		        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
		        propMatrix.clone(toWorldMat);
		      } else {
		        var transformMat = this._elem.finalTransform.mProp;
		        transformMat.applyToMatrix(toWorldMat);
		      }
		      return toWorldMat;
		    }
		    function toWorldVec(arr, time) {
		      var toWorldMat = this.getMatrix(time);
		      toWorldMat.props[12] = 0;
		      toWorldMat.props[13] = 0;
		      toWorldMat.props[14] = 0;
		      return this.applyPoint(toWorldMat, arr);
		    }
		    function toWorld(arr, time) {
		      var toWorldMat = this.getMatrix(time);
		      return this.applyPoint(toWorldMat, arr);
		    }
		    function fromWorldVec(arr, time) {
		      var toWorldMat = this.getMatrix(time);
		      toWorldMat.props[12] = 0;
		      toWorldMat.props[13] = 0;
		      toWorldMat.props[14] = 0;
		      return this.invertPoint(toWorldMat, arr);
		    }
		    function fromWorld(arr, time) {
		      var toWorldMat = this.getMatrix(time);
		      return this.invertPoint(toWorldMat, arr);
		    }
		    function applyPoint(matrix, arr) {
		      if (this._elem.hierarchy && this._elem.hierarchy.length) {
		        var i;
		        var len = this._elem.hierarchy.length;
		        for (i = 0; i < len; i += 1) {
		          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
		        }
		      }
		      return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
		    }
		    function invertPoint(matrix, arr) {
		      if (this._elem.hierarchy && this._elem.hierarchy.length) {
		        var i;
		        var len = this._elem.hierarchy.length;
		        for (i = 0; i < len; i += 1) {
		          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
		        }
		      }
		      return matrix.inversePoint(arr);
		    }
		    function fromComp(arr) {
		      var toWorldMat = new Matrix();
		      toWorldMat.reset();
		      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
		      if (this._elem.hierarchy && this._elem.hierarchy.length) {
		        var i;
		        var len = this._elem.hierarchy.length;
		        for (i = 0; i < len; i += 1) {
		          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
		        }
		        return toWorldMat.inversePoint(arr);
		      }
		      return toWorldMat.inversePoint(arr);
		    }
		    function sampleImage() {
		      return [1, 1, 1, 1];
		    }
		    return function (elem) {
		      var transformInterface;
		      function _registerMaskInterface(maskManager) {
		        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
		      }
		      function _registerEffectsInterface(effects) {
		        _thisLayerFunction.effect = effects;
		      }
		      function _thisLayerFunction(name) {
		        switch (name) {
		          case 'ADBE Root Vectors Group':
		          case 'Contents':
		          case 2:
		            return _thisLayerFunction.shapeInterface;
		          case 1:
		          case 6:
		          case 'Transform':
		          case 'transform':
		          case 'ADBE Transform Group':
		            return transformInterface;
		          case 4:
		          case 'ADBE Effect Parade':
		          case 'effects':
		          case 'Effects':
		            return _thisLayerFunction.effect;
		          case 'ADBE Text Properties':
		            return _thisLayerFunction.textInterface;
		          default:
		            return null;
		        }
		      }
		      _thisLayerFunction.getMatrix = getMatrix;
		      _thisLayerFunction.invertPoint = invertPoint;
		      _thisLayerFunction.applyPoint = applyPoint;
		      _thisLayerFunction.toWorld = toWorld;
		      _thisLayerFunction.toWorldVec = toWorldVec;
		      _thisLayerFunction.fromWorld = fromWorld;
		      _thisLayerFunction.fromWorldVec = fromWorldVec;
		      _thisLayerFunction.toComp = toWorld;
		      _thisLayerFunction.fromComp = fromComp;
		      _thisLayerFunction.sampleImage = sampleImage;
		      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
		      _thisLayerFunction._elem = elem;
		      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
		      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
		      Object.defineProperties(_thisLayerFunction, {
		        hasParent: {
		          get: function get() {
		            return elem.hierarchy.length;
		          }
		        },
		        parent: {
		          get: function get() {
		            return elem.hierarchy[0].layerInterface;
		          }
		        },
		        rotation: getDescriptor(transformInterface, 'rotation'),
		        scale: getDescriptor(transformInterface, 'scale'),
		        position: getDescriptor(transformInterface, 'position'),
		        opacity: getDescriptor(transformInterface, 'opacity'),
		        anchorPoint: anchorPointDescriptor,
		        anchor_point: anchorPointDescriptor,
		        transform: {
		          get: function get() {
		            return transformInterface;
		          }
		        },
		        active: {
		          get: function get() {
		            return elem.isInRange;
		          }
		        }
		      });
		      _thisLayerFunction.startTime = elem.data.st;
		      _thisLayerFunction.index = elem.data.ind;
		      _thisLayerFunction.source = elem.data.refId;
		      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
		      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
		      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
		      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
		      _thisLayerFunction._name = elem.data.nm;
		      _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
		      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
		      return _thisLayerFunction;
		    };
		  }();

		  var propertyGroupFactory = function () {
		    return function (interfaceFunction, parentPropertyGroup) {
		      return function (val) {
		        val = val === undefined ? 1 : val;
		        if (val <= 0) {
		          return interfaceFunction;
		        }
		        return parentPropertyGroup(val - 1);
		      };
		    };
		  }();

		  var PropertyInterface = function () {
		    return function (propertyName, propertyGroup) {
		      var interfaceFunction = {
		        _name: propertyName
		      };
		      function _propertyGroup(val) {
		        val = val === undefined ? 1 : val;
		        if (val <= 0) {
		          return interfaceFunction;
		        }
		        return propertyGroup(val - 1);
		      }
		      return _propertyGroup;
		    };
		  }();

		  var EffectsExpressionInterface = function () {
		    var ob = {
		      createEffectsInterface: createEffectsInterface
		    };
		    function createEffectsInterface(elem, propertyGroup) {
		      if (elem.effectsManager) {
		        var effectElements = [];
		        var effectsData = elem.data.ef;
		        var i;
		        var len = elem.effectsManager.effectElements.length;
		        for (i = 0; i < len; i += 1) {
		          effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
		        }
		        var effects = elem.data.ef || [];
		        var groupInterface = function groupInterface(name) {
		          i = 0;
		          len = effects.length;
		          while (i < len) {
		            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
		              return effectElements[i];
		            }
		            i += 1;
		          }
		          return null;
		        };
		        Object.defineProperty(groupInterface, 'numProperties', {
		          get: function get() {
		            return effects.length;
		          }
		        });
		        return groupInterface;
		      }
		      return null;
		    }
		    function createGroupInterface(data, elements, propertyGroup, elem) {
		      function groupInterface(name) {
		        var effects = data.ef;
		        var i = 0;
		        var len = effects.length;
		        while (i < len) {
		          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
		            if (effects[i].ty === 5) {
		              return effectElements[i];
		            }
		            return effectElements[i]();
		          }
		          i += 1;
		        }
		        throw new Error();
		      }
		      var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
		      var effectElements = [];
		      var i;
		      var len = data.ef.length;
		      for (i = 0; i < len; i += 1) {
		        if (data.ef[i].ty === 5) {
		          effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
		        } else {
		          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
		        }
		      }
		      if (data.mn === 'ADBE Color Control') {
		        Object.defineProperty(groupInterface, 'color', {
		          get: function get() {
		            return effectElements[0]();
		          }
		        });
		      }
		      Object.defineProperties(groupInterface, {
		        numProperties: {
		          get: function get() {
		            return data.np;
		          }
		        },
		        _name: {
		          value: data.nm
		        },
		        propertyGroup: {
		          value: _propertyGroup
		        }
		      });
		      groupInterface.enabled = data.en !== 0;
		      groupInterface.active = groupInterface.enabled;
		      return groupInterface;
		    }
		    function createValueInterface(element, type, elem, propertyGroup) {
		      var expressionProperty = ExpressionPropertyInterface(element.p);
		      function interfaceFunction() {
		        if (type === 10) {
		          return elem.comp.compInterface(element.p.v);
		        }
		        return expressionProperty();
		      }
		      if (element.p.setGroupProperty) {
		        element.p.setGroupProperty(PropertyInterface('', propertyGroup));
		      }
		      return interfaceFunction;
		    }
		    return ob;
		  }();

		  var ShapePathInterface = function () {
		    return function pathInterfaceFactory(shape, view, propertyGroup) {
		      var prop = view.sh;
		      function interfaceFunction(val) {
		        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
		          return interfaceFunction.path;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        path: {
		          get: function get() {
		            if (prop.k) {
		              prop.getValue();
		            }
		            return prop;
		          }
		        },
		        shape: {
		          get: function get() {
		            if (prop.k) {
		              prop.getValue();
		            }
		            return prop;
		          }
		        },
		        _name: {
		          value: shape.nm
		        },
		        ix: {
		          value: shape.ix
		        },
		        propertyIndex: {
		          value: shape.ix
		        },
		        mn: {
		          value: shape.mn
		        },
		        propertyGroup: {
		          value: propertyGroup
		        }
		      });
		      return interfaceFunction;
		    };
		  }();

		  var ShapeExpressionInterface = function () {
		    function iterateElements(shapes, view, propertyGroup) {
		      var arr = [];
		      var i;
		      var len = shapes ? shapes.length : 0;
		      for (i = 0; i < len; i += 1) {
		        if (shapes[i].ty === 'gr') {
		          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'fl') {
		          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'st') {
		          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'tm') {
		          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'tr') ; else if (shapes[i].ty === 'el') {
		          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'sr') {
		          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'sh') {
		          arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'rc') {
		          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'rd') {
		          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'rp') {
		          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else if (shapes[i].ty === 'gf') {
		          arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
		        } else {
		          arr.push(defaultInterfaceFactory(shapes[i], view[i]));
		        }
		      }
		      return arr;
		    }
		    function contentsInterfaceFactory(shape, view, propertyGroup) {
		      var interfaces;
		      var interfaceFunction = function _interfaceFunction(value) {
		        var i = 0;
		        var len = interfaces.length;
		        while (i < len) {
		          if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
		            return interfaces[i];
		          }
		          i += 1;
		        }
		        if (typeof value === 'number') {
		          return interfaces[value - 1];
		        }
		        return null;
		      };
		      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
		      interfaceFunction.numProperties = interfaces.length;
		      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
		      interfaceFunction.transform = transformInterface;
		      interfaceFunction.propertyIndex = shape.cix;
		      interfaceFunction._name = shape.nm;
		      return interfaceFunction;
		    }
		    function groupInterfaceFactory(shape, view, propertyGroup) {
		      var interfaceFunction = function _interfaceFunction(value) {
		        switch (value) {
		          case 'ADBE Vectors Group':
		          case 'Contents':
		          case 2:
		            return interfaceFunction.content;
		          // Not necessary for now. Keeping them here in case a new case appears
		          // case 'ADBE Vector Transform Group':
		          // case 3:
		          default:
		            return interfaceFunction.transform;
		        }
		      };
		      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
		      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
		      interfaceFunction.content = content;
		      interfaceFunction.transform = transformInterface;
		      Object.defineProperty(interfaceFunction, '_name', {
		        get: function get() {
		          return shape.nm;
		        }
		      });
		      // interfaceFunction.content = interfaceFunction;
		      interfaceFunction.numProperties = shape.np;
		      interfaceFunction.propertyIndex = shape.ix;
		      interfaceFunction.nm = shape.nm;
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function fillInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(val) {
		        if (val === 'Color' || val === 'color') {
		          return interfaceFunction.color;
		        }
		        if (val === 'Opacity' || val === 'opacity') {
		          return interfaceFunction.opacity;
		        }
		        return null;
		      }
		      Object.defineProperties(interfaceFunction, {
		        color: {
		          get: ExpressionPropertyInterface(view.c)
		        },
		        opacity: {
		          get: ExpressionPropertyInterface(view.o)
		        },
		        _name: {
		          value: shape.nm
		        },
		        mn: {
		          value: shape.mn
		        }
		      });
		      view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
		      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
		      return interfaceFunction;
		    }
		    function gradientFillInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(val) {
		        if (val === 'Start Point' || val === 'start point') {
		          return interfaceFunction.startPoint;
		        }
		        if (val === 'End Point' || val === 'end point') {
		          return interfaceFunction.endPoint;
		        }
		        if (val === 'Opacity' || val === 'opacity') {
		          return interfaceFunction.opacity;
		        }
		        return null;
		      }
		      Object.defineProperties(interfaceFunction, {
		        startPoint: {
		          get: ExpressionPropertyInterface(view.s)
		        },
		        endPoint: {
		          get: ExpressionPropertyInterface(view.e)
		        },
		        opacity: {
		          get: ExpressionPropertyInterface(view.o)
		        },
		        type: {
		          get: function get() {
		            return 'a';
		          }
		        },
		        _name: {
		          value: shape.nm
		        },
		        mn: {
		          value: shape.mn
		        }
		      });
		      view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
		      view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
		      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
		      return interfaceFunction;
		    }
		    function defaultInterfaceFactory() {
		      function interfaceFunction() {
		        return null;
		      }
		      return interfaceFunction;
		    }
		    function strokeInterfaceFactory(shape, view, propertyGroup) {
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
		      function addPropertyToDashOb(i) {
		        Object.defineProperty(dashOb, shape.d[i].nm, {
		          get: ExpressionPropertyInterface(view.d.dataProps[i].p)
		        });
		      }
		      var i;
		      var len = shape.d ? shape.d.length : 0;
		      var dashOb = {};
		      for (i = 0; i < len; i += 1) {
		        addPropertyToDashOb(i);
		        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
		      }
		      function interfaceFunction(val) {
		        if (val === 'Color' || val === 'color') {
		          return interfaceFunction.color;
		        }
		        if (val === 'Opacity' || val === 'opacity') {
		          return interfaceFunction.opacity;
		        }
		        if (val === 'Stroke Width' || val === 'stroke width') {
		          return interfaceFunction.strokeWidth;
		        }
		        return null;
		      }
		      Object.defineProperties(interfaceFunction, {
		        color: {
		          get: ExpressionPropertyInterface(view.c)
		        },
		        opacity: {
		          get: ExpressionPropertyInterface(view.o)
		        },
		        strokeWidth: {
		          get: ExpressionPropertyInterface(view.w)
		        },
		        dash: {
		          get: function get() {
		            return dashOb;
		          }
		        },
		        _name: {
		          value: shape.nm
		        },
		        mn: {
		          value: shape.mn
		        }
		      });
		      view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
		      view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
		      view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
		      return interfaceFunction;
		    }
		    function trimInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(val) {
		        if (val === shape.e.ix || val === 'End' || val === 'end') {
		          return interfaceFunction.end;
		        }
		        if (val === shape.s.ix) {
		          return interfaceFunction.start;
		        }
		        if (val === shape.o.ix) {
		          return interfaceFunction.offset;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      interfaceFunction.propertyIndex = shape.ix;
		      view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
		      view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
		      view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
		      interfaceFunction.propertyIndex = shape.ix;
		      interfaceFunction.propertyGroup = propertyGroup;
		      Object.defineProperties(interfaceFunction, {
		        start: {
		          get: ExpressionPropertyInterface(view.s)
		        },
		        end: {
		          get: ExpressionPropertyInterface(view.e)
		        },
		        offset: {
		          get: ExpressionPropertyInterface(view.o)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function transformInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.a.ix === value || value === 'Anchor Point') {
		          return interfaceFunction.anchorPoint;
		        }
		        if (shape.o.ix === value || value === 'Opacity') {
		          return interfaceFunction.opacity;
		        }
		        if (shape.p.ix === value || value === 'Position') {
		          return interfaceFunction.position;
		        }
		        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
		          return interfaceFunction.rotation;
		        }
		        if (shape.s.ix === value || value === 'Scale') {
		          return interfaceFunction.scale;
		        }
		        if (shape.sk && shape.sk.ix === value || value === 'Skew') {
		          return interfaceFunction.skew;
		        }
		        if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
		          return interfaceFunction.skewAxis;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
		      view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
		      view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
		      view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
		      view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
		      if (view.transform.mProps.sk) {
		        view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
		        view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
		      }
		      view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        opacity: {
		          get: ExpressionPropertyInterface(view.transform.mProps.o)
		        },
		        position: {
		          get: ExpressionPropertyInterface(view.transform.mProps.p)
		        },
		        anchorPoint: {
		          get: ExpressionPropertyInterface(view.transform.mProps.a)
		        },
		        scale: {
		          get: ExpressionPropertyInterface(view.transform.mProps.s)
		        },
		        rotation: {
		          get: ExpressionPropertyInterface(view.transform.mProps.r)
		        },
		        skew: {
		          get: ExpressionPropertyInterface(view.transform.mProps.sk)
		        },
		        skewAxis: {
		          get: ExpressionPropertyInterface(view.transform.mProps.sa)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.ty = 'tr';
		      interfaceFunction.mn = shape.mn;
		      interfaceFunction.propertyGroup = propertyGroup;
		      return interfaceFunction;
		    }
		    function ellipseInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.p.ix === value) {
		          return interfaceFunction.position;
		        }
		        if (shape.s.ix === value) {
		          return interfaceFunction.size;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      interfaceFunction.propertyIndex = shape.ix;
		      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
		      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
		      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        size: {
		          get: ExpressionPropertyInterface(prop.s)
		        },
		        position: {
		          get: ExpressionPropertyInterface(prop.p)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function starInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.p.ix === value) {
		          return interfaceFunction.position;
		        }
		        if (shape.r.ix === value) {
		          return interfaceFunction.rotation;
		        }
		        if (shape.pt.ix === value) {
		          return interfaceFunction.points;
		        }
		        if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
		          return interfaceFunction.outerRadius;
		        }
		        if (shape.os.ix === value) {
		          return interfaceFunction.outerRoundness;
		        }
		        if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
		          return interfaceFunction.innerRadius;
		        }
		        if (shape.is && shape.is.ix === value) {
		          return interfaceFunction.innerRoundness;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
		      interfaceFunction.propertyIndex = shape.ix;
		      prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
		      prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
		      prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
		      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
		      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
		      if (shape.ir) {
		        prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
		        prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
		      }
		      Object.defineProperties(interfaceFunction, {
		        position: {
		          get: ExpressionPropertyInterface(prop.p)
		        },
		        rotation: {
		          get: ExpressionPropertyInterface(prop.r)
		        },
		        points: {
		          get: ExpressionPropertyInterface(prop.pt)
		        },
		        outerRadius: {
		          get: ExpressionPropertyInterface(prop.or)
		        },
		        outerRoundness: {
		          get: ExpressionPropertyInterface(prop.os)
		        },
		        innerRadius: {
		          get: ExpressionPropertyInterface(prop.ir)
		        },
		        innerRoundness: {
		          get: ExpressionPropertyInterface(prop.is)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function rectInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.p.ix === value) {
		          return interfaceFunction.position;
		        }
		        if (shape.r.ix === value) {
		          return interfaceFunction.roundness;
		        }
		        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
		          return interfaceFunction.size;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
		      interfaceFunction.propertyIndex = shape.ix;
		      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
		      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
		      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        position: {
		          get: ExpressionPropertyInterface(prop.p)
		        },
		        roundness: {
		          get: ExpressionPropertyInterface(prop.r)
		        },
		        size: {
		          get: ExpressionPropertyInterface(prop.s)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function roundedInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.r.ix === value || value === 'Round Corners 1') {
		          return interfaceFunction.radius;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var prop = view;
		      interfaceFunction.propertyIndex = shape.ix;
		      prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        radius: {
		          get: ExpressionPropertyInterface(prop.rd)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    function repeaterInterfaceFactory(shape, view, propertyGroup) {
		      function interfaceFunction(value) {
		        if (shape.c.ix === value || value === 'Copies') {
		          return interfaceFunction.copies;
		        }
		        if (shape.o.ix === value || value === 'Offset') {
		          return interfaceFunction.offset;
		        }
		        return null;
		      }
		      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
		      var prop = view;
		      interfaceFunction.propertyIndex = shape.ix;
		      prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
		      prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
		      Object.defineProperties(interfaceFunction, {
		        copies: {
		          get: ExpressionPropertyInterface(prop.c)
		        },
		        offset: {
		          get: ExpressionPropertyInterface(prop.o)
		        },
		        _name: {
		          value: shape.nm
		        }
		      });
		      interfaceFunction.mn = shape.mn;
		      return interfaceFunction;
		    }
		    return function (shapes, view, propertyGroup) {
		      var interfaces;
		      function _interfaceFunction(value) {
		        if (typeof value === 'number') {
		          value = value === undefined ? 1 : value;
		          if (value === 0) {
		            return propertyGroup;
		          }
		          return interfaces[value - 1];
		        }
		        var i = 0;
		        var len = interfaces.length;
		        while (i < len) {
		          if (interfaces[i]._name === value) {
		            return interfaces[i];
		          }
		          i += 1;
		        }
		        return null;
		      }
		      function parentGroupWrapper() {
		        return propertyGroup;
		      }
		      _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
		      interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
		      _interfaceFunction.numProperties = interfaces.length;
		      _interfaceFunction._name = 'Contents';
		      return _interfaceFunction;
		    };
		  }();

		  var TextExpressionInterface = function () {
		    return function (elem) {
		      var _sourceText;
		      function _thisLayerFunction(name) {
		        switch (name) {
		          case 'ADBE Text Document':
		            return _thisLayerFunction.sourceText;
		          default:
		            return null;
		        }
		      }
		      Object.defineProperty(_thisLayerFunction, 'sourceText', {
		        get: function get() {
		          elem.textProperty.getValue();
		          var stringValue = elem.textProperty.currentData.t;
		          if (!_sourceText || stringValue !== _sourceText.value) {
		            _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
		            // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
		            _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
		            Object.defineProperty(_sourceText, 'style', {
		              get: function get() {
		                return {
		                  fillColor: elem.textProperty.currentData.fc
		                };
		              }
		            });
		          }
		          return _sourceText;
		        }
		      });
		      return _thisLayerFunction;
		    };
		  }();

		  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		  var FootageInterface = function () {
		    var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
		      var currentPropertyName = '';
		      var currentProperty = elem.getFootageData();
		      function init() {
		        currentPropertyName = '';
		        currentProperty = elem.getFootageData();
		        return searchProperty;
		      }
		      function searchProperty(value) {
		        if (currentProperty[value]) {
		          currentPropertyName = value;
		          currentProperty = currentProperty[value];
		          if (_typeof(currentProperty) === 'object') {
		            return searchProperty;
		          }
		          return currentProperty;
		        }
		        var propertyNameIndex = value.indexOf(currentPropertyName);
		        if (propertyNameIndex !== -1) {
		          var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
		          currentProperty = currentProperty[index];
		          if (_typeof(currentProperty) === 'object') {
		            return searchProperty;
		          }
		          return currentProperty;
		        }
		        return '';
		      }
		      return init;
		    };
		    var dataInterfaceFactory = function dataInterfaceFactory(elem) {
		      function interfaceFunction(value) {
		        if (value === 'Outline') {
		          return interfaceFunction.outlineInterface();
		        }
		        return null;
		      }
		      interfaceFunction._name = 'Outline';
		      interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
		      return interfaceFunction;
		    };
		    return function (elem) {
		      function _interfaceFunction(value) {
		        if (value === 'Data') {
		          return _interfaceFunction.dataInterface;
		        }
		        return null;
		      }
		      _interfaceFunction._name = 'Data';
		      _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
		      return _interfaceFunction;
		    };
		  }();

		  var interfaces = {
		    layer: LayerExpressionInterface,
		    effects: EffectsExpressionInterface,
		    comp: CompExpressionInterface,
		    shape: ShapeExpressionInterface,
		    text: TextExpressionInterface,
		    footage: FootageInterface
		  };
		  function getInterface(type) {
		    return interfaces[type] || null;
		  }

		  var expressionHelpers = function () {
		    function searchExpressions(elem, data, prop) {
		      if (data.x) {
		        prop.k = true;
		        prop.x = true;
		        prop.initiateExpression = ExpressionManager.initiateExpression;
		        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
		      }
		    }
		    function getValueAtTime(frameNum) {
		      frameNum *= this.elem.globalData.frameRate;
		      frameNum -= this.offsetTime;
		      if (frameNum !== this._cachingAtTime.lastFrame) {
		        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
		        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
		        this._cachingAtTime.lastFrame = frameNum;
		      }
		      return this._cachingAtTime.value;
		    }
		    function getSpeedAtTime(frameNum) {
		      var delta = -0.01;
		      var v1 = this.getValueAtTime(frameNum);
		      var v2 = this.getValueAtTime(frameNum + delta);
		      var speed = 0;
		      if (v1.length) {
		        var i;
		        for (i = 0; i < v1.length; i += 1) {
		          speed += Math.pow(v2[i] - v1[i], 2);
		        }
		        speed = Math.sqrt(speed) * 100;
		      } else {
		        speed = 0;
		      }
		      return speed;
		    }
		    function getVelocityAtTime(frameNum) {
		      if (this.vel !== undefined) {
		        return this.vel;
		      }
		      var delta = -0.001;
		      // frameNum += this.elem.data.st;
		      var v1 = this.getValueAtTime(frameNum);
		      var v2 = this.getValueAtTime(frameNum + delta);
		      var velocity;
		      if (v1.length) {
		        velocity = createTypedArray('float32', v1.length);
		        var i;
		        for (i = 0; i < v1.length; i += 1) {
		          // removing frameRate
		          // if needed, don't add it here
		          // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
		          velocity[i] = (v2[i] - v1[i]) / delta;
		        }
		      } else {
		        velocity = (v2 - v1) / delta;
		      }
		      return velocity;
		    }
		    function getStaticValueAtTime() {
		      return this.pv;
		    }
		    function setGroupProperty(propertyGroup) {
		      this.propertyGroup = propertyGroup;
		    }
		    return {
		      searchExpressions: searchExpressions,
		      getSpeedAtTime: getSpeedAtTime,
		      getVelocityAtTime: getVelocityAtTime,
		      getValueAtTime: getValueAtTime,
		      getStaticValueAtTime: getStaticValueAtTime,
		      setGroupProperty: setGroupProperty
		    };
		  }();

		  function addPropertyDecorator() {
		    function loopOut(type, duration, durationFlag) {
		      if (!this.k || !this.keyframes) {
		        return this.pv;
		      }
		      type = type ? type.toLowerCase() : '';
		      var currentFrame = this.comp.renderedFrame;
		      var keyframes = this.keyframes;
		      var lastKeyFrame = keyframes[keyframes.length - 1].t;
		      if (currentFrame <= lastKeyFrame) {
		        return this.pv;
		      }
		      var cycleDuration;
		      var firstKeyFrame;
		      if (!durationFlag) {
		        if (!duration || duration > keyframes.length - 1) {
		          duration = keyframes.length - 1;
		        }
		        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
		        cycleDuration = lastKeyFrame - firstKeyFrame;
		      } else {
		        if (!duration) {
		          cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
		        } else {
		          cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
		        }
		        firstKeyFrame = lastKeyFrame - cycleDuration;
		      }
		      var i;
		      var len;
		      var ret;
		      if (type === 'pingpong') {
		        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
		        if (iterations % 2 !== 0) {
		          return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
		        }
		      } else if (type === 'offset') {
		        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
		        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
		        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
		        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
		        if (this.pv.length) {
		          ret = new Array(initV.length);
		          len = ret.length;
		          for (i = 0; i < len; i += 1) {
		            ret[i] = (endV[i] - initV[i]) * repeats + current[i];
		          }
		          return ret;
		        }
		        return (endV - initV) * repeats + current;
		      } else if (type === 'continue') {
		        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
		        var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
		        if (this.pv.length) {
		          ret = new Array(lastValue.length);
		          len = ret.length;
		          for (i = 0; i < len; i += 1) {
		            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
		          }
		          return ret;
		        }
		        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
		      }
		      return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
		    }
		    function loopIn(type, duration, durationFlag) {
		      if (!this.k) {
		        return this.pv;
		      }
		      type = type ? type.toLowerCase() : '';
		      var currentFrame = this.comp.renderedFrame;
		      var keyframes = this.keyframes;
		      var firstKeyFrame = keyframes[0].t;
		      if (currentFrame >= firstKeyFrame) {
		        return this.pv;
		      }
		      var cycleDuration;
		      var lastKeyFrame;
		      if (!durationFlag) {
		        if (!duration || duration > keyframes.length - 1) {
		          duration = keyframes.length - 1;
		        }
		        lastKeyFrame = keyframes[duration].t;
		        cycleDuration = lastKeyFrame - firstKeyFrame;
		      } else {
		        if (!duration) {
		          cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
		        } else {
		          cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
		        }
		        lastKeyFrame = firstKeyFrame + cycleDuration;
		      }
		      var i;
		      var len;
		      var ret;
		      if (type === 'pingpong') {
		        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
		        if (iterations % 2 === 0) {
		          return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
		        }
		      } else if (type === 'offset') {
		        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
		        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
		        var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
		        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
		        if (this.pv.length) {
		          ret = new Array(initV.length);
		          len = ret.length;
		          for (i = 0; i < len; i += 1) {
		            ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
		          }
		          return ret;
		        }
		        return current - (endV - initV) * repeats;
		      } else if (type === 'continue') {
		        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
		        var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
		        if (this.pv.length) {
		          ret = new Array(firstValue.length);
		          len = ret.length;
		          for (i = 0; i < len; i += 1) {
		            ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
		          }
		          return ret;
		        }
		        return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
		      }
		      return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
		    }
		    function smooth(width, samples) {
		      if (!this.k) {
		        return this.pv;
		      }
		      width = (width || 0.4) * 0.5;
		      samples = Math.floor(samples || 5);
		      if (samples <= 1) {
		        return this.pv;
		      }
		      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
		      var initFrame = currentTime - width;
		      var endFrame = currentTime + width;
		      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
		      var i = 0;
		      var j = 0;
		      var value;
		      if (this.pv.length) {
		        value = createTypedArray('float32', this.pv.length);
		      } else {
		        value = 0;
		      }
		      var sampleValue;
		      while (i < samples) {
		        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
		        if (this.pv.length) {
		          for (j = 0; j < this.pv.length; j += 1) {
		            value[j] += sampleValue[j];
		          }
		        } else {
		          value += sampleValue;
		        }
		        i += 1;
		      }
		      if (this.pv.length) {
		        for (j = 0; j < this.pv.length; j += 1) {
		          value[j] /= samples;
		        }
		      } else {
		        value /= samples;
		      }
		      return value;
		    }
		    function getTransformValueAtTime(time) {
		      if (!this._transformCachingAtTime) {
		        this._transformCachingAtTime = {
		          v: new Matrix()
		        };
		      }
		      /// /
		      var matrix = this._transformCachingAtTime.v;
		      matrix.cloneFromProps(this.pre.props);
		      if (this.appliedTransformations < 1) {
		        var anchor = this.a.getValueAtTime(time);
		        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
		      }
		      if (this.appliedTransformations < 2) {
		        var scale = this.s.getValueAtTime(time);
		        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
		      }
		      if (this.sk && this.appliedTransformations < 3) {
		        var skew = this.sk.getValueAtTime(time);
		        var skewAxis = this.sa.getValueAtTime(time);
		        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
		      }
		      if (this.r && this.appliedTransformations < 4) {
		        var rotation = this.r.getValueAtTime(time);
		        matrix.rotate(-rotation * this.r.mult);
		      } else if (!this.r && this.appliedTransformations < 4) {
		        var rotationZ = this.rz.getValueAtTime(time);
		        var rotationY = this.ry.getValueAtTime(time);
		        var rotationX = this.rx.getValueAtTime(time);
		        var orientation = this.or.getValueAtTime(time);
		        matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
		      }
		      if (this.data.p && this.data.p.s) {
		        var positionX = this.px.getValueAtTime(time);
		        var positionY = this.py.getValueAtTime(time);
		        if (this.data.p.z) {
		          var positionZ = this.pz.getValueAtTime(time);
		          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
		        } else {
		          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
		        }
		      } else {
		        var position = this.p.getValueAtTime(time);
		        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
		      }
		      return matrix;
		      /// /
		    }
		    function getTransformStaticValueAtTime() {
		      return this.v.clone(new Matrix());
		    }
		    var getTransformProperty = TransformPropertyFactory.getTransformProperty;
		    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
		      var prop = getTransformProperty(elem, data, container);
		      if (prop.dynamicProperties.length) {
		        prop.getValueAtTime = getTransformValueAtTime.bind(prop);
		      } else {
		        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
		      }
		      prop.setGroupProperty = expressionHelpers.setGroupProperty;
		      return prop;
		    };
		    var propertyGetProp = PropertyFactory.getProp;
		    PropertyFactory.getProp = function (elem, data, type, mult, container) {
		      var prop = propertyGetProp(elem, data, type, mult, container);
		      // prop.getVelocityAtTime = getVelocityAtTime;
		      // prop.loopOut = loopOut;
		      // prop.loopIn = loopIn;
		      if (prop.kf) {
		        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
		      } else {
		        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
		      }
		      prop.setGroupProperty = expressionHelpers.setGroupProperty;
		      prop.loopOut = loopOut;
		      prop.loopIn = loopIn;
		      prop.smooth = smooth;
		      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
		      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
		      prop.numKeys = data.a === 1 ? data.k.length : 0;
		      prop.propertyIndex = data.ix;
		      var value = 0;
		      if (type !== 0) {
		        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
		      }
		      prop._cachingAtTime = {
		        lastFrame: initialDefaultFrame,
		        lastIndex: 0,
		        value: value
		      };
		      expressionHelpers.searchExpressions(elem, data, prop);
		      if (prop.k) {
		        container.addDynamicProperty(prop);
		      }
		      return prop;
		    };
		    function getShapeValueAtTime(frameNum) {
		      // For now this caching object is created only when needed instead of creating it when the shape is initialized.
		      if (!this._cachingAtTime) {
		        this._cachingAtTime = {
		          shapeValue: shapePool.clone(this.pv),
		          lastIndex: 0,
		          lastTime: initialDefaultFrame
		        };
		      }
		      frameNum *= this.elem.globalData.frameRate;
		      frameNum -= this.offsetTime;
		      if (frameNum !== this._cachingAtTime.lastTime) {
		        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
		        this._cachingAtTime.lastTime = frameNum;
		        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
		      }
		      return this._cachingAtTime.shapeValue;
		    }
		    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
		    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
		    function ShapeExpressions() {}
		    ShapeExpressions.prototype = {
		      vertices: function vertices(prop, time) {
		        if (this.k) {
		          this.getValue();
		        }
		        var shapePath = this.v;
		        if (time !== undefined) {
		          shapePath = this.getValueAtTime(time, 0);
		        }
		        var i;
		        var len = shapePath._length;
		        var vertices = shapePath[prop];
		        var points = shapePath.v;
		        var arr = createSizedArray(len);
		        for (i = 0; i < len; i += 1) {
		          if (prop === 'i' || prop === 'o') {
		            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
		          } else {
		            arr[i] = [vertices[i][0], vertices[i][1]];
		          }
		        }
		        return arr;
		      },
		      points: function points(time) {
		        return this.vertices('v', time);
		      },
		      inTangents: function inTangents(time) {
		        return this.vertices('i', time);
		      },
		      outTangents: function outTangents(time) {
		        return this.vertices('o', time);
		      },
		      isClosed: function isClosed() {
		        return this.v.c;
		      },
		      pointOnPath: function pointOnPath(perc, time) {
		        var shapePath = this.v;
		        if (time !== undefined) {
		          shapePath = this.getValueAtTime(time, 0);
		        }
		        if (!this._segmentsLength) {
		          this._segmentsLength = bez.getSegmentsLength(shapePath);
		        }
		        var segmentsLength = this._segmentsLength;
		        var lengths = segmentsLength.lengths;
		        var lengthPos = segmentsLength.totalLength * perc;
		        var i = 0;
		        var len = lengths.length;
		        var accumulatedLength = 0;
		        var pt;
		        while (i < len) {
		          if (accumulatedLength + lengths[i].addedLength > lengthPos) {
		            var initIndex = i;
		            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
		            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
		            pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
		            break;
		          } else {
		            accumulatedLength += lengths[i].addedLength;
		          }
		          i += 1;
		        }
		        if (!pt) {
		          pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
		        }
		        return pt;
		      },
		      vectorOnPath: function vectorOnPath(perc, time, vectorType) {
		        // perc doesn't use triple equality because it can be a Number object as well as a primitive.
		        if (perc == 1) {
		          // eslint-disable-line eqeqeq
		          perc = this.v.c;
		        } else if (perc == 0) {
		          // eslint-disable-line eqeqeq
		          perc = 0.999;
		        }
		        var pt1 = this.pointOnPath(perc, time);
		        var pt2 = this.pointOnPath(perc + 0.001, time);
		        var xLength = pt2[0] - pt1[0];
		        var yLength = pt2[1] - pt1[1];
		        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
		        if (magnitude === 0) {
		          return [0, 0];
		        }
		        var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
		        return unitVector;
		      },
		      tangentOnPath: function tangentOnPath(perc, time) {
		        return this.vectorOnPath(perc, time, 'tangent');
		      },
		      normalOnPath: function normalOnPath(perc, time) {
		        return this.vectorOnPath(perc, time, 'normal');
		      },
		      setGroupProperty: expressionHelpers.setGroupProperty,
		      getValueAtTime: expressionHelpers.getStaticValueAtTime
		    };
		    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
		    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
		    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
		    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
		    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
		    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
		      var prop = propertyGetShapeProp(elem, data, type, arr, trims);
		      prop.propertyIndex = data.ix;
		      prop.lock = false;
		      if (type === 3) {
		        expressionHelpers.searchExpressions(elem, data.pt, prop);
		      } else if (type === 4) {
		        expressionHelpers.searchExpressions(elem, data.ks, prop);
		      }
		      if (prop.k) {
		        elem.addDynamicProperty(prop);
		      }
		      return prop;
		    };
		  }
		  function initialize$1() {
		    addPropertyDecorator();
		  }

		  function addDecorator() {
		    function searchExpressions() {
		      if (this.data.d.x) {
		        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
		        this.addEffect(this.getExpressionValue.bind(this));
		        return true;
		      }
		      return null;
		    }
		    TextProperty.prototype.getExpressionValue = function (currentValue, text) {
		      var newValue = this.calculateExpression(text);
		      if (currentValue.t !== newValue) {
		        var newData = {};
		        this.copyData(newData, currentValue);
		        newData.t = newValue.toString();
		        newData.__complete = false;
		        return newData;
		      }
		      return currentValue;
		    };
		    TextProperty.prototype.searchProperty = function () {
		      var isKeyframed = this.searchKeyframes();
		      var hasExpressions = this.searchExpressions();
		      this.kf = isKeyframed || hasExpressions;
		      return this.kf;
		    };
		    TextProperty.prototype.searchExpressions = searchExpressions;
		  }
		  function initialize() {
		    addDecorator();
		  }

		  function SVGComposableEffect() {}
		  SVGComposableEffect.prototype = {
		    createMergeNode: function createMergeNode(resultId, ins) {
		      var feMerge = createNS('feMerge');
		      feMerge.setAttribute('result', resultId);
		      var feMergeNode;
		      var i;
		      for (i = 0; i < ins.length; i += 1) {
		        feMergeNode = createNS('feMergeNode');
		        feMergeNode.setAttribute('in', ins[i]);
		        feMerge.appendChild(feMergeNode);
		        feMerge.appendChild(feMergeNode);
		      }
		      return feMerge;
		    }
		  };

		  var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';
		  function SVGTintFilter(filter, filterManager, elem, id, source) {
		    this.filterManager = filterManager;
		    var feColorMatrix = createNS('feColorMatrix');
		    feColorMatrix.setAttribute('type', 'matrix');
		    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
		    feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');
		    this.linearFilter = feColorMatrix;
		    feColorMatrix.setAttribute('result', id + '_tint_1');
		    filter.appendChild(feColorMatrix);
		    feColorMatrix = createNS('feColorMatrix');
		    feColorMatrix.setAttribute('type', 'matrix');
		    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
		    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
		    feColorMatrix.setAttribute('result', id + '_tint_2');
		    filter.appendChild(feColorMatrix);
		    this.matrixFilter = feColorMatrix;
		    var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);
		    filter.appendChild(feMerge);
		  }
		  extendPrototype([SVGComposableEffect], SVGTintFilter);
		  SVGTintFilter.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      var colorBlack = this.filterManager.effectElements[0].p.v;
		      var colorWhite = this.filterManager.effectElements[1].p.v;
		      var opacity = this.filterManager.effectElements[2].p.v / 100;
		      this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');
		      this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');
		    }
		  };

		  function SVGFillFilter(filter, filterManager, elem, id) {
		    this.filterManager = filterManager;
		    var feColorMatrix = createNS('feColorMatrix');
		    feColorMatrix.setAttribute('type', 'matrix');
		    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
		    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
		    feColorMatrix.setAttribute('result', id);
		    filter.appendChild(feColorMatrix);
		    this.matrixFilter = feColorMatrix;
		  }
		  SVGFillFilter.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      var color = this.filterManager.effectElements[2].p.v;
		      var opacity = this.filterManager.effectElements[6].p.v;
		      this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
		    }
		  };

		  function SVGStrokeEffect(fil, filterManager, elem) {
		    this.initialized = false;
		    this.filterManager = filterManager;
		    this.elem = elem;
		    this.paths = [];
		  }
		  SVGStrokeEffect.prototype.initialize = function () {
		    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
		    var path;
		    var groupPath;
		    var i;
		    var len;
		    if (this.filterManager.effectElements[1].p.v === 1) {
		      len = this.elem.maskManager.masksProperties.length;
		      i = 0;
		    } else {
		      i = this.filterManager.effectElements[0].p.v - 1;
		      len = i + 1;
		    }
		    groupPath = createNS('g');
		    groupPath.setAttribute('fill', 'none');
		    groupPath.setAttribute('stroke-linecap', 'round');
		    groupPath.setAttribute('stroke-dashoffset', 1);
		    for (i; i < len; i += 1) {
		      path = createNS('path');
		      groupPath.appendChild(path);
		      this.paths.push({
		        p: path,
		        m: i
		      });
		    }
		    if (this.filterManager.effectElements[10].p.v === 3) {
		      var mask = createNS('mask');
		      var id = createElementID();
		      mask.setAttribute('id', id);
		      mask.setAttribute('mask-type', 'alpha');
		      mask.appendChild(groupPath);
		      this.elem.globalData.defs.appendChild(mask);
		      var g = createNS('g');
		      g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
		      while (elemChildren[0]) {
		        g.appendChild(elemChildren[0]);
		      }
		      this.elem.layerElement.appendChild(g);
		      this.masker = mask;
		      groupPath.setAttribute('stroke', '#fff');
		    } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
		      if (this.filterManager.effectElements[10].p.v === 2) {
		        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
		        while (elemChildren.length) {
		          this.elem.layerElement.removeChild(elemChildren[0]);
		        }
		      }
		      this.elem.layerElement.appendChild(groupPath);
		      this.elem.layerElement.removeAttribute('mask');
		      groupPath.setAttribute('stroke', '#fff');
		    }
		    this.initialized = true;
		    this.pathMasker = groupPath;
		  };
		  SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
		    if (!this.initialized) {
		      this.initialize();
		    }
		    var i;
		    var len = this.paths.length;
		    var mask;
		    var path;
		    for (i = 0; i < len; i += 1) {
		      if (this.paths[i].m !== -1) {
		        mask = this.elem.maskManager.viewData[this.paths[i].m];
		        path = this.paths[i].p;
		        if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
		          path.setAttribute('d', mask.lastPath);
		        }
		        if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
		          var dasharrayValue;
		          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
		            var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
		            var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
		            var l = path.getTotalLength();
		            dasharrayValue = '0 0 0 ' + l * s + ' ';
		            var lineLength = l * (e - s);
		            var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
		            var units = Math.floor(lineLength / segment);
		            var j;
		            for (j = 0; j < units; j += 1) {
		              dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
		            }
		            dasharrayValue += '0 ' + l * 10 + ' 0 0';
		          } else {
		            dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
		          }
		          path.setAttribute('stroke-dasharray', dasharrayValue);
		        }
		      }
		    }
		    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
		      this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
		    }
		    if (forceRender || this.filterManager.effectElements[6].p._mdf) {
		      this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
		    }
		    if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
		      if (forceRender || this.filterManager.effectElements[3].p._mdf) {
		        var color = this.filterManager.effectElements[3].p.v;
		        this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
		      }
		    }
		  };

		  function SVGTritoneFilter(filter, filterManager, elem, id) {
		    this.filterManager = filterManager;
		    var feColorMatrix = createNS('feColorMatrix');
		    feColorMatrix.setAttribute('type', 'matrix');
		    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
		    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
		    filter.appendChild(feColorMatrix);
		    var feComponentTransfer = createNS('feComponentTransfer');
		    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
		    feComponentTransfer.setAttribute('result', id);
		    this.matrixFilter = feComponentTransfer;
		    var feFuncR = createNS('feFuncR');
		    feFuncR.setAttribute('type', 'table');
		    feComponentTransfer.appendChild(feFuncR);
		    this.feFuncR = feFuncR;
		    var feFuncG = createNS('feFuncG');
		    feFuncG.setAttribute('type', 'table');
		    feComponentTransfer.appendChild(feFuncG);
		    this.feFuncG = feFuncG;
		    var feFuncB = createNS('feFuncB');
		    feFuncB.setAttribute('type', 'table');
		    feComponentTransfer.appendChild(feFuncB);
		    this.feFuncB = feFuncB;
		    filter.appendChild(feComponentTransfer);
		  }
		  SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      var color1 = this.filterManager.effectElements[0].p.v;
		      var color2 = this.filterManager.effectElements[1].p.v;
		      var color3 = this.filterManager.effectElements[2].p.v;
		      var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
		      var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
		      var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
		      this.feFuncR.setAttribute('tableValues', tableR);
		      this.feFuncG.setAttribute('tableValues', tableG);
		      this.feFuncB.setAttribute('tableValues', tableB);
		    }
		  };

		  function SVGProLevelsFilter(filter, filterManager, elem, id) {
		    this.filterManager = filterManager;
		    var effectElements = this.filterManager.effectElements;
		    var feComponentTransfer = createNS('feComponentTransfer');

		    // Red
		    if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
		      this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
		    }
		    // Green
		    if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
		      this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
		    }
		    // Blue
		    if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
		      this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
		    }
		    // Alpha
		    if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
		      this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
		    }
		    // RGB
		    if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
		      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
		      filter.appendChild(feComponentTransfer);
		    }
		    if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
		      feComponentTransfer = createNS('feComponentTransfer');
		      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
		      feComponentTransfer.setAttribute('result', id);
		      filter.appendChild(feComponentTransfer);
		      this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
		      this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
		      this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
		    }
		  }
		  SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
		    var feFunc = createNS(type);
		    feFunc.setAttribute('type', 'table');
		    feComponentTransfer.appendChild(feFunc);
		    return feFunc;
		  };
		  SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
		    var cnt = 0;
		    var segments = 256;
		    var perc;
		    var min = Math.min(inputBlack, inputWhite);
		    var max = Math.max(inputBlack, inputWhite);
		    var table = Array.call(null, {
		      length: segments
		    });
		    var colorValue;
		    var pos = 0;
		    var outputDelta = outputWhite - outputBlack;
		    var inputDelta = inputWhite - inputBlack;
		    while (cnt <= 256) {
		      perc = cnt / 256;
		      if (perc <= min) {
		        colorValue = inputDelta < 0 ? outputWhite : outputBlack;
		      } else if (perc >= max) {
		        colorValue = inputDelta < 0 ? outputBlack : outputWhite;
		      } else {
		        colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
		      }
		      table[pos] = colorValue;
		      pos += 1;
		      cnt += 256 / (segments - 1);
		    }
		    return table.join(' ');
		  };
		  SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      var val;
		      var effectElements = this.filterManager.effectElements;
		      if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
		        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
		        this.feFuncRComposed.setAttribute('tableValues', val);
		        this.feFuncGComposed.setAttribute('tableValues', val);
		        this.feFuncBComposed.setAttribute('tableValues', val);
		      }
		      if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
		        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
		        this.feFuncR.setAttribute('tableValues', val);
		      }
		      if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
		        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
		        this.feFuncG.setAttribute('tableValues', val);
		      }
		      if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
		        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
		        this.feFuncB.setAttribute('tableValues', val);
		      }
		      if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
		        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
		        this.feFuncA.setAttribute('tableValues', val);
		      }
		    }
		  };

		  function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
		    var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
		    var filterSize = filterManager.data.fs || globalFilterSize;
		    filter.setAttribute('x', filterSize.x || globalFilterSize.x);
		    filter.setAttribute('y', filterSize.y || globalFilterSize.y);
		    filter.setAttribute('width', filterSize.width || globalFilterSize.width);
		    filter.setAttribute('height', filterSize.height || globalFilterSize.height);
		    this.filterManager = filterManager;
		    var feGaussianBlur = createNS('feGaussianBlur');
		    feGaussianBlur.setAttribute('in', 'SourceAlpha');
		    feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
		    feGaussianBlur.setAttribute('stdDeviation', '0');
		    this.feGaussianBlur = feGaussianBlur;
		    filter.appendChild(feGaussianBlur);
		    var feOffset = createNS('feOffset');
		    feOffset.setAttribute('dx', '25');
		    feOffset.setAttribute('dy', '0');
		    feOffset.setAttribute('in', id + '_drop_shadow_1');
		    feOffset.setAttribute('result', id + '_drop_shadow_2');
		    this.feOffset = feOffset;
		    filter.appendChild(feOffset);
		    var feFlood = createNS('feFlood');
		    feFlood.setAttribute('flood-color', '#00ff00');
		    feFlood.setAttribute('flood-opacity', '1');
		    feFlood.setAttribute('result', id + '_drop_shadow_3');
		    this.feFlood = feFlood;
		    filter.appendChild(feFlood);
		    var feComposite = createNS('feComposite');
		    feComposite.setAttribute('in', id + '_drop_shadow_3');
		    feComposite.setAttribute('in2', id + '_drop_shadow_2');
		    feComposite.setAttribute('operator', 'in');
		    feComposite.setAttribute('result', id + '_drop_shadow_4');
		    filter.appendChild(feComposite);
		    var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);
		    filter.appendChild(feMerge);
		    //
		  }
		  extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
		  SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
		        this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
		      }
		      if (forceRender || this.filterManager.effectElements[0].p._mdf) {
		        var col = this.filterManager.effectElements[0].p.v;
		        this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
		      }
		      if (forceRender || this.filterManager.effectElements[1].p._mdf) {
		        this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
		      }
		      if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
		        var distance = this.filterManager.effectElements[3].p.v;
		        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
		        var x = distance * Math.cos(angle);
		        var y = distance * Math.sin(angle);
		        this.feOffset.setAttribute('dx', x);
		        this.feOffset.setAttribute('dy', y);
		      }
		    }
		  };

		  var _svgMatteSymbols = [];
		  function SVGMatte3Effect(filterElem, filterManager, elem) {
		    this.initialized = false;
		    this.filterManager = filterManager;
		    this.filterElem = filterElem;
		    this.elem = elem;
		    elem.matteElement = createNS('g');
		    elem.matteElement.appendChild(elem.layerElement);
		    elem.matteElement.appendChild(elem.transformedElement);
		    elem.baseElement = elem.matteElement;
		  }
		  SVGMatte3Effect.prototype.findSymbol = function (mask) {
		    var i = 0;
		    var len = _svgMatteSymbols.length;
		    while (i < len) {
		      if (_svgMatteSymbols[i] === mask) {
		        return _svgMatteSymbols[i];
		      }
		      i += 1;
		    }
		    return null;
		  };
		  SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
		    var parentNode = mask.layerElement.parentNode;
		    if (!parentNode) {
		      return;
		    }
		    var children = parentNode.children;
		    var i = 0;
		    var len = children.length;
		    while (i < len) {
		      if (children[i] === mask.layerElement) {
		        break;
		      }
		      i += 1;
		    }
		    var nextChild;
		    if (i <= len - 2) {
		      nextChild = children[i + 1];
		    }
		    var useElem = createNS('use');
		    useElem.setAttribute('href', '#' + symbolId);
		    if (nextChild) {
		      parentNode.insertBefore(useElem, nextChild);
		    } else {
		      parentNode.appendChild(useElem);
		    }
		  };
		  SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
		    if (!this.findSymbol(mask)) {
		      var symbolId = createElementID();
		      var masker = createNS('mask');
		      masker.setAttribute('id', mask.layerId);
		      masker.setAttribute('mask-type', 'alpha');
		      _svgMatteSymbols.push(mask);
		      var defs = elem.globalData.defs;
		      defs.appendChild(masker);
		      var symbol = createNS('symbol');
		      symbol.setAttribute('id', symbolId);
		      this.replaceInParent(mask, symbolId);
		      symbol.appendChild(mask.layerElement);
		      defs.appendChild(symbol);
		      var useElem = createNS('use');
		      useElem.setAttribute('href', '#' + symbolId);
		      masker.appendChild(useElem);
		      mask.data.hd = false;
		      mask.show();
		    }
		    elem.setMatte(mask.layerId);
		  };
		  SVGMatte3Effect.prototype.initialize = function () {
		    var ind = this.filterManager.effectElements[0].p.v;
		    var elements = this.elem.comp.elements;
		    var i = 0;
		    var len = elements.length;
		    while (i < len) {
		      if (elements[i] && elements[i].data.ind === ind) {
		        this.setElementAsMask(this.elem, elements[i]);
		      }
		      i += 1;
		    }
		    this.initialized = true;
		  };
		  SVGMatte3Effect.prototype.renderFrame = function () {
		    if (!this.initialized) {
		      this.initialize();
		    }
		  };

		  function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
		    // Outset the filter region by 100% on all sides to accommodate blur expansion.
		    filter.setAttribute('x', '-100%');
		    filter.setAttribute('y', '-100%');
		    filter.setAttribute('width', '300%');
		    filter.setAttribute('height', '300%');
		    this.filterManager = filterManager;
		    var feGaussianBlur = createNS('feGaussianBlur');
		    feGaussianBlur.setAttribute('result', id);
		    filter.appendChild(feGaussianBlur);
		    this.feGaussianBlur = feGaussianBlur;
		  }
		  SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
		    if (forceRender || this.filterManager._mdf) {
		      // Empirical value, matching AE's blur appearance.
		      var kBlurrinessToSigma = 0.3;
		      var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

		      // Dimensions mapping:
		      //
		      //   1 -> horizontal & vertical
		      //   2 -> horizontal only
		      //   3 -> vertical only
		      //
		      var dimensions = this.filterManager.effectElements[1].p.v;
		      var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq
		      var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

		      this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

		      // Repeat edges mapping:
		      //
		      //   0 -> off -> duplicate
		      //   1 -> on  -> wrap
		      var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
		      this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
		    }
		  };

		  function TransformEffect() {}
		  TransformEffect.prototype.init = function (effectsManager) {
		    this.effectsManager = effectsManager;
		    this.type = effectTypes.TRANSFORM_EFFECT;
		    this.matrix = new Matrix();
		    this.opacity = -1;
		    this._mdf = false;
		    this._opMdf = false;
		  };
		  TransformEffect.prototype.renderFrame = function (forceFrame) {
		    this._opMdf = false;
		    this._mdf = false;
		    if (forceFrame || this.effectsManager._mdf) {
		      var effectElements = this.effectsManager.effectElements;
		      var anchor = effectElements[0].p.v;
		      var position = effectElements[1].p.v;
		      var isUniformScale = effectElements[2].p.v === 1;
		      var scaleHeight = effectElements[3].p.v;
		      var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
		      var skew = effectElements[5].p.v;
		      var skewAxis = effectElements[6].p.v;
		      var rotation = effectElements[7].p.v;
		      this.matrix.reset();
		      this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
		      this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
		      this.matrix.rotate(-rotation * degToRads);
		      this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
		      this.matrix.translate(position[0], position[1], 0);
		      this._mdf = true;
		      if (this.opacity !== effectElements[8].p.v) {
		        this.opacity = effectElements[8].p.v;
		        this._opMdf = true;
		      }
		    }
		  };

		  function SVGTransformEffect(_, filterManager) {
		    this.init(filterManager);
		  }
		  extendPrototype([TransformEffect], SVGTransformEffect);

		  function CVTransformEffect(effectsManager) {
		    this.init(effectsManager);
		  }
		  extendPrototype([TransformEffect], CVTransformEffect);

		  // Registering renderers
		  registerRenderer('canvas', CanvasRenderer);
		  registerRenderer('html', HybridRenderer);
		  registerRenderer('svg', SVGRenderer);

		  // Registering shape modifiers
		  ShapeModifiers.registerModifier('tm', TrimModifier);
		  ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
		  ShapeModifiers.registerModifier('rp', RepeaterModifier);
		  ShapeModifiers.registerModifier('rd', RoundCornersModifier);
		  ShapeModifiers.registerModifier('zz', ZigZagModifier);
		  ShapeModifiers.registerModifier('op', OffsetPathModifier);

		  // Registering expression plugin
		  setExpressionsPlugin(Expressions);
		  setExpressionInterfaces(getInterface);
		  initialize$1();
		  initialize();

		  // Registering svg effects
		  registerEffect$1(20, SVGTintFilter, true);
		  registerEffect$1(21, SVGFillFilter, true);
		  registerEffect$1(22, SVGStrokeEffect, false);
		  registerEffect$1(23, SVGTritoneFilter, true);
		  registerEffect$1(24, SVGProLevelsFilter, true);
		  registerEffect$1(25, SVGDropShadowEffect, true);
		  registerEffect$1(28, SVGMatte3Effect, false);
		  registerEffect$1(29, SVGGaussianBlurEffect, true);
		  registerEffect$1(35, SVGTransformEffect, false);
		  registerEffect(35, CVTransformEffect);

		  return lottie;

		})); 
	} (lottie, lottie.exports));
	return lottie.exports;
}

(function (module, exports) {
	(function (global, factory) {
	  factory(exports, requireLottie(), React) ;
	})(commonjsGlobal, (function (exports, lottie, React) {
	  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	  var lottie__default = /*#__PURE__*/_interopDefaultLegacy(lottie);
	  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

	  function _arrayLikeToArray(r, a) {
	    (null == a || a > r.length) && (a = r.length);
	    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	    return n;
	  }
	  function _arrayWithHoles(r) {
	    if (Array.isArray(r)) return r;
	  }
	  function _defineProperty(e, r, t) {
	    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	      value: t,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }) : e[r] = t, e;
	  }
	  function _iterableToArrayLimit(r, l) {
	    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	    if (null != t) {
	      var e,
	        n,
	        i,
	        u,
	        a = [],
	        f = !0,
	        o = !1;
	      try {
	        if (i = (t = t.call(r)).next, 0 === l) {
	          if (Object(t) !== t) return;
	          f = !1;
	        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
	      } catch (r) {
	        o = !0, n = r;
	      } finally {
	        try {
	          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
	        } finally {
	          if (o) throw n;
	        }
	      }
	      return a;
	    }
	  }
	  function _nonIterableRest() {
	    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }
	  function ownKeys(e, r) {
	    var t = Object.keys(e);
	    if (Object.getOwnPropertySymbols) {
	      var o = Object.getOwnPropertySymbols(e);
	      r && (o = o.filter(function (r) {
	        return Object.getOwnPropertyDescriptor(e, r).enumerable;
	      })), t.push.apply(t, o);
	    }
	    return t;
	  }
	  function _objectSpread2(e) {
	    for (var r = 1; r < arguments.length; r++) {
	      var t = null != arguments[r] ? arguments[r] : {};
	      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
	        _defineProperty(e, r, t[r]);
	      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	      });
	    }
	    return e;
	  }
	  function _objectWithoutProperties(e, t) {
	    if (null == e) return {};
	    var o,
	      r,
	      i = _objectWithoutPropertiesLoose(e, t);
	    if (Object.getOwnPropertySymbols) {
	      var s = Object.getOwnPropertySymbols(e);
	      for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	    }
	    return i;
	  }
	  function _objectWithoutPropertiesLoose(r, e) {
	    if (null == r) return {};
	    var t = {};
	    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
	      if (e.includes(n)) continue;
	      t[n] = r[n];
	    }
	    return t;
	  }
	  function _slicedToArray(r, e) {
	    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
	  }
	  function _toPrimitive(t, r) {
	    if ("object" != typeof t || !t) return t;
	    var e = t[Symbol.toPrimitive];
	    if (void 0 !== e) {
	      var i = e.call(t, r || "default");
	      if ("object" != typeof i) return i;
	      throw new TypeError("@@toPrimitive must return a primitive value.");
	    }
	    return ("string" === r ? String : Number)(t);
	  }
	  function _toPropertyKey(t) {
	    var i = _toPrimitive(t, "string");
	    return "symbol" == typeof i ? i : i + "";
	  }
	  function _unsupportedIterableToArray(r, a) {
	    if (r) {
	      if ("string" == typeof r) return _arrayLikeToArray(r, a);
	      var t = {}.toString.call(r).slice(8, -1);
	      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
	    }
	  }

	  var _excluded$1 = ["animationData", "loop", "autoplay", "initialSegment", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart", "onConfigReady", "onDataReady", "onDataFailed", "onLoadedImages", "onDOMLoaded", "onDestroy", "lottieRef", "renderer", "name", "assetsPath", "rendererSettings"];
	  var useLottie = function useLottie(props, style) {
	    var animationData = props.animationData,
	      loop = props.loop,
	      autoplay = props.autoplay,
	      initialSegment = props.initialSegment,
	      onComplete = props.onComplete,
	      onLoopComplete = props.onLoopComplete,
	      onEnterFrame = props.onEnterFrame,
	      onSegmentStart = props.onSegmentStart,
	      onConfigReady = props.onConfigReady,
	      onDataReady = props.onDataReady,
	      onDataFailed = props.onDataFailed,
	      onLoadedImages = props.onLoadedImages,
	      onDOMLoaded = props.onDOMLoaded,
	      onDestroy = props.onDestroy;
	      props.lottieRef;
	      props.renderer;
	      props.name;
	      props.assetsPath;
	      props.rendererSettings;
	      var rest = _objectWithoutProperties(props, _excluded$1);
	    var _useState = React.useState(false),
	      _useState2 = _slicedToArray(_useState, 2),
	      animationLoaded = _useState2[0],
	      setAnimationLoaded = _useState2[1];
	    var animationInstanceRef = React.useRef();
	    var animationContainer = React.useRef(null);
	    /*
	          ======================================
	              INTERACTION METHODS
	          ======================================
	       */
	    /**
	     * Play
	     */
	    var play = function play() {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();
	    };
	    /**
	     * Stop
	     */
	    var stop = function stop() {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();
	    };
	    /**
	     * Pause
	     */
	    var pause = function pause() {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();
	    };
	    /**
	     * Set animation speed
	     * @param speed
	     */
	    var setSpeed = function setSpeed(speed) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);
	    };
	    /**
	     * Got to frame and play
	     * @param value
	     * @param isFrame
	     */
	    var goToAndPlay = function goToAndPlay(value, isFrame) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value, isFrame);
	    };
	    /**
	     * Got to frame and stop
	     * @param value
	     * @param isFrame
	     */
	    var goToAndStop = function goToAndStop(value, isFrame) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value, isFrame);
	    };
	    /**
	     * Set animation direction
	     * @param direction
	     */
	    var setDirection = function setDirection(direction) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);
	    };
	    /**
	     * Play animation segments
	     * @param segments
	     * @param forceFlag
	     */
	    var playSegments = function playSegments(segments, forceFlag) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);
	    };
	    /**
	     * Set sub frames
	     * @param useSubFrames
	     */
	    var setSubframe = function setSubframe(useSubFrames) {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);
	    };
	    /**
	     * Get animation duration
	     * @param inFrames
	     */
	    var getDuration = function getDuration(inFrames) {
	      var _a;
	      return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);
	    };
	    /**
	     * Destroy animation
	     */
	    var destroy = function destroy() {
	      var _a;
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
	      // Removing the reference to the animation so separate cleanups are skipped.
	      // Without it the internal `lottie-react` instance throws exceptions as it already cleared itself on destroy.
	      animationInstanceRef.current = undefined;
	    };
	    /*
	          ======================================
	              LOTTIE
	          ======================================
	       */
	    /**
	     * Load a new animation, and if it's the case, destroy the previous one
	     * @param {Object} forcedConfigs
	     */
	    var loadAnimation = function loadAnimation() {
	      var forcedConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _a;
	      // Return if the container ref is null
	      if (!animationContainer.current) {
	        return;
	      }
	      // Destroy any previous instance
	      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
	      // Build the animation configuration
	      var config = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {
	        container: animationContainer.current
	      });
	      // Save the animation instance
	      animationInstanceRef.current = lottie__default["default"].loadAnimation(config);
	      setAnimationLoaded(!!animationInstanceRef.current);
	      // Return a function that will clean up
	      return function () {
	        var _a;
	        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
	        animationInstanceRef.current = undefined;
	      };
	    };
	    /**
	     * (Re)Initialize when animation data changed
	     */
	    React.useEffect(function () {
	      var onUnmount = loadAnimation();
	      // Clean up on unmount
	      return function () {
	        return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
	      };
	      // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [animationData, loop]);
	    // Update the autoplay state
	    React.useEffect(function () {
	      if (!animationInstanceRef.current) {
	        return;
	      }
	      animationInstanceRef.current.autoplay = !!autoplay;
	    }, [autoplay]);
	    // Update the initial segment state
	    React.useEffect(function () {
	      if (!animationInstanceRef.current) {
	        return;
	      }
	      // When null should reset to default animation length
	      if (!initialSegment) {
	        animationInstanceRef.current.resetSegments(true);
	        return;
	      }
	      // If it's not a valid segment, do nothing
	      if (!Array.isArray(initialSegment) || !initialSegment.length) {
	        return;
	      }
	      // If the current position it's not in the new segment
	      // set the current position to start
	      if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {
	        animationInstanceRef.current.currentRawFrame = initialSegment[0];
	      }
	      // Update the segment
	      animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);
	    }, [initialSegment]);
	    /*
	          ======================================
	              EVENTS
	          ======================================
	       */
	    /**
	     * Reinitialize listener on change
	     */
	    React.useEffect(function () {
	      var partialListeners = [{
	        name: "complete",
	        handler: onComplete
	      }, {
	        name: "loopComplete",
	        handler: onLoopComplete
	      }, {
	        name: "enterFrame",
	        handler: onEnterFrame
	      }, {
	        name: "segmentStart",
	        handler: onSegmentStart
	      }, {
	        name: "config_ready",
	        handler: onConfigReady
	      }, {
	        name: "data_ready",
	        handler: onDataReady
	      }, {
	        name: "data_failed",
	        handler: onDataFailed
	      }, {
	        name: "loaded_images",
	        handler: onLoadedImages
	      }, {
	        name: "DOMLoaded",
	        handler: onDOMLoaded
	      }, {
	        name: "destroy",
	        handler: onDestroy
	      }];
	      var listeners = partialListeners.filter(function (listener) {
	        return listener.handler != null;
	      });
	      if (!listeners.length) {
	        return;
	      }
	      var deregisterList = listeners.map(
	      /**
	       * Handle the process of adding an event listener
	       * @param {Listener} listener
	       * @return {Function} Function that deregister the listener
	       */
	      function (listener) {
	        var _a;
	        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);
	        // Return a function to deregister this listener
	        return function () {
	          var _a;
	          (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(listener.name, listener.handler);
	        };
	      });
	      // Deregister listeners on unmount
	      return function () {
	        deregisterList.forEach(function (deregister) {
	          return deregister();
	        });
	      };
	    }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);
	    /**
	     * Build the animation view
	     */
	    var View = /*#__PURE__*/React__default["default"].createElement("div", _objectSpread2({
	      style: style,
	      ref: animationContainer
	    }, rest));
	    return {
	      View: View,
	      play: play,
	      stop: stop,
	      pause: pause,
	      setSpeed: setSpeed,
	      goToAndStop: goToAndStop,
	      goToAndPlay: goToAndPlay,
	      setDirection: setDirection,
	      playSegments: playSegments,
	      setSubframe: setSubframe,
	      getDuration: getDuration,
	      destroy: destroy,
	      animationContainerRef: animationContainer,
	      animationLoaded: animationLoaded,
	      animationItem: animationInstanceRef.current
	    };
	  };

	  // helpers
	  function getContainerVisibility(container) {
	    var _container$getBoundin = container.getBoundingClientRect(),
	      top = _container$getBoundin.top,
	      height = _container$getBoundin.height;
	    var current = window.innerHeight - top;
	    var max = window.innerHeight + height;
	    return current / max;
	  }
	  function getContainerCursorPosition(container, cursorX, cursorY) {
	    var _container$getBoundin2 = container.getBoundingClientRect(),
	      top = _container$getBoundin2.top,
	      left = _container$getBoundin2.left,
	      width = _container$getBoundin2.width,
	      height = _container$getBoundin2.height;
	    var x = (cursorX - left) / width;
	    var y = (cursorY - top) / height;
	    return {
	      x: x,
	      y: y
	    };
	  }
	  var useInitInteractivity = function useInitInteractivity(_ref) {
	    var wrapperRef = _ref.wrapperRef,
	      animationItem = _ref.animationItem,
	      mode = _ref.mode,
	      actions = _ref.actions;
	    React.useEffect(function () {
	      var wrapper = wrapperRef.current;
	      if (!wrapper || !animationItem || !actions.length) {
	        return;
	      }
	      animationItem.stop();
	      var scrollModeHandler = function scrollModeHandler() {
	        var assignedSegment = null;
	        var scrollHandler = function scrollHandler() {
	          var currentPercent = getContainerVisibility(wrapper);
	          // Find the first action that satisfies the current position conditions
	          var action = actions.find(function (_ref2) {
	            var visibility = _ref2.visibility;
	            return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];
	          });
	          // Skip if no matching action was found!
	          if (!action) {
	            return;
	          }
	          if (action.type === "seek" && action.visibility && action.frames.length === 2) {
	            // Seek: Go to a frame based on player scroll position action
	            var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);
	            //! goToAndStop must be relative to the start of the current segment
	            animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);
	          }
	          if (action.type === "loop") {
	            // Loop: Loop a given frames
	            if (assignedSegment === null) {
	              // if not playing any segments currently. play those segments and save to state
	              animationItem.playSegments(action.frames, true);
	              assignedSegment = action.frames;
	            } else {
	              // if playing any segments currently.
	              //check if segments in state are equal to the frames selected by action
	              if (assignedSegment !== action.frames) {
	                // if they are not equal. new segments are to be loaded
	                animationItem.playSegments(action.frames, true);
	                assignedSegment = action.frames;
	              } else if (animationItem.isPaused) {
	                // if they are equal the play method must be called only if lottie is paused
	                animationItem.playSegments(action.frames, true);
	                assignedSegment = action.frames;
	              }
	            }
	          }
	          if (action.type === "play" && animationItem.isPaused) {
	            // Play: Reset segments and continue playing full animation from current position
	            animationItem.resetSegments(true);
	            animationItem.play();
	          }
	          if (action.type === "stop") {
	            // Stop: Stop playback
	            animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);
	          }
	        };
	        document.addEventListener("scroll", scrollHandler);
	        return function () {
	          document.removeEventListener("scroll", scrollHandler);
	        };
	      };
	      var cursorModeHandler = function cursorModeHandler() {
	        var handleCursor = function handleCursor(_x, _y) {
	          var x = _x;
	          var y = _y;
	          // Resolve cursor position if cursor is inside container
	          if (x !== -1 && y !== -1) {
	            // Get container cursor position
	            var pos = getContainerCursorPosition(wrapper, x, y);
	            // Use the resolved position
	            x = pos.x;
	            y = pos.y;
	          }
	          // Find the first action that satisfies the current position conditions
	          var action = actions.find(function (_ref3) {
	            var position = _ref3.position;
	            if (position && Array.isArray(position.x) && Array.isArray(position.y)) {
	              return x >= position.x[0] && x <= position.x[1] && y >= position.y[0] && y <= position.y[1];
	            }
	            if (position && !Number.isNaN(position.x) && !Number.isNaN(position.y)) {
	              return x === position.x && y === position.y;
	            }
	            return false;
	          });
	          // Skip if no matching action was found!
	          if (!action) {
	            return;
	          }
	          // Process action types:
	          if (action.type === "seek" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {
	            // Seek: Go to a frame based on player scroll position action
	            var xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);
	            var yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);
	            animationItem.playSegments(action.frames, true);
	            animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);
	          }
	          if (action.type === "loop") {
	            animationItem.playSegments(action.frames, true);
	          }
	          if (action.type === "play") {
	            // Play: Reset segments and continue playing full animation from current position
	            if (animationItem.isPaused) {
	              animationItem.resetSegments(false);
	            }
	            animationItem.playSegments(action.frames);
	          }
	          if (action.type === "stop") {
	            animationItem.goToAndStop(action.frames[0], true);
	          }
	        };
	        var mouseMoveHandler = function mouseMoveHandler(ev) {
	          handleCursor(ev.clientX, ev.clientY);
	        };
	        var mouseOutHandler = function mouseOutHandler() {
	          handleCursor(-1, -1);
	        };
	        wrapper.addEventListener("mousemove", mouseMoveHandler);
	        wrapper.addEventListener("mouseout", mouseOutHandler);
	        return function () {
	          wrapper.removeEventListener("mousemove", mouseMoveHandler);
	          wrapper.removeEventListener("mouseout", mouseOutHandler);
	        };
	      };
	      switch (mode) {
	        case "scroll":
	          return scrollModeHandler();
	        case "cursor":
	          return cursorModeHandler();
	      }
	      // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [mode, animationItem]);
	  };
	  var useLottieInteractivity = function useLottieInteractivity(_ref4) {
	    var actions = _ref4.actions,
	      mode = _ref4.mode,
	      lottieObj = _ref4.lottieObj;
	    var animationItem = lottieObj.animationItem,
	      View = lottieObj.View,
	      animationContainerRef = lottieObj.animationContainerRef;
	    useInitInteractivity({
	      actions: actions,
	      animationItem: animationItem,
	      mode: mode,
	      wrapperRef: animationContainerRef
	    });
	    return View;
	  };

	  var _excluded = ["style", "interactivity"];
	  var Lottie = function Lottie(props) {
	    var _a, _b, _c;
	    var style = props.style,
	      interactivity = props.interactivity,
	      lottieProps = _objectWithoutProperties(props, _excluded);
	    /**
	     * Initialize the 'useLottie' hook
	     */
	    var _useLottie = useLottie(lottieProps, style),
	      View = _useLottie.View,
	      play = _useLottie.play,
	      stop = _useLottie.stop,
	      pause = _useLottie.pause,
	      setSpeed = _useLottie.setSpeed,
	      goToAndStop = _useLottie.goToAndStop,
	      goToAndPlay = _useLottie.goToAndPlay,
	      setDirection = _useLottie.setDirection,
	      playSegments = _useLottie.playSegments,
	      setSubframe = _useLottie.setSubframe,
	      getDuration = _useLottie.getDuration,
	      destroy = _useLottie.destroy,
	      animationContainerRef = _useLottie.animationContainerRef,
	      animationLoaded = _useLottie.animationLoaded,
	      animationItem = _useLottie.animationItem;
	    /**
	     * Make the hook variables/methods available through the provided 'lottieRef'
	     */
	    React.useEffect(function () {
	      if (props.lottieRef) {
	        props.lottieRef.current = {
	          play: play,
	          stop: stop,
	          pause: pause,
	          setSpeed: setSpeed,
	          goToAndPlay: goToAndPlay,
	          goToAndStop: goToAndStop,
	          setDirection: setDirection,
	          playSegments: playSegments,
	          setSubframe: setSubframe,
	          getDuration: getDuration,
	          destroy: destroy,
	          animationContainerRef: animationContainerRef,
	          animationLoaded: animationLoaded,
	          animationItem: animationItem
	        };
	      }
	      // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);
	    return useLottieInteractivity({
	      lottieObj: {
	        View: View,
	        play: play,
	        stop: stop,
	        pause: pause,
	        setSpeed: setSpeed,
	        goToAndStop: goToAndStop,
	        goToAndPlay: goToAndPlay,
	        setDirection: setDirection,
	        playSegments: playSegments,
	        setSubframe: setSubframe,
	        getDuration: getDuration,
	        destroy: destroy,
	        animationContainerRef: animationContainerRef,
	        animationLoaded: animationLoaded,
	        animationItem: animationItem
	      },
	      actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],
	      mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : "scroll"
	    });
	  };

	  Object.defineProperty(exports, 'LottiePlayer', {
	    enumerable: true,
	    get: function () { return lottie__default["default"]; }
	  });
	  exports["default"] = Lottie;
	  exports.useLottie = useLottie;
	  exports.useLottieInteractivity = useLottieInteractivity;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));
	
} (index_umd, index_umd.exports));

var index_umdExports = index_umd.exports;
var Lottie = /*@__PURE__*/getDefaultExportFromCjs(index_umdExports);

var YouthLottie = forwardRef(function (_a, ref) {
  var animationData = _a.animationData,
    _b = _a.loop,
    loop = _b === void 0 ? true : _b,
    _c = _a.autoplay,
    autoplay = _c === void 0 ? true : _c,
    _d = _a.speed,
    speed = _d === void 0 ? 1 : _d,
    _e = _a.direction,
    direction = _e === void 0 ? 1 : _e,
    width = _a.width,
    height = _a.height,
    _f = _a.className,
    className = _f === void 0 ? '' : _f,
    _g = _a.style,
    style = _g === void 0 ? {} : _g,
    onComplete = _a.onComplete,
    onLoopComplete = _a.onLoopComplete,
    segments = _a.segments,
    rendererSettings = _a.rendererSettings;
  var lottieRef = useRef(null);
  // 외부에서 사용할 수 있는 메서드들을 정의
  useImperativeHandle(ref, function () {
    return {
      play: function () {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.play();
      },
      stop: function () {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.stop();
      },
      pause: function () {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.pause();
      },
      goToAndStop: function (frame) {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(frame, true);
      },
      goToAndPlay: function (frame) {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(frame, true);
      },
      setSpeed: function (speed) {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);
      },
      setDirection: function (direction) {
        var _a;
        return (_a = lottieRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);
      },
      getLottieInstance: function () {
        return lottieRef.current;
      }
    };
  });
  // 애니메이션 완료 콜백
  var handleComplete = useCallback(function () {
    if (onComplete) {
      onComplete();
    }
  }, [onComplete]);
  // 애니메이션 반복 완료 콜백
  var handleLoopComplete = useCallback(function () {
    if (onLoopComplete) {
      onLoopComplete();
    }
  }, [onLoopComplete]);
  // 컨테이너 스타일
  var containerStyle = __assign({
    width: width || '100%',
    height: height || 'auto',
    display: 'inline-block'
  }, style);
  // Lottie 옵션
  var lottieOptions = __assign({
    animationData: animationData,
    loop: loop,
    autoplay: autoplay,
    onComplete: handleComplete,
    onLoopComplete: handleLoopComplete,
    lottieRef: lottieRef,
    rendererSettings: __assign({
      preserveAspectRatio: 'xMidYMid slice',
      clearCanvas: true,
      progressiveLoad: false,
      hideOnTransparent: true
    }, rendererSettings)
  }, segments && {
    segments: segments
  });
  // 애니메이션 설정 적용
  React.useEffect(function () {
    if (lottieRef.current) {
      lottieRef.current.setSpeed(speed);
      lottieRef.current.setDirection(direction);
    }
  }, [speed, direction]);
  return jsx("div", {
    className: "youth-lottie ".concat(className),
    style: containerStyle,
    role: "img",
    "aria-label": "\uC560\uB2C8\uBA54\uC774\uC158",
    children: jsx(Lottie, __assign({}, lottieOptions))
  });
});
YouthLottie.displayName = 'YouthLottie';

var TextInput = forwardRef(function (_a, ref) {
  var _b = _a.placeholder,
    placeholder = _b === void 0 ? 'Placeholder' : _b,
    value = _a.value,
    defaultValue = _a.defaultValue,
    onChange = _a.onChange,
    onFocus = _a.onFocus,
    onBlur = _a.onBlur,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    _d = _a.error,
    error = _d === void 0 ? false : _d,
    errorMessage = _a.errorMessage,
    _e = _a.className,
    className = _e === void 0 ? '' : _e,
    _f = _a.type,
    type = _f === void 0 ? 'text' : _f,
    _g = _a.size,
    size = _g === void 0 ? 'l' : _g,
    restProps = __rest(_a, ["placeholder", "value", "defaultValue", "onChange", "onFocus", "onBlur", "disabled", "error", "errorMessage", "className", "type", "size"]);
  var _h = useState(false),
    isFocused = _h[0],
    setIsFocused = _h[1];
  var _j = useState(defaultValue || ''),
    internalValue = _j[0],
    setInternalValue = _j[1];
  // Size configurations
  var sizeConfig = {
    l: __assign(__assign({
      paddingX: '16px',
      paddingY: '12px',
      borderRadius: '12px',
      height: '48px'
    }, textStyles.body1), {
      fontWeight: fontWeight.regular
    }),
    m: __assign(__assign({
      paddingX: '12px',
      paddingY: '8px',
      borderRadius: '8px',
      height: '40px'
    }, textStyles.body2), {
      fontWeight: fontWeight.regular
    }),
    s: __assign(__assign({
      paddingX: '8px',
      paddingY: '6px',
      borderRadius: '4px',
      height: '32px'
    }, textStyles.body3), {
      fontWeight: fontWeight.regular
    })
  };
  var getStyles = function () {
    var config = sizeConfig[size];
    var styles = {
      width: '100%',
      height: config.height,
      padding: "".concat(config.paddingY, " ").concat(config.paddingX),
      borderRadius: config.borderRadius,
      fontSize: config.fontSize,
      fontWeight: config.fontWeight,
      lineHeight: config.lineHeight,
      border: "".concat(border.s, " transparent"),
      outline: 'none',
      transition: 'all 0.2s ease',
      fontFamily: 'inherit'
    };
    if (disabled) {
      styles = __assign(__assign({}, styles), {
        backgroundColor: colors.semantic.disabled.background,
        color: colors.semantic.disabled.foreground,
        border: "".concat(border.s, " ").concat(colors.semantic.disabled.background),
        cursor: 'not-allowed'
      });
    } else if (error) {
      styles = __assign(__assign({}, styles), {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.text.primary,
        border: "".concat(border.s, " ").concat(colors.semantic.state.error)
      });
    } else if (isFocused) {
      styles = __assign(__assign({}, styles), {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.text.primary,
        border: "".concat(border.s, " ").concat(colors.primary.mainviolet),
        boxShadow: "0 0 0 3px ".concat(colors.primary.tint.violet[100])
      });
    } else {
      styles = __assign(__assign({}, styles), {
        backgroundColor: colors.semantic.background.primary,
        color: colors.semantic.text.primary,
        border: "".concat(border.s, " ").concat(colors.semantic.border.default)
      });
    }
    return styles;
  };
  var handleFocus = function () {
    if (!disabled) {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    }
  };
  var handleBlur = function () {
    setIsFocused(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur();
  };
  var handleChange = function (e) {
    var newValue = e.target.value;
    if (value === undefined) {
      setInternalValue(newValue);
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
  };
  var inputValue = value !== undefined ? value : internalValue;
  return jsxs("div", {
    className: "text-input-container ".concat(className),
    children: [jsx("input", __assign({
      ref: ref,
      type: type,
      value: inputValue,
      placeholder: placeholder,
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      disabled: disabled,
      style: getStyles(),
      className: "text-input"
    }, restProps)), error && errorMessage && jsx("div", {
      style: {
        marginTop: '4px',
        fontSize: '12px',
        color: colors.semantic.state.error,
        fontWeight: fontWeight.regular
      },
      className: "error-message",
      children: errorMessage
    })]
  });
});
TextInput.displayName = 'TextInput';

var TextButton = function (_a) {
  var _b = _a.size,
    size = _b === void 0 ? 'm' : _b,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    _d = _a.underline,
    underline = _d === void 0 ? false : _d,
    icon = _a.icon,
    children = _a.children,
    onClick = _a.onClick,
    _e = _a.className,
    className = _e === void 0 ? '' : _e,
    width = _a.width,
    height = _a.height,
    _f = _a.chevron,
    chevron = _f === void 0 ? false : _f,
    color = _a.color;
  // Size configurations
  var sizeConfig = {
    m: __assign(__assign({}, textStyles.body1), {
      fontWeight: fontWeight.medium,
      padding: '4px 8px'
    }),
    s: __assign(__assign({}, textStyles.body2), {
      fontWeight: fontWeight.medium,
      padding: '3px 6px'
    }),
    xs: __assign(__assign({}, textStyles.body3), {
      fontWeight: fontWeight.medium,
      padding: '2px 4px'
    })
  };
  var getTextColor = function () {
    if (disabled) {
      return colors.semantic.disabled.foreground;
    }
    return color || colors.primary.coolGray[800];
  };
  var getStyles = function () {
    var config = sizeConfig[size];
    var textColor = getTextColor();
    // 아이콘이 있는지 확인
    var hasIcons = (icon === null || icon === void 0 ? void 0 : icon.left) || (icon === null || icon === void 0 ? void 0 : icon.right);
    return {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: config.padding,
      border: 'none',
      background: 'transparent',
      cursor: disabled ? 'not-allowed' : 'pointer',
      fontSize: config.fontSize,
      lineHeight: config.lineHeight,
      fontWeight: config.fontWeight,
      color: textColor,
      textDecoration: underline ? 'underline' : 'none',
      textUnderlineOffset: underline ? '2px' : undefined,
      width: width || 'auto',
      height: height || 'auto',
      minWidth: 'fit-content',
      minHeight: 'fit-content',
      gap: hasIcons ? '4px' : '0px',
      transition: 'all 0.2s ease'
    };
  };
  var handleClick = function () {
    if (!disabled && onClick) {
      onClick();
    }
  };
  var renderContent = function () {
    var textColor = getTextColor();
    return jsxs(Fragment, {
      children: [(icon === null || icon === void 0 ? void 0 : icon.left) && icon.left, jsxs("div", {
        style: {
          display: 'flex',
          alignItems: 'center'
        },
        children: [children && jsx("span", {
          children: children
        }), chevron && jsx(Icon, {
          type: "arrow-right",
          size: 20,
          color: textColor
        })]
      }), (icon === null || icon === void 0 ? void 0 : icon.right) && !chevron && icon.right]
    });
  };
  return jsx("button", {
    style: getStyles(),
    onClick: handleClick,
    disabled: disabled,
    className: className,
    children: renderContent()
  });
};

var Tab = function (_a) {
  var _b = _a.type,
    type = _b === void 0 ? 'underline' : _b,
    _c = _a.size,
    size = _c === void 0 ? 'm' : _c,
    _d = _a.selected,
    selected = _d === void 0 ? false : _d,
    _e = _a.disabled,
    disabled = _e === void 0 ? false : _e,
    icon = _a.icon,
    number = _a.number,
    children = _a.children,
    onClick = _a.onClick,
    _f = _a.className,
    className = _f === void 0 ? '' : _f,
    style = _a.style,
    width = _a.width;
  var getSizeConfig = function () {
    var getFontWeight = function () {
      if (type === 'toggle') {
        return selected ? fontWeight.semibold : fontWeight.medium;
      }
      return fontWeight.semibold;
    };
    var configs = {
      l: __assign(__assign({}, type === 'underline' ? textStyles.heading4 : type === 'capsule' ? textStyles.heading4 : textStyles.body1), {
        height: type === 'underline' ? 64 : type === 'capsule' ? 42 : 40,
        padding: type === 'underline' ? '0 8px' : type === 'capsule' ? '10px 16px' : '0 8px',
        fontWeight: getFontWeight(),
        iconSize: 20,
        borderRadius: type === 'capsule' ? 100 : type === 'toggle' ? 8 : 0
      }),
      m: __assign(__assign({}, type === 'underline' ? textStyles.heading4 : type === 'capsule' ? textStyles.heading4 : textStyles.body3), {
        height: type === 'underline' ? 48 : type === 'capsule' ? 36 : 32,
        padding: type === 'underline' ? '0 8px' : type === 'capsule' ? '6px 12px' : '0 8px',
        fontWeight: getFontWeight(),
        iconSize: 16,
        borderRadius: type === 'capsule' ? 100 : type === 'toggle' ? 6 : 0
      }),
      s: __assign(__assign({}, type === 'underline' ? textStyles.heading5 : type === 'capsule' ? textStyles.body3 : textStyles.body2), {
        height: type === 'underline' ? 40 : type === 'capsule' ? 30 : 28,
        padding: type === 'underline' ? '0 8px' : type === 'capsule' ? '5px 12px' : '4px 8px',
        fontWeight: getFontWeight(),
        iconSize: 16,
        borderRadius: type === 'capsule' ? 100 : type === 'toggle' ? 4 : 0
      })
    };
    return configs[size];
  };
  var getTabWidth = function () {
    if (width === 'fill') {
      return '100%';
    }
    if (width) {
      return width;
    }
    return 'fit-content';
  };
  var getColors = function () {
    if (disabled) {
      return {
        text: colors.semantic.disabled.foreground,
        background: 'transparent',
        border: 'transparent',
        number: colors.semantic.disabled.foreground
      };
    }
    switch (type) {
      case 'underline':
        if (selected) {
          return {
            text: colors.primary.coolGray[800],
            background: 'transparent',
            border: colors.primary.coolGray[800],
            number: colors.primary.tint.violet[500]
          };
        }
        return {
          text: colors.primary.coolGray[400],
          background: 'transparent',
          border: 'transparent',
          number: colors.primary.coolGray[200]
        };
      case 'capsule':
        if (selected) {
          return {
            text: colors.primary.gray.white,
            background: colors.primary.coolGray[800],
            border: 'transparent',
            number: colors.primary.tint.violet[500]
          };
        }
        return {
          text: colors.primary.coolGray[800],
          background: 'transparent',
          border: colors.primary.coolGray[300],
          number: colors.primary.coolGray[400]
        };
      case 'toggle':
        if (selected) {
          return {
            text: colors.primary.coolGray[800],
            background: colors.primary.gray.white,
            border: 'transparent',
            number: colors.primary.tint.violet[500]
          };
        }
        return {
          text: colors.primary.coolGray[400],
          background: 'transparent',
          border: 'transparent',
          number: colors.primary.coolGray[200]
        };
      default:
        return {
          text: colors.primary.coolGray[400],
          background: 'transparent',
          border: 'transparent',
          number: colors.primary.coolGray[200]
        };
    }
  };
  var config = getSizeConfig();
  var colorScheme = getColors();
  var getBaseStyles = function () {
    return __assign({
      display: width === 'fill' ? 'flex' : 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '4px',
      height: config.height,
      padding: config.padding,
      fontSize: config.fontSize,
      fontWeight: config.fontWeight,
      borderRadius: config.borderRadius,
      border: type === 'capsule' ? "1px solid ".concat(colorScheme.border) : 'none',
      background: colorScheme.background,
      color: colorScheme.text,
      cursor: disabled ? 'not-allowed' : 'pointer',
      transition: 'all 0.2s ease',
      boxShadow: type === 'toggle' && selected ? '0px 1px 8px 0px rgba(21, 23, 25, 0.08)' : 'none',
      position: 'relative',
      minWidth: width === 'fill' ? '0' : 'fit-content',
      width: getTabWidth()
    }, style);
  };
  var getHoverStyles = function () {
    if (disabled || selected) return {};
    switch (type) {
      case 'underline':
        return {
          color: colors.primary.coolGray[600]
        };
      case 'capsule':
        return {
          backgroundColor: colors.primary.coolGray[50],
          borderColor: colors.primary.coolGray[400]
        };
      case 'toggle':
        return {
          backgroundColor: colors.primary.coolGray[100]
        };
      default:
        return {};
    }
  };
  var handleClick = function () {
    if (!disabled && onClick) {
      onClick();
    }
  };
  var handleMouseEnter = function (e) {
    if (disabled || selected) return;
    var hoverStyles = getHoverStyles();
    Object.assign(e.currentTarget.style, hoverStyles);
  };
  var handleMouseLeave = function (e) {
    if (disabled || selected) return;
    // 기본 스타일로 복원
    var baseStyles = getBaseStyles();
    Object.assign(e.currentTarget.style, baseStyles);
  };
  var renderIcon = function () {
    if (!icon) return null;
    return jsx(Icon, {
      type: icon,
      size: config.iconSize,
      color: "currentColor"
    });
  };
  var renderNumber = function () {
    if (number === undefined || number === null || number === '') return null;
    return jsx("span", {
      style: {
        color: colorScheme.number,
        fontSize: config.fontSize,
        fontWeight: config.fontWeight
      },
      children: number
    });
  };
  // underline용 ::after 스타일을 위한 unique id 생성
  var uniqueId = React.useId();
  var buttonId = "tab-".concat(uniqueId);
  return jsxs(Fragment, {
    children: [type === 'underline' && jsx("style", {
      children: "\n            #".concat(buttonId, "::after {\n              content: '';\n              position: absolute;\n              bottom: 0;\n              left: 0;\n              right: 0;\n              height: 2px;\n              background-color: ").concat(selected ? colorScheme.border : 'transparent', ";\n              transition: background-color 0.2s ease;\n            }\n            #").concat(buttonId, ":hover:not(:disabled)::after {\n              background-color: ").concat(!selected && !disabled ? colors.primary.coolGray[300] : selected ? colorScheme.border : 'transparent', ";\n            }\n          ")
    }), jsxs("button", {
      id: buttonId,
      style: getBaseStyles(),
      onClick: handleClick,
      disabled: disabled,
      className: className,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [renderIcon(), jsx("span", {
        children: children
      }), renderNumber()]
    })]
  });
};

var TabBar = function (_a) {
  var _b = _a.type,
    type = _b === void 0 ? 'underline' : _b,
    _c = _a.size,
    size = _c === void 0 ? 'm' : _c,
    width = _a.width,
    _d = _a.wrap,
    wrap = _d === void 0 ? true : _d,
    _e = _a.defaultSelectedIndex,
    defaultSelectedIndex = _e === void 0 ? 0 : _e,
    selectedIndex = _a.selectedIndex,
    onTabChange = _a.onTabChange,
    tabs = _a.tabs,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(defaultSelectedIndex),
    internalSelectedIndex = _g[0],
    setInternalSelectedIndex = _g[1];
  var currentSelectedIndex = selectedIndex !== undefined ? selectedIndex : internalSelectedIndex;
  var handleTabClick = function (index) {
    var _a;
    if ((_a = tabs[index]) === null || _a === void 0 ? void 0 : _a.disabled) return;
    if (selectedIndex === undefined) {
      setInternalSelectedIndex(index);
    }
    onTabChange === null || onTabChange === void 0 ? void 0 : onTabChange(index);
  };
  var getContainerStyles = function () {
    var baseStyles = {
      display: 'flex',
      alignItems: 'center',
      gap: type === 'toggle' ? '0px' : type === 'capsule' ? '12px' : '8px',
      flexDirection: 'row',
      flexWrap: wrap ? 'wrap' : 'nowrap',
      rowGap: wrap ? type === 'toggle' ? '4px' : type === 'capsule' ? '12px' : '8px' : undefined,
      width: width === 'fill' ? '100%' : width || 'fit-content',
      borderBottom: type === 'underline' ? "1px solid ".concat(colors.semantic.border.default) : 'none',
      background: type === 'toggle' ? colors.primary.coolGray[50] : 'transparent',
      borderRadius: type === 'toggle' ? size === 'l' ? '12px' : '8px' : '0px',
      padding: type === 'toggle' ? '4px' : '0px'
    };
    return baseStyles;
  };
  var getTabStyles = function (index) {
    if (type === 'toggle') {
      return {
        width: width === 'fill' ? 'fill' : undefined,
        style: {
          flex: width === 'fill' ? '1' : 'none',
          minWidth: '0'
        }
      };
    }
    if (width === 'fill') {
      return {
        width: 'fill',
        style: {
          flex: '1',
          minWidth: '0'
        }
      };
    }
    return {};
  };
  return jsx("div", {
    style: getContainerStyles(),
    className: className,
    children: tabs.map(function (tab, index) {
      return jsx(Tab, __assign({
        type: type,
        size: size,
        selected: index === currentSelectedIndex,
        disabled: tab.disabled,
        icon: tab.icon,
        number: tab.number,
        onClick: function () {
          return handleTabClick(index);
        }
      }, getTabStyles(), {
        children: tab.label
      }), index);
    })
  });
};

var Chips = function (_a) {
  var _b = _a.size,
    size = _b === void 0 ? 'medium' : _b,
    _c = _a.type,
    type = _c === void 0 ? 'capsule' : _c,
    _d = _a.state,
    state = _d === void 0 ? 'resting' : _d,
    _e = _a.iconPosition,
    iconPosition = _e === void 0 ? 'leading' : _e,
    icon = _a.icon,
    iconColor = _a.iconColor,
    children = _a.children,
    onClick = _a.onClick,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(false),
    isHovered = _g[0],
    setIsHovered = _g[1];
  // Size configurations
  var sizeConfig = {
    large: {
      paddingX: '16px',
      paddingY: '9px',
      borderRadius: type === 'capsule' ? '100px' : '8px',
      height: '40px',
      gap: '4px'
    },
    medium: {
      paddingX: '12px',
      paddingY: '6px',
      borderRadius: type === 'capsule' ? '100px' : '6px',
      height: '32px',
      gap: '4px'
    }
  };
  var getStyles = function () {
    var config = sizeConfig[size];
    var styles = {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: "".concat(config.paddingY, " ").concat(config.paddingX),
      borderRadius: config.borderRadius,
      height: config.height,
      border: '1px solid transparent',
      cursor: state === 'disabled' ? 'not-allowed' : 'pointer',
      transition: 'all 0.2s ease',
      gap: config.gap,
      whiteSpace: 'nowrap'
    };
    // State에 따른 스타일링
    switch (state) {
      case 'selected':
        if (type === 'square') {
          styles = __assign(__assign({}, styles), {
            backgroundColor: colors.primary.gray.white,
            border: "1px solid ".concat(colors.primary.mainviolet)
          });
        } else {
          styles = __assign(__assign({}, styles), {
            backgroundColor: colors.primary.mainviolet,
            border: "1px solid ".concat(colors.primary.mainviolet)
          });
        }
        break;
      case 'hover':
        styles = __assign(__assign({}, styles), {
          backgroundColor: colors.primary.coolGray[50],
          border: "1px solid ".concat(colors.primary.coolGray[200])
        });
        break;
      case 'disabled':
        styles = __assign(__assign({}, styles), {
          backgroundColor: colors.semantic.disabled.background,
          border: "1px solid ".concat(colors.semantic.disabled.background),
          cursor: 'not-allowed'
        });
        break;
      case 'resting':
      default:
        if (isHovered) {
          styles = __assign(__assign({}, styles), {
            backgroundColor: colors.primary.coolGray[50],
            border: "1px solid ".concat(colors.primary.coolGray[200])
          });
        } else {
          styles = __assign(__assign({}, styles), {
            backgroundColor: colors.primary.gray.white,
            border: "1px solid ".concat(colors.semantic.border.default)
          });
        }
        break;
    }
    return styles;
  };
  var getTextColor = function () {
    switch (state) {
      case 'selected':
        if (type === 'square') {
          return colors.primary.coolGray[800];
        }
        return colors.primary.gray.white;
      case 'disabled':
        return colors.semantic.disabled.foreground;
      default:
        return colors.primary.coolGray[800];
    }
  };
  var getIconColor = function () {
    if (iconColor) {
      return iconColor;
    }
    switch (state) {
      case 'selected':
        if (type === 'square') {
          return colors.primary.mainviolet;
        }
        return colors.primary.gray.white;
      case 'disabled':
        return colors.semantic.disabled.foreground;
      default:
        return colors.primary.coolGray[800];
    }
  };
  var handleClick = function () {
    if (state !== 'disabled' && onClick) {
      onClick();
    }
  };
  var handleMouseEnter = function () {
    if (state === 'resting') {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    setIsHovered(false);
  };
  var renderContent = function () {
    if (!icon) {
      return jsx(Font, {
        type: "body2",
        fontWeight: "medium",
        color: getTextColor(),
        children: children
      });
    }
    if (iconPosition === 'leading') {
      return jsxs(Fragment, {
        children: [jsx("span", {
          className: "chips-icon",
          style: {
            color: getIconColor()
          },
          children: icon
        }), children && jsx(Font, {
          type: "body2",
          fontWeight: "medium",
          color: getTextColor(),
          children: children
        })]
      });
    } else {
      return jsxs(Fragment, {
        children: [children && jsx(Font, {
          type: "body2",
          fontWeight: "medium",
          color: getTextColor(),
          children: children
        }), jsx("span", {
          className: "chips-icon",
          style: {
            color: getIconColor()
          },
          children: icon
        })]
      });
    }
  };
  return jsx("button", {
    className: "chips chips--".concat(size, " chips--").concat(type, " chips--").concat(state, " ").concat(className),
    style: getStyles(),
    onClick: handleClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    disabled: state === 'disabled',
    type: "button",
    children: renderContent()
  });
};

var Radio = function (_a) {
  var _b = _a.checked,
    checked = _b === void 0 ? false : _b,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    name = _a.name,
    value = _a.value,
    label = _a.label,
    description = _a.description,
    _d = _a.labelPosition,
    labelPosition = _d === void 0 ? 'right' : _d,
    _e = _a.size,
    size = _e === void 0 ? 'medium' : _e,
    onChange = _a.onChange,
    onClick = _a.onClick,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(false),
    isHovered = _g[0],
    setIsHovered = _g[1];
  var getSizeConfig = function () {
    switch (size) {
      case 'small':
        return __assign(__assign({}, textStyles.body3), {
          fontWeight: fontWeight.medium,
          radioSize: '16px',
          dotSize: '8px',
          gap: '4px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body3), {
            fontWeight: fontWeight.regular
          })
        });
      case 'medium':
        return __assign(__assign({}, textStyles.body2), {
          fontWeight: fontWeight.medium,
          radioSize: '18px',
          dotSize: '10px',
          gap: '6px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body3), {
            fontWeight: fontWeight.regular
          })
        });
      case 'large':
        return __assign(__assign({}, textStyles.body1), {
          fontWeight: fontWeight.medium,
          radioSize: '22px',
          dotSize: '14px',
          gap: '8px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body2), {
            fontWeight: fontWeight.regular
          })
        });
      default:
        // large
        return __assign(__assign({}, textStyles.body1), {
          fontWeight: fontWeight.medium,
          radioSize: '22px',
          dotSize: '14px',
          gap: '8px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body2), {
            fontWeight: fontWeight.regular
          })
        });
    }
  };
  var sizeConfig = getSizeConfig();
  var getRadioStyles = function () {
    if (disabled) {
      return {
        width: sizeConfig.radioSize,
        height: sizeConfig.radioSize,
        borderRadius: '50%',
        border: "2px solid ".concat(colors.semantic.disabled.foreground),
        backgroundColor: !checked ? colors.semantic.disabled.background : 'transparent',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'not-allowed',
        transition: 'all 0.2s ease',
        position: 'relative'
      };
    } else if (checked) {
      return {
        width: sizeConfig.radioSize,
        height: sizeConfig.radioSize,
        borderRadius: '50%',
        border: "2px solid ".concat(colors.primary.mainviolet),
        backgroundColor: 'transparent',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        transition: 'all 0.2s ease',
        position: 'relative'
      };
    } else if (isHovered) {
      return {
        width: sizeConfig.radioSize,
        height: sizeConfig.radioSize,
        borderRadius: '50%',
        border: "2px solid ".concat(colors.primary.mainviolet),
        backgroundColor: colors.semantic.background.primary,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        transition: 'all 0.2s ease',
        position: 'relative'
      };
    } else {
      return {
        width: sizeConfig.radioSize,
        height: sizeConfig.radioSize,
        borderRadius: '50%',
        border: "2px solid ".concat(colors.semantic.border.strong),
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        transition: 'all 0.2s ease',
        position: 'relative'
      };
    }
  };
  var getDotStyles = function () {
    return {
      width: sizeConfig.dotSize,
      height: sizeConfig.dotSize,
      borderRadius: '50%',
      backgroundColor: checked ? disabled ? colors.semantic.disabled.foreground : colors.primary.mainviolet : 'transparent',
      transition: 'all 0.2s ease'
    };
  };
  var getLabelStyles = function () {
    return __assign(__assign({}, sizeConfig), {
      color: disabled ? colors.semantic.text.disabled : colors.semantic.text.primary,
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var getDescriptionStyles = function () {
    return __assign(__assign({}, sizeConfig.descriptionFontStyle), {
      color: disabled ? colors.semantic.text.disabled : colors.primary.coolGray[300],
      marginTop: '2px',
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var handleChange = function () {
    if (!disabled && !checked) {
      onChange === null || onChange === void 0 ? void 0 : onChange(true, value);
      onClick === null || onClick === void 0 ? void 0 : onClick();
    }
  };
  var handleMouseEnter = function () {
    if (!disabled) {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    if (!disabled) {
      setIsHovered(false);
    }
  };
  var containerStyles = {
    display: 'flex',
    alignItems: description ? 'flex-start' : 'center',
    gap: sizeConfig.gap,
    flexDirection: labelPosition === 'left' ? 'row-reverse' : 'row',
    cursor: disabled ? 'not-allowed' : 'pointer'
  };
  var radioContainerStyles = {
    paddingTop: description ? '2px' : '0' // label의 라인하이트와 맞추기 위한 조정
  };
  var labelContainerStyles = {
    display: 'flex',
    flexDirection: 'column',
    flex: 1
  };
  return jsxs("div", {
    className: "youth-radio-button ".concat(className),
    style: containerStyles,
    onClick: handleChange,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    children: [jsx("input", {
      type: "radio",
      name: name,
      value: value,
      checked: checked,
      disabled: disabled,
      onChange: function () {},
      style: {
        display: 'none'
      }
    }), jsx("div", {
      style: radioContainerStyles,
      children: jsx("div", {
        style: getRadioStyles(),
        children: jsx("div", {
          style: getDotStyles()
        })
      })
    }), (label || description) && jsxs("div", {
      style: labelContainerStyles,
      children: [label && jsx("span", {
        style: getLabelStyles(),
        children: label
      }), description && jsx("span", {
        style: getDescriptionStyles(),
        children: description
      })]
    })]
  });
};

var Checkbox = function (_a) {
  var _b = _a.checked,
    checked = _b === void 0 ? false : _b,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    label = _a.label,
    description = _a.description,
    _d = _a.labelPosition,
    labelPosition = _d === void 0 ? 'right' : _d,
    onChange = _a.onChange,
    onClick = _a.onClick,
    _e = _a.className,
    className = _e === void 0 ? '' : _e,
    _f = _a.checkboxWidth,
    checkboxWidth = _f === void 0 ? '24px' : _f,
    _g = _a.titleTextStyle,
    titleTextStyle = _g === void 0 ? 'body1' : _g,
    _h = _a.descriptionTextStyle,
    descriptionTextStyle = _h === void 0 ? 'body2' : _h,
    _j = _a.titleFontWeight,
    titleFontWeight = _j === void 0 ? 'medium' : _j,
    _k = _a.descriptionFontWeight,
    descriptionFontWeight = _k === void 0 ? 'regular' : _k,
    titleColor = _a.titleColor,
    descriptionColor = _a.descriptionColor;
  var _l = useState(false),
    isHovered = _l[0],
    setIsHovered = _l[1];
  var gap = '8px';
  var getCheckboxStyles = function () {
    var baseStyles = {
      width: checkboxWidth,
      height: checkboxWidth,
      borderRadius: '4px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      transition: 'all 0.2s ease',
      position: 'relative'
    };
    if (disabled && checked) {
      // checked + disabled 상태: 내부 배경은 disabled.foreground, 아이콘은 white
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.semantic.disabled.foreground),
        backgroundColor: colors.semantic.disabled.foreground,
        cursor: 'not-allowed'
      });
    } else if (disabled) {
      // disabled이지만 checked가 아닌 상태
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.semantic.disabled.foreground),
        backgroundColor: colors.semantic.disabled.background,
        cursor: 'not-allowed'
      });
    } else if (checked && isHovered) {
      // checked + hover 상태: violet600
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.primary.tint.violet[600]),
        backgroundColor: colors.primary.tint.violet[600],
        cursor: 'pointer'
      });
    } else if (checked) {
      // checked 상태: mainviolet
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.primary.mainviolet),
        backgroundColor: colors.primary.mainviolet,
        cursor: 'pointer'
      });
    } else if (isHovered) {
      // hover 상태: coolgray 200
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.primary.coolGray[200]),
        backgroundColor: colors.semantic.background.primary,
        cursor: 'pointer'
      });
    } else {
      // 기본 상태: coolgray 100
      return __assign(__assign({}, baseStyles), {
        border: "2px solid ".concat(colors.primary.coolGray[100]),
        backgroundColor: colors.semantic.background.primary,
        cursor: 'pointer'
      });
    }
  };
  var getIconColor = useCallback(function () {
    if (disabled && checked) {
      // checked + disabled: white
      return 'white';
    } else if (disabled) {
      // disabled이지만 checked가 아닌 상태 (아이콘이 보이지 않음)
      return colors.semantic.disabled.foreground;
    } else if (checked) {
      // checked 상태: white
      return 'white';
    } else if (isHovered) {
      // hover 상태: coolgray 200
      return colors.primary.coolGray[200];
    } else {
      // 기본 상태: coolgray 100
      return colors.primary.coolGray[100];
    }
  }, [checked, disabled, isHovered]);
  var getLabelStyles = function () {
    var defaultColor = disabled ? colors.semantic.disabled.foreground : colors.primary.coolGray[800];
    return __assign(__assign({}, textStyles[titleTextStyle]), {
      fontWeight: fontWeight[titleFontWeight],
      color: titleColor || defaultColor,
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var getDescriptionStyles = function () {
    var defaultColor = disabled ? colors.semantic.disabled.foreground : colors.primary.coolGray[300];
    return __assign(__assign({}, textStyles[descriptionTextStyle]), {
      fontWeight: fontWeight[descriptionFontWeight],
      color: descriptionColor || defaultColor,
      lineHeight: '1.3',
      marginTop: '2px',
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var handleChange = function () {
    if (!disabled) {
      onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
      onClick === null || onClick === void 0 ? void 0 : onClick();
    }
  };
  var handleMouseEnter = function () {
    if (!disabled) {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    if (!disabled) {
      setIsHovered(false);
    }
  };
  var containerStyles = {
    display: 'flex',
    alignItems: description ? 'flex-start' : 'center',
    gap: gap,
    flexDirection: labelPosition === 'left' ? 'row-reverse' : 'row',
    cursor: disabled ? 'not-allowed' : 'pointer'
  };
  var labelContainerStyles = {
    display: 'flex',
    flexDirection: 'column',
    flex: 1
  };
  // 현재 상태에 따른 아이콘 색상을 미리 계산
  var iconColor = getIconColor();
  // Check icon SVG
  var CheckIcon = function () {
    return jsx("svg", {
      width: "14",
      height: "12",
      viewBox: "0 0 14 12",
      xmlns: "http://www.w3.org/2000/svg",
      children: jsx("path", {
        fill: iconColor,
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M13.3821 0.997823C13.7285 1.30089 13.7636 1.82736 13.4605 2.17372L5.80428 10.9237C5.64699 11.1035 5.42012 11.2071 5.18127 11.2083C4.94241 11.2095 4.71453 11.1081 4.55546 10.9299L0.545044 6.43733C0.238554 6.09399 0.268427 5.56719 0.611766 5.2607C0.955106 4.95421 1.4819 4.98409 1.78839 5.32743L5.17089 9.11661L12.2062 1.07622C12.5093 0.729853 13.0358 0.694755 13.3821 0.997823Z"
      })
    });
  };
  return jsxs("div", {
    className: "youth-checkbox ".concat(className),
    style: containerStyles,
    onClick: handleChange,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    children: [jsx("input", {
      type: "checkbox",
      checked: checked,
      disabled: disabled,
      onChange: function () {},
      style: {
        display: 'none'
      }
    }), jsx("div", {
      style: getCheckboxStyles(),
      children: jsx(CheckIcon, {})
    }), (label || description) && jsxs("div", {
      style: labelContainerStyles,
      children: [label && jsx("span", {
        style: getLabelStyles(),
        children: label
      }), description && jsx("span", {
        style: getDescriptionStyles(),
        children: description
      })]
    })]
  });
};

var Toggle = function (_a) {
  var _b = _a.checked,
    checked = _b === void 0 ? false : _b,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    label = _a.label,
    description = _a.description,
    _d = _a.labelPosition,
    labelPosition = _d === void 0 ? 'right' : _d,
    _e = _a.size,
    size = _e === void 0 ? 'medium' : _e,
    onChange = _a.onChange,
    onClick = _a.onClick,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(false),
    isHovered = _g[0],
    setIsHovered = _g[1];
  var getSizeConfig = function () {
    switch (size) {
      case 'small':
        return __assign(__assign({}, textStyles.body2), {
          fontWeight: fontWeight.medium,
          toggleWidth: '32px',
          toggleHeight: '18px',
          thumbSize: '14px',
          thumbOffset: '2px',
          gap: '6px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body3), {
            fontWeight: fontWeight.regular
          })
        });
      case 'large':
        return __assign(__assign({}, textStyles.heading3), {
          fontWeight: fontWeight.medium,
          toggleWidth: '52px',
          toggleHeight: '28px',
          thumbSize: '24px',
          thumbOffset: '2px',
          gap: '10px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body2), {
            fontWeight: fontWeight.regular
          })
        });
      default:
        // medium
        return __assign(__assign({}, textStyles.body1), {
          fontWeight: fontWeight.medium,
          toggleWidth: '48px',
          toggleHeight: '24px',
          thumbSize: '20px',
          thumbOffset: '2px',
          gap: '8px',
          descriptionFontStyle: __assign(__assign({}, textStyles.body2), {
            fontWeight: fontWeight.regular
          })
        });
    }
  };
  var sizeConfig = getSizeConfig();
  var getToggleStyles = function () {
    if (disabled) {
      return {
        width: sizeConfig.toggleWidth,
        height: sizeConfig.toggleHeight,
        borderRadius: sizeConfig.toggleHeight,
        backgroundColor: colors.primary.coolGray[50],
        cursor: 'not-allowed',
        transition: 'all 0.3s ease',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        padding: sizeConfig.thumbOffset
      };
    } else if (isHovered) {
      return {
        width: sizeConfig.toggleWidth,
        height: sizeConfig.toggleHeight,
        borderRadius: sizeConfig.toggleHeight,
        backgroundColor: !checked ? colors.primary.coolGray[200] : colors.primary.tint.green[600],
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        padding: sizeConfig.thumbOffset
      };
    } else if (checked) {
      return {
        width: sizeConfig.toggleWidth,
        height: sizeConfig.toggleHeight,
        borderRadius: sizeConfig.toggleHeight,
        backgroundColor: colors.primary.tint.green[500],
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        padding: sizeConfig.thumbOffset
      };
    } else {
      return {
        width: sizeConfig.toggleWidth,
        height: sizeConfig.toggleHeight,
        borderRadius: sizeConfig.toggleHeight,
        backgroundColor: colors.primary.coolGray[100],
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        padding: sizeConfig.thumbOffset
      };
    }
  };
  var getThumbStyles = function () {
    var thumbPosition = checked ? "calc(".concat(sizeConfig.toggleWidth, " - ").concat(sizeConfig.thumbSize, " - ").concat(parseInt(sizeConfig.thumbOffset) * 2, "px)") : '0px';
    return {
      width: sizeConfig.thumbSize,
      height: sizeConfig.thumbSize,
      borderRadius: '50%',
      backgroundColor: 'white',
      boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.1)',
      transition: 'all 0.3s ease',
      transform: "translateX(".concat(thumbPosition, ")"),
      position: 'absolute'
    };
  };
  var getLabelStyles = function () {
    return __assign(__assign({}, sizeConfig), {
      color: disabled ? colors.semantic.text.disabled : colors.primary.coolGray[800],
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var getDescriptionStyles = function () {
    return __assign(__assign({}, sizeConfig.descriptionFontStyle), {
      color: disabled ? colors.semantic.text.disabled : colors.primary.coolGray[300],
      lineHeight: '1.3',
      marginTop: '2px',
      cursor: disabled ? 'not-allowed' : 'pointer'
    });
  };
  var handleChange = function () {
    if (!disabled) {
      onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
      onClick === null || onClick === void 0 ? void 0 : onClick();
    }
  };
  var handleMouseEnter = function () {
    if (!disabled) {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    if (!disabled) {
      setIsHovered(false);
    }
  };
  var containerStyles = {
    display: 'flex',
    alignItems: !description ? 'center' : 'flex-start',
    gap: sizeConfig.gap,
    flexDirection: labelPosition === 'left' ? 'row-reverse' : 'row',
    cursor: disabled ? 'not-allowed' : 'pointer'
  };
  var labelContainerStyles = {
    display: 'flex',
    flexDirection: 'column',
    flex: 1
  };
  return jsxs("div", {
    className: "youth-toggle ".concat(className),
    style: containerStyles,
    onClick: handleChange,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    children: [jsx("input", {
      type: "checkbox",
      checked: checked,
      disabled: disabled,
      onChange: function () {},
      style: {
        display: 'none'
      }
    }), jsx("div", {
      style: getToggleStyles(),
      children: jsx("div", {
        style: getThumbStyles()
      })
    }), (label || description) && jsxs("div", {
      style: labelContainerStyles,
      children: [label && jsx("span", {
        style: getLabelStyles(),
        children: label
      }), description && jsx("span", {
        style: getDescriptionStyles(),
        children: description
      })]
    })]
  });
};

// 아이콘 컴포넌트들
var CheckCircleIcon = function (_a) {
  var color = _a.color;
  return jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: [jsx("circle", {
      cx: "12",
      cy: "12",
      r: "11",
      fill: color
    }), jsx("path", {
      d: "M8.5 12L10.5 14L15.5 9",
      stroke: "white",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  });
};
var CloseCircleIcon = function (_a) {
  var color = _a.color;
  return jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: [jsx("circle", {
      cx: "12",
      cy: "12",
      r: "11",
      fill: color
    }), jsx("path", {
      d: "M8 8L16 16M16 8L8 16",
      stroke: "white",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  });
};
var CautionIcon = function (_a) {
  var color = _a.color;
  return jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: [jsx("circle", {
      cx: "12",
      cy: "12",
      r: "11",
      fill: color
    }), jsx("rect", {
      x: "11",
      y: "7",
      width: "2",
      height: "6",
      fill: "white",
      rx: "1"
    }), jsx("circle", {
      cx: "12",
      cy: "16",
      r: "1",
      fill: "white"
    })]
  });
};
var InfoIcon = function (_a) {
  var color = _a.color;
  return jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: [jsx("circle", {
      cx: "12",
      cy: "12",
      r: "11",
      fill: color
    }), jsx("circle", {
      cx: "12",
      cy: "8",
      r: "1",
      fill: "white"
    }), jsx("rect", {
      x: "11",
      y: "11",
      width: "2",
      height: "6",
      fill: "white",
      rx: "1"
    })]
  });
};
// 상태별 설정
var statusConfig = {
  success: {
    icon: CheckCircleIcon,
    color: colors.semantic.state.success
  },
  error: {
    icon: CloseCircleIcon,
    color: colors.semantic.state.error
  },
  warning: {
    icon: CautionIcon,
    color: colors.semantic.state.warning
  },
  info: {
    icon: InfoIcon,
    color: colors.semantic.state.info
  }
};
/**
 * 토스트 오버레이 컴포넌트
 *
 * 사용자가 어떤 작업을 완료했을 때, 시스템이 잘 처리됐다는 걸 알려주는 알림입니다.
 * 현재 하고 있는 일을 방해하지 않고, 잠깐 나타났다 사라지는 방식으로 보여집니다.
 */
var Toast = React.memo(function (_a) {
  var status = _a.status,
    title = _a.title,
    description = _a.description,
    _b = _a.showLeadingIcon,
    showLeadingIcon = _b === void 0 ? true : _b,
    _c = _a.showCloseButton,
    showCloseButton = _c === void 0 ? false : _c,
    onClose = _a.onClose,
    _d = _a.className,
    className = _d === void 0 ? '' : _d;
  var config = statusConfig[status];
  var IconComponent = config.icon;
  var handleCloseClick = useCallback(function () {
    onClose === null || onClose === void 0 ? void 0 : onClose();
  }, [onClose]);
  var toastStyle = {
    display: 'flex',
    alignItems: 'center',
    gap: spacing.m,
    padding: spacing.l,
    backgroundColor: colors.semantic.background.primary,
    borderRadius: radius.l,
    boxShadow: shadows.s,
    width: '360px',
    minHeight: 'fit-content'
  };
  var contentStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: spacing.xxs,
    flex: 1
  };
  var titleStyle = __assign(__assign({}, textStyles.heading3), {
    color: colors.semantic.text.primary,
    margin: 0
  });
  var descriptionStyle = __assign(__assign({}, textStyles.body2), {
    color: colors.semantic.text.secondary,
    margin: 0
  });
  var closeButtonStyle = {
    background: 'none',
    border: 'none',
    cursor: 'pointer',
    padding: spacing.xxs,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: radius.xs,
    transition: 'background-color 0.2s ease'
  };
  var handleMouseEnter = useCallback(function (e) {
    e.target.style.backgroundColor = colors.primary.coolGray[100];
  }, []);
  var handleMouseLeave = useCallback(function (e) {
    e.target.style.backgroundColor = 'transparent';
  }, []);
  return jsxs("div", {
    className: "toast toast--".concat(status, " ").concat(className),
    style: toastStyle,
    role: "alert",
    "aria-live": "polite",
    children: [showLeadingIcon && jsx("div", {
      className: "toast__icon",
      children: jsx(IconComponent, {
        color: config.color
      })
    }), jsxs("div", {
      className: "toast__content",
      style: contentStyle,
      children: [jsx("h3", {
        className: "toast__title",
        style: titleStyle,
        children: title
      }), description && jsx("p", {
        className: "toast__description",
        style: descriptionStyle,
        children: description
      })]
    }), showCloseButton && onClose && jsx("button", {
      className: "toast__close",
      style: closeButtonStyle,
      onClick: handleCloseClick,
      "aria-label": "\uC54C\uB9BC \uB2EB\uAE30",
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: jsx(Icon, {
        type: "close",
        size: 16,
        color: colors.semantic.text.tertiary
      })
    })]
  });
}, function (prevProps, nextProps) {
  // 커스텀 비교 함수: onClose를 제외한 나머지 props만 비교
  return prevProps.status === nextProps.status && prevProps.title === nextProps.title && prevProps.description === nextProps.description && prevProps.showLeadingIcon === nextProps.showLeadingIcon && prevProps.showCloseButton === nextProps.showCloseButton && prevProps.className === nextProps.className;
});
// displayName 추가 (React Dev Tools에서 식별하기 쉽게)
Toast.displayName = 'Toast';

/**
 * Toast Provider 컴포넌트
 *
 * react-hot-toast를 래핑하여 기존 Toast 컴포넌트와 함께 사용할 수 있는 Provider입니다.
 */
var ToastProvider = function (_a) {
  var children = _a.children,
    _b = _a.position,
    position = _b === void 0 ? 'top-right' : _b,
    _c = _a.defaultDuration,
    defaultDuration = _c === void 0 ? 4000 : _c;
  return jsxs(Fragment, {
    children: [children, jsx(Toaster, {
      position: position,
      toastOptions: {
        duration: defaultDuration,
        style: {
          background: 'transparent',
          boxShadow: 'none',
          padding: 0,
          margin: 0
        }
      }
    })]
  });
};
/**
 * useToast 훅
 *
 * react-hot-toast를 래핑하여 기존 API 호환성을 유지하면서 Toast를 사용할 수 있는 훅입니다.
 */
var useToast = function () {
  // dismiss 함수를 미리 참조로 저장하여 재생성 방지
  var dismissToast = useCallback(function (id) {
    return toast.dismiss(id);
  }, []);
  var success = useCallback(function (title, description, options) {
    return toast.custom(function (t) {
      var _a;
      return jsx(Toast, __assign({
        status: "success",
        title: title,
        description: description,
        showLeadingIcon: (_a = options === null || options === void 0 ? void 0 : options.showLeadingIcon) !== null && _a !== void 0 ? _a : true,
        showCloseButton: true,
        onClose: function () {
          return dismissToast(t.id);
        }
      }, options), t.id);
    }, {
      duration: (options === null || options === void 0 ? void 0 : options.duration) || 4000,
      id: options === null || options === void 0 ? void 0 : options.id
    });
  }, [dismissToast]);
  var error = useCallback(function (title, description, options) {
    return toast.custom(function (t) {
      var _a;
      return jsx(Toast, __assign({
        status: "error",
        title: title,
        description: description,
        showLeadingIcon: (_a = options === null || options === void 0 ? void 0 : options.showLeadingIcon) !== null && _a !== void 0 ? _a : true,
        showCloseButton: true,
        onClose: function () {
          return dismissToast(t.id);
        }
      }, options), t.id);
    }, {
      duration: (options === null || options === void 0 ? void 0 : options.duration) || 4000,
      id: options === null || options === void 0 ? void 0 : options.id
    });
  }, [dismissToast]);
  var warning = useCallback(function (title, description, options) {
    return toast.custom(function (t) {
      var _a;
      return jsx(Toast, __assign({
        status: "warning",
        title: title,
        description: description,
        showLeadingIcon: (_a = options === null || options === void 0 ? void 0 : options.showLeadingIcon) !== null && _a !== void 0 ? _a : true,
        showCloseButton: true,
        onClose: function () {
          return dismissToast(t.id);
        }
      }, options), t.id);
    }, {
      duration: (options === null || options === void 0 ? void 0 : options.duration) || 4000,
      id: options === null || options === void 0 ? void 0 : options.id
    });
  }, [dismissToast]);
  var info = useCallback(function (title, description, options) {
    return toast.custom(function (t) {
      var _a;
      return jsx(Toast, __assign({
        status: "info",
        title: title,
        description: description,
        showLeadingIcon: (_a = options === null || options === void 0 ? void 0 : options.showLeadingIcon) !== null && _a !== void 0 ? _a : true,
        showCloseButton: true,
        onClose: function () {
          return dismissToast(t.id);
        }
      }, options), t.id);
    }, {
      duration: (options === null || options === void 0 ? void 0 : options.duration) || 4000,
      id: options === null || options === void 0 ? void 0 : options.id
    });
  }, [dismissToast]);
  var custom = useCallback(function (options) {
    return toast.custom(function (t) {
      return jsx(Toast, __assign({
        showLeadingIcon: true,
        showCloseButton: true,
        onClose: function () {
          return dismissToast(t.id);
        }
      }, options), t.id);
    }, {
      duration: options.duration || 4000
    });
  }, [dismissToast]);
  var remove = useCallback(function (id) {
    return dismissToast(id);
  }, [dismissToast]);
  var removeAll = useCallback(function () {
    return toast.dismiss();
  }, []);
  return {
    success: success,
    error: error,
    warning: warning,
    info: info,
    custom: custom,
    remove: remove,
    removeAll: removeAll
  };
};

var Popup = function (_a) {
  var title = _a.title,
    description = _a.description,
    primaryButton = _a.primaryButton,
    secondaryButton = _a.secondaryButton,
    isOpen = _a.isOpen,
    onClose = _a.onClose,
    _b = _a.className,
    className = _b === void 0 ? '' : _b,
    _c = _a.width,
    width = _c === void 0 ? '480px' : _c,
    _d = _a.style,
    style = _d === void 0 ? {} : _d;
  if (!isOpen) return null;
  var overlayStyle = __assign({
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: colors.semantic.dim.overlay,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 1000
  }, style);
  var popupStyle = {
    backgroundColor: colors.semantic.background.primary,
    borderRadius: '16px',
    padding: '32px',
    minWidth: '480px',
    width: typeof width === 'number' ? "".concat(width, "px") : width,
    maxHeight: '90vh',
    boxShadow: shadows.s,
    display: 'flex',
    flexDirection: 'column',
    gap: '24px'
  };
  var contentStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: '16px'
  };
  var titleStyle = __assign(__assign({}, textStyles.heading1), {
    color: colors.semantic.text.primary,
    margin: 0
  });
  var descriptionStyle = __assign(__assign({}, textStyles.body1), {
    color: colors.semantic.text.secondary,
    margin: 0,
    whiteSpace: 'pre-wrap'
  });
  var buttonContainerStyle = {
    display: 'flex',
    gap: '12px',
    flexDirection: secondaryButton ? 'row' : 'column'
  };
  var handleOverlayClick = function (e) {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };
  return jsx("div", {
    className: "popup-overlay ".concat(className),
    style: overlayStyle,
    onClick: handleOverlayClick,
    children: jsxs("div", {
      className: "popup",
      style: popupStyle,
      children: [jsxs("div", {
        className: "popup-content",
        style: contentStyle,
        children: [jsx("h1", {
          style: titleStyle,
          children: title
        }), description && jsx("p", {
          style: descriptionStyle,
          children: description
        })]
      }), jsxs("div", {
        className: "popup-buttons",
        style: buttonContainerStyle,
        children: [secondaryButton && jsx(Button, __assign({
          type: "outlined",
          size: "l",
          width: "fill",
          onClick: secondaryButton.onClick
        }, function (_a) {
          _a.text;
            _a.onClick;
            var rest = __rest(_a, ["text", "onClick"]);
          return rest;
        }(secondaryButton), {
          children: secondaryButton.text
        })), jsx(Button, __assign({
          type: "solid",
          size: "l",
          width: "fill",
          onClick: primaryButton.onClick
        }, function (_a) {
          _a.text;
            _a.onClick;
            var rest = __rest(_a, ["text", "onClick"]);
          return rest;
        }(primaryButton), {
          children: primaryButton.text
        }))]
      })]
    })
  });
};

var Modal = function (_a) {
  var title = _a.title,
    description = _a.description,
    children = _a.children,
    _b = _a.contentMaxHeight,
    contentMaxHeight = _b === void 0 ? 500 : _b,
    _c = _a.showScrollbar,
    showScrollbar = _c === void 0 ? false : _c,
    _d = _a.showCloseButton,
    showCloseButton = _d === void 0 ? true : _d,
    width = _a.width,
    primaryButton = _a.primaryButton,
    primaryDefaultDisabledButton = _a.primaryDefaultDisabledButton,
    secondaryButton = _a.secondaryButton,
    isOpen = _a.isOpen,
    onClose = _a.onClose,
    _e = _a.className,
    className = _e === void 0 ? '' : _e,
    _f = _a.style,
    style = _f === void 0 ? {} : _f,
    _g = _a.overlayStyle,
    overlayStyle = _g === void 0 ? {} : _g;
  var _h = React.useState(false),
    isContentOverflowing = _h[0],
    setIsContentOverflowing = _h[1];
  var _j = React.useState(true),
    isPrimaryDefaultDisabled = _j[0],
    setIsPrimaryDefaultDisabled = _j[1];
  var contentRef = React.useRef(null);
  useEffect(function () {
    if (children && contentRef.current) {
      var _a = contentRef.current,
        scrollHeight = _a.scrollHeight,
        clientHeight = _a.clientHeight;
      setIsContentOverflowing(scrollHeight > clientHeight);
    }
  }, [children, contentMaxHeight]);
  useEffect(function () {
    if (!primaryDefaultDisabledButton) {
      return;
    }
    if (primaryDefaultDisabledButton.disabled !== undefined) {
      setIsPrimaryDefaultDisabled(primaryDefaultDisabledButton.disabled);
    }
  }, [primaryDefaultDisabledButton === null || primaryDefaultDisabledButton === void 0 ? void 0 : primaryDefaultDisabledButton.disabled]);
  if (!isOpen) return null;
  var overlayStyleConfig = __assign({
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: colors.semantic.dim.overlay,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 9999
  }, overlayStyle);
  var modalStyle = __assign({
    backgroundColor: colors.semantic.background.primary,
    borderRadius: '16px',
    padding: '32px',
    minWidth: typeof width === 'number' ? "".concat(width, "px") : width || '480px',
    width: typeof width === 'number' ? "".concat(width, "px") : width,
    maxWidth: 'calc(100vw - 40px)',
    maxHeight: 'calc(100vh - 40px)',
    boxShadow: shadows.m,
    display: 'flex',
    flexDirection: 'column',
    gap: isContentOverflowing ? '0px' : secondaryButton ? '20px' : '24px'
  }, style);
  var headerStyle = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    gap: '20px',
    flexShrink: 0
  };
  var titleStyle = __assign(__assign({}, textStyles.heading1), {
    color: colors.semantic.text.primary,
    margin: 0,
    flex: 1
  });
  var closeButtonStyle = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '24px',
    height: '24px',
    cursor: 'pointer',
    flexShrink: 0
  };
  var contentStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: '16px',
    flex: 1,
    minHeight: 0
  };
  var descriptionStyle = __assign(__assign({}, textStyles.body1), {
    color: colors.semantic.text.secondary,
    margin: 0
  });
  ({
    width: '100%',
    height: '240px',
    borderRadius: '8px',
    backgroundColor: colors.primary.coolGray[100],
    objectFit: 'cover'
  });
  var imageContainerStyle = {
    width: '100%',
    // borderRadius: '8px',
    overflow: 'hidden',
    maxHeight: "".concat(contentMaxHeight, "px"),
    overflowY: 'auto',
    scrollbarWidth: showScrollbar ? 'thin' : 'none',
    msOverflowStyle: showScrollbar ? 'auto' : 'none'
  };
  var buttonContainerStyle = __assign({
    display: 'flex',
    gap: '12px',
    flexDirection: secondaryButton ? 'row' : 'column',
    flexShrink: 0
  }, isContentOverflowing && {
    borderTop: "1px solid ".concat(colors.semantic.border.default),
    paddingTop: '20px',
    marginLeft: '-32px',
    marginRight: '-32px',
    paddingLeft: '32px',
    paddingRight: '32px'
  });
  var handleOverlayClick = function (e) {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };
  var handleCloseClick = function () {
    onClose();
  };
  return jsx("div", {
    className: "modal-overlay ".concat(className),
    style: overlayStyleConfig,
    onClick: handleOverlayClick,
    children: jsxs("div", {
      className: "modal",
      style: modalStyle,
      children: [jsxs("div", {
        className: "modal-content",
        style: contentStyle,
        children: [jsxs("div", {
          className: "modal-header",
          style: headerStyle,
          children: [jsx("h1", {
            style: titleStyle,
            children: title
          }), showCloseButton && jsx("div", {
            style: closeButtonStyle,
            onClick: handleCloseClick,
            children: jsx(Icon, {
              type: "close",
              size: 24,
              color: colors.semantic.text.secondary
            })
          })]
        }), description && jsx("p", {
          style: descriptionStyle,
          children: description
        }), children && jsx("div", {
          ref: contentRef,
          style: imageContainerStyle,
          className: showScrollbar ? '' : 'modal-content-scrollable',
          children: children
        })]
      }), jsxs("div", {
        className: "modal-buttons",
        style: buttonContainerStyle,
        children: [secondaryButton && jsx(Button, __assign({
          type: "outlined",
          size: "l",
          width: "fill",
          onClick: secondaryButton.onClick
        }, function (_a) {
          _a.text;
            _a.onClick;
            _a.disabled;
            var rest = __rest(_a, ["text", "onClick", "disabled"]);
          return rest;
        }(secondaryButton), {
          children: secondaryButton.text
        })), primaryDefaultDisabledButton && jsx(Button, __assign({
          type: "solid",
          size: "l",
          width: "fill",
          disabled: isPrimaryDefaultDisabled,
          onClick: primaryDefaultDisabledButton.onClick
        }, function (_a) {
          _a.text;
            _a.onClick;
            _a.disabled;
            var rest = __rest(_a, ["text", "onClick", "disabled"]);
          return rest;
        }(primaryDefaultDisabledButton), {
          children: primaryDefaultDisabledButton.text
        })), primaryButton && jsx(Button, __assign({
          type: "solid",
          size: "l",
          width: "fill",
          disabled: primaryButton.disabled,
          onClick: primaryButton.onClick
        }, function (_a) {
          _a.text;
            _a.onClick;
            _a.disabled;
            var rest = __rest(_a, ["text", "onClick", "disabled"]);
          return rest;
        }(primaryButton), {
          children: primaryButton.text
        }))]
      })]
    })
  });
};

var Dropdown = function (_a) {
  var _b = _a.placeholder,
    placeholder = _b === void 0 ? 'Placeholder' : _b,
    value = _a.value,
    _c = _a.options,
    options = _c === void 0 ? [] : _c,
    onChange = _a.onChange,
    _d = _a.disabled,
    disabled = _d === void 0 ? false : _d,
    _e = _a.error,
    error = _e === void 0 ? false : _e,
    errorMessage = _a.errorMessage,
    _f = _a.className,
    className = _f === void 0 ? '' : _f,
    leadingIconType = _a.leadingIconType,
    _g = _a.size,
    size = _g === void 0 ? 'l' : _g,
    width = _a.width,
    _h = _a.enableSearch,
    enableSearch = _h === void 0 ? false : _h,
    _j = _a.hideOption,
    hideOption = _j === void 0 ? false : _j;
  var _k = useState(false),
    isOpen = _k[0],
    setIsOpen = _k[1];
  var _l = useState(false),
    isAnimating = _l[0],
    setIsAnimating = _l[1];
  var _m = useState(false),
    shouldRender = _m[0],
    setShouldRender = _m[1];
  var _o = useState(null),
    hoveredOptionIndex = _o[0],
    setHoveredOptionIndex = _o[1];
  var _p = useState(''),
    searchText = _p[0],
    setSearchText = _p[1];
  var dropdownRef = useRef(null);
  var optionsContainerRef = useRef(null);
  var inputRef = useRef(null);
  var selectedOption = useMemo(function () {
    return options.find(function (option) {
      return option.value === value;
    });
  }, [options, value]);
  var hasSelectedOption = !!selectedOption;
  // size에 따른 기본 width 계산, width prop이 있으면 우선 적용
  var finalWidth = useMemo(function () {
    if (width) {
      return width;
    }
    return '335px';
  }, [width, size]);
  // 검색 텍스트에 따른 옵션 필터링
  var filteredOptions = useMemo(function () {
    if (!enableSearch || !searchText.trim()) {
      return options;
    }
    return options.filter(function (option) {
      return option.label.toLowerCase().includes(searchText.toLowerCase());
    });
  }, [options, searchText, enableSearch]);
  // 선택된 옵션의 인덱스를 찾기 위한 함수
  var getSelectedOptionIndex = useCallback(function () {
    if (!hasSelectedOption) return -1;
    return filteredOptions.findIndex(function (option) {
      return option.value === value;
    });
  }, [filteredOptions, value, hasSelectedOption]);
  // 선택된 옵션으로 스크롤 이동
  var scrollToSelectedOption = useCallback(function () {
    if (!hasSelectedOption) return;
    // 스크롤 실행 함수
    var performScroll = function () {
      if (!optionsContainerRef.current) return false;
      var selectedIndex = getSelectedOptionIndex();
      if (selectedIndex === -1) return false;
      var container = optionsContainerRef.current;
      var optionElements = container.children;
      var selectedElement = optionElements[selectedIndex];
      if (selectedElement && container.clientHeight > 0) {
        var containerHeight = container.clientHeight;
        var optionHeight = selectedElement.offsetHeight;
        var optionTop = selectedElement.offsetTop;
        // 선택된 옵션이 중앙에 오도록 스크롤 위치 계산
        var scrollTop = optionTop - containerHeight / 2 + optionHeight / 2;
        container.scrollTop = Math.max(0, scrollTop);
        return true;
      }
      return false;
    };
    // 즉시 실행 시도
    if (performScroll()) return;
    // 재시도 로직 (최대 3번)
    var retryCount = 0;
    var maxRetries = 3;
    var retryScroll = function () {
      if (retryCount >= maxRetries) return;
      if (performScroll()) return;
      retryCount++;
      setTimeout(retryScroll, 10); // 10ms씩 지연하여 재시도
    };
    setTimeout(retryScroll, 0);
  }, [hasSelectedOption, getSelectedOptionIndex]);
  // 드롭다운 열기/닫기 애니메이션 관리
  useEffect(function () {
    if (isOpen) {
      // 열기: 먼저 DOM에 마운트하고 애니메이션 시작
      setShouldRender(true);
      // hover 상태 초기화
      setHoveredOptionIndex(null);
      // 첫 번째 requestAnimationFrame으로 DOM 렌더링 대기
      requestAnimationFrame(function () {
        // 두 번째 requestAnimationFrame으로 스크롤 설정 후 애니메이션 시작
        requestAnimationFrame(function () {
          // 스크롤 위치를 애니메이션 시작 직전에 설정
          scrollToSelectedOption();
          setIsAnimating(true);
          // 드롭다운이 열리고 검색이 활성화된 경우 input에 포커스
          if (enableSearch && inputRef.current) {
            inputRef.current.focus();
          }
        });
      });
    } else {
      // 닫기: 애니메이션 시작하고 완료 후 DOM에서 제거
      setIsAnimating(false);
      // hover 상태 초기화
      setHoveredOptionIndex(null);
      // 검색 텍스트 초기화 (검색이 활성화된 경우에만)
      if (enableSearch) {
        setSearchText('');
      }
      var timer_1 = setTimeout(function () {
        setShouldRender(false);
      }, 200); // 애니메이션 duration과 맞춤
      return function () {
        return clearTimeout(timer_1);
      };
    }
  }, [isOpen, enableSearch, scrollToSelectedOption]);
  // 외부 클릭 시 드롭다운 닫기
  useEffect(function () {
    var handleClickOutside = function (event) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return function () {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);
  // ESC 키로 드롭다운 닫기
  useEffect(function () {
    var handleKeyDown = function (event) {
      if (event.key === 'Escape' && isOpen) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
    }
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen]);
  // 텍스트 스타일 계산 (size에 따라 body1/body2 + medium)
  var getTextStyle = useCallback(function () {
    var baseStyle = size === 'l' ? typography.textStyles.body1 : typography.textStyles.body2;
    return __assign(__assign({}, baseStyle), {
      fontWeight: typography.fontWeight.medium
    });
  }, [size]);
  // 컨테이너 스타일
  var getContainerStyles = useCallback(function () {
    var borderColor = colors.semantic.border.strong; // #D6D6D6
    var backgroundColor = colors.semantic.background.primary; // #FFFFFF
    if (disabled) {
      borderColor = colors.semantic.border.strong;
      backgroundColor = colors.semantic.disabled.background; // #F3F5F6
    } else if (error) {
      borderColor = colors.semantic.state.error; // #FF2E2E
    } else if (isOpen) {
      borderColor = colors.semantic.text.primary; // #25282D
    }
    // size에 따른 패딩 설정
    var padding = size === 'l' ? '12px 16px' : '9px 16px';
    return __assign({
      display: 'flex',
      alignItems: 'center',
      gap: spacing.xs,
      // 8px
      padding: padding,
      backgroundColor: backgroundColor,
      border: "1px solid ".concat(borderColor),
      borderRadius: '8px',
      transition: 'all 0.2s ease',
      cursor: disabled ? 'not-allowed' : 'pointer',
      width: finalWidth === 'fill' ? '100%' : finalWidth,
      boxSizing: 'border-box',
      userSelect: !enableSearch ? 'none' : 'auto'
    }, hideOption && {
      userSelect: 'none'
    });
  }, [disabled, error, isOpen, finalWidth, hideOption, enableSearch, size]);
  var getTextStyles = useCallback(function () {
    var textColor;
    if (disabled) {
      textColor = colors.semantic.disabled.foreground; // #D1D5DB
    } else if (error) {
      textColor = colors.semantic.state.error; // #FF2E2E
    } else if (hasSelectedOption) {
      textColor = colors.semantic.text.primary; // #25282D
    } else {
      textColor = '#AFB6C0'; // Figma 스펙의 placeholder 색상
    }
    var textStyle = getTextStyle();
    return __assign(__assign({}, textStyle), {
      flex: 1,
      color: textColor,
      userSelect: !enableSearch || hideOption ? 'none' : 'auto'
    });
  }, [disabled, error, hasSelectedOption, enableSearch, hideOption, getTextStyle]);
  var getInputStyles = useCallback(function () {
    var textStyle = getTextStyle();
    return __assign(__assign({}, textStyle), {
      flex: 1,
      color: colors.semantic.text.primary,
      backgroundColor: 'transparent',
      border: 'none',
      outline: 'none',
      width: '100%'
    });
  }, [getTextStyle]);
  var getIconColor = useCallback(function () {
    if (disabled) {
      return colors.semantic.disabled.foreground; // #D1D5DB
    } else if (error) {
      return colors.semantic.state.error; // #FF2E2E
    } else {
      return colors.semantic.text.primary; // #25282D
    }
  }, [disabled, error]);
  var getChevronIcon = useCallback(function () {
    return jsx(Icon, {
      type: isOpen ? 'chevron-up' : 'chevron-down',
      size: 20,
      color: "currentColor"
    });
  }, [isOpen]);
  var handleClick = useCallback(function () {
    if (!disabled && !hideOption) {
      setIsOpen(!isOpen);
    }
  }, [disabled, hideOption, isOpen]);
  var handleOptionClick = useCallback(function (optionValue) {
    if (!disabled) {
      onChange === null || onChange === void 0 ? void 0 : onChange(optionValue);
      setIsOpen(false);
    }
  }, [disabled, onChange]);
  var handleKeyDown = useCallback(function (event) {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      if (!hideOption) {
        handleClick();
      }
    }
  }, [handleClick, hideOption]);
  var handleInputKeyDown = useCallback(function (event) {
    if (!enableSearch) return;
    if (event.key === 'Enter') {
      event.preventDefault();
      // 첫 번째 필터링된 옵션 선택
      if (filteredOptions.length > 0 && !filteredOptions[0].disabled) {
        handleOptionClick(filteredOptions[0].value);
      }
    } else if (event.key === 'ArrowDown') {
      event.preventDefault();
      // 첫 번째 옵션에 호버 효과
      if (filteredOptions.length > 0) {
        setHoveredOptionIndex(0);
      }
    } else if (event.key === 'Escape') {
      event.preventDefault();
      setIsOpen(false);
    }
  }, [enableSearch, filteredOptions, handleOptionClick]);
  var handleInputChange = useCallback(function (event) {
    if (!enableSearch) return;
    setSearchText(event.target.value);
    setHoveredOptionIndex(null);
  }, [enableSearch]);
  var getOptionStyles = useCallback(function (option, index, isSelected) {
    var backgroundColor = colors.semantic.background.primary; // #FFFFFF
    var textColor = colors.semantic.text.primary; // #25282D
    if (option.disabled) {
      textColor = colors.semantic.disabled.foreground; // #D1D5DB
    } else if (isSelected) {
      backgroundColor = '#F8F4FE'; // Figma 스펙의 선택된 옵션 배경색
      textColor = '#7248D9'; // Figma 스펙의 선택된 옵션 텍스트 색상
    } else if (hoveredOptionIndex === index) {
      backgroundColor = colors.semantic.disabled.background; // #F3F5F6
    }
    var textStyle = getTextStyle();
    return __assign(__assign({
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: '13px 16px'
    }, textStyle), {
      color: textColor,
      backgroundColor: backgroundColor,
      cursor: option.disabled ? 'not-allowed' : 'pointer',
      transition: 'background-color 0.2s ease'
    });
  }, [hoveredOptionIndex, getTextStyle]);
  var dropdownOptionsStyle = useMemo(function () {
    return {
      position: 'absolute',
      top: '100%',
      left: 0,
      right: 0,
      backgroundColor: colors.semantic.background.primary,
      border: "1px solid ".concat(colors.semantic.border.strong),
      borderRadius: '8px',
      boxShadow: '0px 1px 6px 0px rgba(0, 0, 0, 0.06)',
      zIndex: 1000,
      marginTop: '8px',
      maxHeight: '200px',
      overflowY: 'auto',
      // 애니메이션 스타일
      opacity: isAnimating ? 1 : 0,
      transform: isAnimating ? 'translateY(0) scaleY(1)' : 'translateY(-8px) scaleY(0.95)',
      transformOrigin: 'top center',
      transition: 'all 0.2s cubic-bezier(0.16, 1, 0.3, 1)',
      userSelect: !enableSearch ? 'none' : 'auto'
    };
  }, [isAnimating, enableSearch]);
  var getCheckIcon = function () {
    return jsx(Icon, {
      type: "check",
      size: 20,
      color: "currentColor"
    });
  };
  var getLockIcon = function () {
    return jsx(Icon, {
      type: "lock",
      size: 20,
      color: "currentColor"
    });
  };
  // 표시할 텍스트 결정
  var getDisplayText = function () {
    if (isOpen && enableSearch) {
      return searchText;
    }
    return hasSelectedOption ? selectedOption.label : placeholder;
  };
  // 플레이스홀더 텍스트 결정
  var getPlaceholderText = function () {
    if (isOpen && enableSearch) {
      return hasSelectedOption ? selectedOption.label : placeholder;
    }
    return '';
  };
  // Leading 아이콘 렌더링
  var renderLeadingIcon = function () {
    if (!leadingIconType) return null;
    return jsx(Icon, {
      type: leadingIconType,
      size: 20,
      color: getIconColor()
    });
  };
  return jsxs("div", {
    className: "dropdown-wrapper ".concat(className),
    ref: dropdownRef,
    style: {
      position: 'relative',
      width: finalWidth === 'fill' ? '100%' : finalWidth
    },
    children: [jsxs("div", {
      style: getContainerStyles(),
      onClick: !isOpen || !enableSearch ? handleClick : undefined,
      onKeyDown: !isOpen || !enableSearch ? handleKeyDown : undefined,
      tabIndex: disabled || isOpen && enableSearch ? -1 : 0,
      role: "combobox",
      "aria-expanded": isOpen,
      "aria-haspopup": "listbox",
      "aria-disabled": disabled,
      children: [renderLeadingIcon(), isOpen && enableSearch ? jsx("input", {
        ref: inputRef,
        type: "text",
        value: searchText,
        onChange: handleInputChange,
        onKeyDown: handleInputKeyDown,
        placeholder: getPlaceholderText(),
        style: getInputStyles(),
        disabled: disabled
      }) : jsx("div", {
        style: getTextStyles(),
        children: getDisplayText()
      }), jsx("div", {
        style: {
          width: '20px',
          height: '20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: getIconColor(),
          transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
          transition: 'transform 0.2s ease'
        },
        onClick: isOpen && enableSearch ? handleClick : undefined,
        children: getChevronIcon()
      })]
    }), shouldRender && !hideOption && jsx("div", {
      style: dropdownOptionsStyle,
      role: "listbox",
      ref: optionsContainerRef,
      children: filteredOptions.length === 0 ? jsx("div", {
        style: __assign(__assign({
          padding: '13px 16px'
        }, getTextStyle()), {
          color: colors.semantic.disabled.foreground,
          textAlign: 'center',
          userSelect: !enableSearch ? 'none' : 'auto'
        }),
        children: enableSearch && searchText.trim() ? '검색 결과가 없습니다' : '옵션이 없습니다'
      }) : filteredOptions.map(function (option, index) {
        var isSelected = value === option.value;
        return jsxs("div", {
          style: __assign(__assign({}, getOptionStyles(option, index, isSelected)), {
            userSelect: !enableSearch ? 'none' : 'auto'
          }),
          onClick: function () {
            return !option.disabled && handleOptionClick(option.value);
          },
          onMouseEnter: function () {
            return setHoveredOptionIndex(index);
          },
          onMouseLeave: function () {
            return setHoveredOptionIndex(null);
          },
          role: "option",
          "aria-selected": isSelected,
          "aria-disabled": option.disabled,
          children: [jsx("span", {
            children: option.label
          }), isSelected ? jsx("div", {
            style: {
              width: '20px',
              height: '20px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: '#7248D9'
            },
            children: getCheckIcon()
          }) : option.disabled ? jsx("div", {
            style: {
              width: '20px',
              height: '20px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: colors.semantic.disabled.foreground
            },
            children: getLockIcon()
          }) : null]
        }, option.value);
      })
    }), error && errorMessage && jsx("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: spacing.xxs,
        // 4px
        marginTop: spacing.xxs // 4px
      },
      children: jsx("span", {
        style: __assign(__assign({}, getTextStyle()), {
          color: colors.semantic.state.error
        }),
        children: errorMessage
      })
    })]
  });
};
Dropdown.displayName = 'Dropdown';

var TextArea = forwardRef(function (_a, ref) {
  var _b = _a.placeholder,
    placeholder = _b === void 0 ? 'Placeholder' : _b,
    value = _a.value,
    defaultValue = _a.defaultValue,
    onChange = _a.onChange,
    onFocus = _a.onFocus,
    onBlur = _a.onBlur,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    _d = _a.error,
    error = _d === void 0 ? false : _d,
    errorMessage = _a.errorMessage,
    _e = _a.className,
    className = _e === void 0 ? '' : _e,
    _f = _a.showCharacterCounter,
    showCharacterCounter = _f === void 0 ? false : _f,
    _g = _a.maxLength,
    maxLength = _g === void 0 ? 1000 : _g,
    status = _a.status,
    _h = _a.width,
    width = _h === void 0 ? '320px' : _h,
    _j = _a.rows,
    rows = _j === void 0 ? 4 : _j,
    restProps = __rest(_a, ["placeholder", "value", "defaultValue", "onChange", "onFocus", "onBlur", "disabled", "error", "errorMessage", "className", "showCharacterCounter", "maxLength", "status", "width", "rows"]);
  var _k = useState(false),
    isFocused = _k[0],
    setIsFocused = _k[1];
  var _l = useState(false),
    isHovered = _l[0],
    setIsHovered = _l[1];
  var _m = useState(defaultValue || ''),
    internalValue = _m[0],
    setInternalValue = _m[1];
  var currentValue = value !== undefined ? value : internalValue;
  var isEmpty = !currentValue || currentValue.length === 0;
  var actualStatus = status || (isEmpty ? 'empty' : 'filled');
  var characterCount = currentValue.length;
  var getContainerStyles = function () {
    var borderColor = colors.semantic.border.strong; // #D6D6D6
    var backgroundColor = colors.semantic.background.primary; // #FFFFFF
    if (disabled) {
      borderColor = colors.semantic.border.strong;
      backgroundColor = colors.semantic.disabled.background; // #F3F5F6
    } else if (error) {
      borderColor = colors.semantic.state.error; // #FF2E2E
    } else if (isFocused) {
      borderColor = colors.semantic.text.primary; // #25282D
    } else if (isHovered) {
      borderColor = colors.semantic.text.primary; // #25282D
    }
    var getWidth = function () {
      if (width === 'fill') {
        return '100%';
      }
      return typeof width === 'number' ? "".concat(width, "px") : width;
    };
    return {
      display: 'flex',
      flexDirection: 'column',
      width: getWidth(),
      border: "1px solid ".concat(borderColor),
      borderRadius: radius.s,
      // 8px
      backgroundColor: backgroundColor,
      transition: 'all 0.2s ease',
      position: 'relative'
    };
  };
  var getTextAreaStyles = function () {
    var textColor = colors.semantic.text.tertiary; // #8D97A5 for placeholder
    if (disabled) {
      textColor = colors.semantic.text.tertiary;
    } else if (error) {
      textColor = colors.semantic.state.error; // #FF2E2E
    } else if (actualStatus === 'filled') {
      textColor = colors.primary.coolGray[700]; // #393F46
    }
    return {
      width: '100%',
      minHeight: '160px',
      padding: "14px ".concat(spacing.m),
      // 14px 16px
      border: 'none',
      outline: 'none',
      backgroundColor: 'transparent',
      color: textColor,
      fontSize: '16px',
      fontWeight: 400,
      lineHeight: '24px',
      letterSpacing: '-2%',
      fontFamily: 'Pretendard',
      resize: 'none',
      wordWrap: 'break-word',
      whiteSpace: 'pre-wrap',
      overflowWrap: 'break-word',
      boxSizing: 'border-box'
    };
  };
  var handleFocus = function () {
    if (!disabled) {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    }
  };
  var handleBlur = function () {
    setIsFocused(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur();
  };
  var handleChange = function (e) {
    var newValue = e.target.value;
    // 최대 길이 체크
    if (maxLength && newValue.length > maxLength) {
      return;
    }
    if (value === undefined) {
      setInternalValue(newValue);
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
  };
  var handleMouseEnter = function () {
    if (!disabled && !isFocused) {
      setIsHovered(true);
    }
  };
  var handleMouseLeave = function () {
    setIsHovered(false);
  };
  return jsxs("div", {
    className: "text-area-wrapper ".concat(className),
    style: {
      width: width === 'fill' ? '100%' : width
    },
    children: [jsx("div", {
      style: getContainerStyles(),
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: jsx("textarea", __assign({
        ref: ref,
        value: currentValue,
        placeholder: placeholder,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        disabled: disabled,
        style: getTextAreaStyles(),
        rows: rows,
        maxLength: maxLength
      }, restProps))
    }), (showCharacterCounter || error) && jsxs("div", {
      style: {
        display: 'flex',
        justifyContent: error && errorMessage ? 'space-between' : 'flex-end',
        alignItems: 'center',
        marginTop: spacing.xxs,
        // 4px
        gap: spacing.s // 12px
      },
      children: [error && errorMessage && jsxs("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: spacing.xxs // 4px
        },
        children: [jsx(Icon, {
          type: "dialog",
          size: 16,
          color: colors.semantic.state.error
        }), jsx("span", {
          style: {
            fontSize: '14px',
            fontWeight: 400,
            lineHeight: '22px',
            color: colors.semantic.state.error,
            fontFamily: 'Pretendard'
          },
          children: errorMessage
        })]
      }), showCharacterCounter && jsxs("span", {
        style: {
          fontSize: '14px',
          fontWeight: 400,
          lineHeight: '22px',
          color: colors.semantic.text.tertiary,
          fontFamily: 'Pretendard',
          textAlign: 'right'
        },
        children: [characterCount, "/", maxLength]
      })]
    }), jsx("style", {
      children: "\n            @keyframes blink {\n              0%, 50% { opacity: 1; }\n              51%, 100% { opacity: 0; }\n            }\n            \n            .text-area-wrapper textarea::placeholder {\n              color: ".concat(colors.semantic.text.tertiary, ";\n            }\n          ")
    })]
  });
});
TextArea.displayName = 'TextArea';

var TextField = forwardRef(function (_a, ref) {
  var _b = _a.placeholder,
    placeholder = _b === void 0 ? 'Placeholder' : _b,
    value = _a.value,
    defaultValue = _a.defaultValue,
    onChange = _a.onChange,
    onFocus = _a.onFocus,
    onBlur = _a.onBlur,
    _c = _a.disabled,
    disabled = _c === void 0 ? false : _c,
    _d = _a.readOnly,
    readOnly = _d === void 0 ? false : _d,
    _e = _a.error,
    error = _e === void 0 ? false : _e,
    errorMessage = _a.errorMessage,
    _f = _a.className,
    className = _f === void 0 ? '' : _f,
    _g = _a.type,
    type = _g === void 0 ? 'text' : _g,
    leadingIcon = _a.leadingIcon,
    trailingIcon = _a.trailingIcon,
    leadingIconType = _a.leadingIconType,
    trailingIconType = _a.trailingIconType,
    onLeadingIconClick = _a.onLeadingIconClick,
    onTrailingIconClick = _a.onTrailingIconClick,
    status = _a.status,
    _h = _a.width,
    width = _h === void 0 ? '320px' : _h,
    restProps = __rest(_a, ["placeholder", "value", "defaultValue", "onChange", "onFocus", "onBlur", "disabled", "readOnly", "error", "errorMessage", "className", "type", "leadingIcon", "trailingIcon", "leadingIconType", "trailingIconType", "onLeadingIconClick", "onTrailingIconClick", "status", "width"]);
  var _j = useState(false),
    isFocused = _j[0],
    setIsFocused = _j[1];
  var _k = useState(false),
    isHovered = _k[0],
    setIsHovered = _k[1];
  var _l = useState(defaultValue || ''),
    internalValue = _l[0],
    setInternalValue = _l[1];
  var currentValue = value !== undefined ? value : internalValue;
  var isEmpty = !currentValue || currentValue.length === 0;
  var actualStatus = status || (isEmpty ? 'empty' : 'filled');
  var getContainerStyles = useCallback(function () {
    var borderColor = colors.semantic.border.strong; // #D6D6D6
    var backgroundColor = colors.semantic.background.primary; // #FFFFFF
    if (disabled) {
      borderColor = colors.semantic.border.strong;
      backgroundColor = colors.semantic.disabled.background; // #F3F5F6
    } else if (readOnly) {
      borderColor = colors.semantic.border.strong;
      backgroundColor = colors.semantic.background.primary;
    } else if (error) {
      borderColor = colors.semantic.state.error; // #FF2E2E
    } else if (isFocused) {
      borderColor = colors.semantic.text.primary; // #25282D
    } else if (isHovered) {
      borderColor = colors.semantic.text.primary; // #25282D
    }
    var getWidth = function () {
      if (width === 'fill') {
        return '100%';
      }
      return typeof width === 'number' ? "".concat(width, "px") : width;
    };
    return {
      display: 'flex',
      alignItems: 'center',
      gap: spacing.xs,
      // 8px
      padding: "13px ".concat(spacing.m),
      // 13px 16px
      backgroundColor: backgroundColor,
      border: "1px solid ".concat(borderColor),
      borderRadius: radius.s,
      // 8px
      transition: 'all 0.2s ease',
      width: getWidth()
    };
  }, [disabled, readOnly, error, isFocused, isHovered, width]);
  var getInputStyles = useCallback(function () {
    var textColor = colors.semantic.text.tertiary; // #8D97A5 for placeholder
    if (disabled) {
      textColor = colors.semantic.text.tertiary;
    } else if (error) {
      textColor = colors.semantic.state.error; // #FF2E2E
    } else if (actualStatus === 'filled') {
      textColor = colors.semantic.text.primary; // #25282D
    }
    // readOnly일 때 커서 스타일 변경
    var cursorStyle = readOnly ? 'default' : 'text';
    return __assign({
      flex: 1,
      border: 'none',
      outline: 'none',
      backgroundColor: 'transparent',
      color: textColor,
      cursor: cursorStyle
    }, textStyles.body1);
  }, [disabled, error, actualStatus, readOnly]);
  var getIconColor = useCallback(function () {
    if (disabled) {
      return colors.semantic.disabled.foreground; // #D1D5DB
    } else if (error) {
      return colors.semantic.state.error; // #FF2E2E
    } else {
      return colors.semantic.text.primary; // #25282D
    }
  }, [disabled, error]);
  var handleFocus = useCallback(function () {
    if (!disabled && !readOnly) {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    }
  }, [disabled, readOnly, onFocus]);
  var handleBlur = useCallback(function () {
    setIsFocused(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur();
  }, [onBlur]);
  var handleChange = useCallback(function (e) {
    if (readOnly) return; // readOnly일 때 값 변경 방지
    var newValue = e.target.value;
    if (value === undefined) {
      setInternalValue(newValue);
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
  }, [value, onChange, readOnly]);
  var handleMouseEnter = useCallback(function () {
    if (!disabled && !readOnly && !isFocused) {
      setIsHovered(true);
    }
  }, [disabled, readOnly, isFocused]);
  var handleMouseLeave = useCallback(function () {
    setIsHovered(false);
  }, []);
  var iconColor = getIconColor();
  // Leading 아이콘 렌더링
  var renderLeadingIcon = function () {
    if (leadingIconType) {
      return jsx(Icon, {
        type: leadingIconType,
        size: 20,
        color: iconColor,
        onClick: onLeadingIconClick
      });
    }
    if (leadingIcon) {
      return jsx("div", {
        style: {
          width: '20px',
          height: '20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: iconColor
        },
        children: leadingIcon
      });
    }
    return null;
  };
  // Trailing 아이콘 렌더링
  var renderTrailingIcon = function () {
    if (trailingIconType) {
      return jsx(Icon, {
        type: trailingIconType,
        size: 20,
        color: iconColor,
        onClick: onTrailingIconClick
      });
    }
    if (trailingIcon) {
      return jsx("div", {
        style: {
          width: '20px',
          height: '20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: iconColor
        },
        children: trailingIcon
      });
    }
    return null;
  };
  return jsxs("div", {
    className: "text-field-wrapper ".concat(className),
    style: {
      width: width === 'fill' ? '100%' : width
    },
    children: [jsxs("div", {
      style: getContainerStyles(),
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [renderLeadingIcon(), jsx("input", __assign({
        ref: ref,
        type: type,
        value: currentValue,
        placeholder: placeholder,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        disabled: disabled,
        readOnly: readOnly,
        style: getInputStyles()
      }, restProps)), renderTrailingIcon()]
    }), error && errorMessage && jsxs("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: spacing.xxs,
        // 4px
        marginTop: spacing.xs // 8px
      },
      children: [jsx(Icon, {
        type: "dialog",
        size: 16,
        color: colors.semantic.state.error
      }), jsx("span", {
        style: {
          fontSize: '12px',
          fontWeight: 500,
          lineHeight: '18px',
          color: colors.semantic.state.error,
          fontFamily: 'Pretendard'
        },
        children: errorMessage
      })]
    }), jsx("style", {
      children: "\n            .text-field-wrapper input::placeholder {\n              color: ".concat(colors.semantic.text.tertiary, ";\n            }\n          ")
    })]
  });
});
TextField.displayName = 'TextField';

var ExerciseCard = function (_a) {
  var title = _a.title,
    description = _a.description,
    _b = _a.type,
    type = _b === void 0 ? 'cardio' : _b,
    duration = _a.duration,
    calories = _a.calories,
    icon = _a.icon,
    _c = _a.isCompleted,
    isCompleted = _c === void 0 ? false : _c,
    _d = _a.isFavorite,
    isFavorite = _d === void 0 ? false : _d,
    _e = _a.width,
    width = _e === void 0 ? '300px' : _e,
    onClick = _a.onClick,
    onFavoriteToggle = _a.onFavoriteToggle,
    onCompleteToggle = _a.onCompleteToggle,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(false),
    isHovered = _g[0],
    setIsHovered = _g[1];
  // 운동 타입별 색상 및 아이콘
  var typeConfig = {
    cardio: {
      color: colors.primary.tint.blue[500],
      bgColor: colors.primary.tint.blue[50],
      icon: '🏃‍♂️',
      label: '유산소'
    },
    strength: {
      color: colors.primary.tint.red[500],
      bgColor: colors.primary.tint.red[50],
      icon: '💪',
      label: '근력'
    },
    stretching: {
      color: colors.primary.tint.green[500],
      bgColor: colors.primary.tint.green[50],
      icon: '🧘‍♀️',
      label: '스트레칭'
    },
    balance: {
      color: colors.primary.tint.violet[500],
      bgColor: colors.primary.tint.violet[50],
      icon: '⚖️',
      label: '밸런스'
    }
  };
  var currentTypeConfig = typeConfig[type];
  // width 동적 설정
  var getWidth = function () {
    if (width === 'fill') {
      return '100%';
    }
    return width;
  };
  var cardStyles = {
    display: 'flex',
    alignItems: 'center',
    padding: spacing.m,
    backgroundColor: isCompleted ? colors.primary.coolGray[50] : colors.semantic.background.primary,
    border: "1px solid ".concat(isHovered ? currentTypeConfig.color : colors.semantic.border.default),
    borderRadius: radius.m,
    boxShadow: isHovered ? shadows.m : shadows.s,
    cursor: 'pointer',
    transition: 'all 0.3s ease',
    transform: isHovered ? 'translateY(-2px)' : 'translateY(0)',
    opacity: isCompleted ? 0.7 : 1,
    position: 'relative',
    overflow: 'hidden',
    width: getWidth(),
    minWidth: '300px' // 최소 너비 설정
  };
  var handleCardClick = function (e) {
    e.stopPropagation();
    if (onClick) onClick();
  };
  var handleFavoriteClick = function (e) {
    e.stopPropagation();
    if (onFavoriteToggle) onFavoriteToggle();
  };
  var handleCompleteClick = function (e) {
    e.stopPropagation();
    if (onCompleteToggle) onCompleteToggle();
  };
  return jsxs("div", {
    className: "exercise-card ".concat(className),
    style: __assign({}, cardStyles),
    onClick: handleCardClick,
    onMouseEnter: function () {
      return setIsHovered(true);
    },
    onMouseLeave: function () {
      return setIsHovered(false);
    },
    children: [isCompleted && jsx("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '4px',
        height: '100%',
        backgroundColor: colors.semantic.state.success
      }
    }), jsx("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: '48px',
        height: '48px',
        backgroundColor: currentTypeConfig.bgColor,
        borderRadius: radius.s,
        marginRight: spacing.m,
        fontSize: '20px'
      },
      children: icon || currentTypeConfig.icon
    }), jsxs("div", {
      style: {
        flex: 1,
        minWidth: 0
      },
      children: [jsxs("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          marginBottom: spacing.xxs
        },
        children: [jsx("h3", {
          style: __assign(__assign({}, textStyles.heading4), {
            color: isCompleted ? colors.semantic.text.tertiary : colors.semantic.text.primary,
            margin: 0,
            textDecoration: isCompleted ? 'line-through' : 'none'
          }),
          children: title
        }), jsx("span", {
          style: __assign(__assign({}, textStyles.caption), {
            color: currentTypeConfig.color,
            backgroundColor: currentTypeConfig.bgColor,
            padding: "".concat(spacing.xxxs, " ").concat(spacing.xs),
            borderRadius: radius.xs,
            marginLeft: spacing.xs,
            fontSize: '10px',
            fontWeight: 500
          }),
          children: currentTypeConfig.label
        })]
      }), description && jsx("p", {
        style: __assign(__assign({}, textStyles.body3), {
          color: colors.semantic.text.secondary,
          margin: 0,
          marginBottom: spacing.xs,
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap'
        }),
        children: description
      }), jsxs("div", {
        style: {
          display: 'flex',
          gap: spacing.m,
          alignItems: 'center'
        },
        children: [duration && jsxs("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: spacing.xxs
          },
          children: [jsx("span", {
            style: {
              fontSize: '12px'
            },
            children: "\u23F1\uFE0F"
          }), jsxs("span", {
            style: __assign(__assign({}, textStyles.caption), {
              color: colors.semantic.text.tertiary
            }),
            children: [duration, "\uBD84"]
          })]
        }), calories && jsxs("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: spacing.xxs
          },
          children: [jsx("span", {
            style: {
              fontSize: '12px'
            },
            children: "\uD83D\uDD25"
          }), jsxs("span", {
            style: __assign(__assign({}, textStyles.caption), {
              color: colors.semantic.text.tertiary
            }),
            children: [calories, "kcal"]
          })]
        })]
      })]
    }), jsxs("div", {
      style: {
        display: 'flex',
        gap: spacing.xs,
        alignItems: 'center'
      },
      children: [jsx("button", {
        onClick: handleFavoriteClick,
        style: {
          background: 'none',
          border: 'none',
          cursor: 'pointer',
          fontSize: '16px',
          padding: spacing.xxs,
          borderRadius: radius.xs,
          transition: 'all 0.2s ease',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        },
        title: isFavorite ? '즐겨찾기 해제' : '즐겨찾기 추가',
        children: isFavorite ? '⭐' : '☆'
      }), jsx("button", {
        onClick: handleCompleteClick,
        style: {
          background: 'none',
          border: "1px solid ".concat(isCompleted ? colors.semantic.state.success : colors.semantic.border.default),
          cursor: 'pointer',
          padding: spacing.xs,
          borderRadius: radius.xs,
          transition: 'all 0.2s ease',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: isCompleted ? colors.semantic.state.success : 'transparent'
        },
        title: isCompleted ? '완료 취소' : '완료 표시',
        children: jsx("span", {
          style: {
            fontSize: '12px',
            color: isCompleted ? colors.semantic.background.primary : colors.semantic.text.tertiary
          },
          children: isCompleted ? '✓' : '○'
        })
      })]
    })]
  });
};

var ActivityGoalCard = function (_a) {
  var title = _a.title,
    description = _a.description,
    currentValue = _a.currentValue,
    goalValue = _a.goalValue,
    unit = _a.unit,
    _b = _a.theme,
    theme = _b === void 0 ? 'primary' : _b,
    icon = _a.icon,
    onClick = _a.onClick,
    _c = _a.className,
    className = _c === void 0 ? '' : _c;
  // 진행률 계산
  var progressPercentage = Math.min(currentValue / goalValue * 100, 100);
  var isCompleted = progressPercentage >= 100;
  // 테마별 색상 설정
  var themeConfig = {
    primary: {
      color: colors.primary.mainviolet,
      bgColor: colors.primary.tint.violet[50],
      lightColor: colors.primary.tint.violet[100]
    },
    success: {
      color: colors.semantic.state.success,
      bgColor: colors.primary.tint.green[50],
      lightColor: colors.primary.tint.green[100]
    },
    warning: {
      color: colors.semantic.state.warning,
      bgColor: colors.primary.tint.yellow[50],
      lightColor: colors.primary.tint.yellow[100]
    },
    info: {
      color: colors.semantic.state.info,
      bgColor: colors.primary.tint.blue[50],
      lightColor: colors.primary.tint.blue[100]
    }
  };
  var currentTheme = themeConfig[theme];
  var cardStyles = {
    padding: spacing.l,
    backgroundColor: currentTheme.bgColor,
    border: "1px solid ".concat(currentTheme.lightColor),
    borderRadius: radius.l,
    boxShadow: shadows.s,
    cursor: onClick ? 'pointer' : 'default',
    transition: 'all 0.3s ease',
    position: 'relative',
    overflow: 'hidden'
  };
  var progressBarStyles = {
    width: '100%',
    height: '8px',
    backgroundColor: colors.semantic.background.secondary,
    borderRadius: radius.xs,
    overflow: 'hidden',
    position: 'relative'
  };
  var progressFillStyles = {
    height: '100%',
    backgroundColor: currentTheme.color,
    borderRadius: radius.xs,
    width: "".concat(progressPercentage, "%"),
    transition: 'width 0.5s ease',
    position: 'relative'
  };
  return jsxs("div", {
    className: "activity-goal-card ".concat(className, " ").concat(isCompleted ? 'completed' : ''),
    style: cardStyles,
    onClick: onClick,
    children: [isCompleted && jsx("div", {
      style: {
        position: 'absolute',
        top: spacing.s,
        right: spacing.s,
        fontSize: '20px',
        animation: 'bounce 0.6s ease-in-out'
      },
      children: "\uD83C\uDF89"
    }), jsxs("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        marginBottom: spacing.m
      },
      children: [icon && jsx("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          width: '40px',
          height: '40px',
          backgroundColor: currentTheme.color,
          color: colors.semantic.background.primary,
          borderRadius: radius.s,
          marginRight: spacing.s,
          fontSize: '18px'
        },
        children: icon
      }), jsxs("div", {
        style: {
          flex: 1
        },
        children: [jsx("h3", {
          style: __assign(__assign({}, textStyles.heading3), {
            color: colors.semantic.text.primary,
            margin: 0,
            marginBottom: spacing.xxxs
          }),
          children: title
        }), description && jsx("p", {
          style: __assign(__assign({}, textStyles.body3), {
            color: colors.semantic.text.secondary,
            margin: 0
          }),
          children: description
        })]
      })]
    }), jsx("div", {
      style: {
        marginBottom: spacing.s
      },
      children: jsxs("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'baseline'
        },
        children: [jsxs("div", {
          style: {
            display: 'flex',
            alignItems: 'baseline',
            gap: spacing.xxxs
          },
          children: [jsx("span", {
            style: __assign(__assign({}, textStyles.display2), {
              color: currentTheme.color,
              fontWeight: 700
            }),
            children: currentValue.toLocaleString()
          }), jsx("span", {
            style: __assign(__assign({}, textStyles.body2), {
              color: colors.semantic.text.secondary
            }),
            children: unit
          })]
        }), jsxs("span", {
          style: __assign(__assign({}, textStyles.body3), {
            color: colors.semantic.text.tertiary
          }),
          children: ["\uBAA9\uD45C: ", goalValue.toLocaleString(), unit]
        })]
      })
    }), jsx("div", {
      style: progressBarStyles,
      children: jsx("div", {
        style: progressFillStyles,
        children: jsx("div", {
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '50%',
            background: 'linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%)',
            borderRadius: "".concat(radius.xs, " ").concat(radius.xs, " 0 0")
          }
        })
      })
    }), jsx("div", {
      style: {
        marginTop: spacing.s,
        textAlign: 'center'
      },
      children: jsx("span", {
        style: __assign(__assign({}, textStyles.caption), {
          color: isCompleted ? currentTheme.color : colors.semantic.text.tertiary,
          fontWeight: isCompleted ? 600 : 400
        }),
        children: isCompleted ? '목표 달성! 🎯' : "".concat(progressPercentage.toFixed(1), "% \uB2EC\uC131")
      })
    }), jsx("div", {
      style: {
        position: 'absolute',
        top: 0,
        right: 0,
        width: '100px',
        height: '100px',
        background: "radial-gradient(circle, ".concat(currentTheme.lightColor, " 1px, transparent 1px)"),
        backgroundSize: '12px 12px',
        opacity: 0.3,
        pointerEvents: 'none'
      }
    })]
  });
};

var GreetingHeader = function (_a) {
  var _b = _a.userName,
    userName = _b === void 0 ? '익명' : _b,
    customGreeting = _a.customGreeting,
    _c = _a.showDate,
    showDate = _c === void 0 ? true : _c,
    weather = _a.weather,
    onClick = _a.onClick,
    _d = _a.className,
    className = _d === void 0 ? '' : _d;
  var _e = useState(new Date()),
    currentTime = _e[0],
    setCurrentTime = _e[1];
  useEffect(function () {
    var timer = setInterval(function () {
      setCurrentTime(new Date());
    }, 60000); // 1분마다 업데이트
    return function () {
      return clearInterval(timer);
    };
  }, []);
  // 시간대별 인사말 생성
  var getTimeBasedGreeting = function () {
    var hour = currentTime.getHours();
    if (hour >= 5 && hour < 12) {
      return {
        greeting: '좋은 아침이에요!',
        emoji: '🌅',
        bgGradient: 'linear-gradient(135deg, #FFE5B4 0%, #FFD700 100%)',
        textColor: colors.primary.gray[800]
      };
    } else if (hour >= 12 && hour < 18) {
      return {
        greeting: '활기찬 오후네요!',
        emoji: '☀️',
        bgGradient: 'linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%)',
        textColor: colors.semantic.background.primary
      };
    } else if (hour >= 18 && hour < 22) {
      return {
        greeting: '좋은 저녁이에요!',
        emoji: '🌇',
        bgGradient: 'linear-gradient(135deg, #FF9A56 0%, #FF6B35 100%)',
        textColor: colors.semantic.background.primary
      };
    } else {
      return {
        greeting: '늦은 시간이네요!',
        emoji: '🌙',
        bgGradient: 'linear-gradient(135deg, #2C3E50 0%, #4A6741 100%)',
        textColor: colors.semantic.background.primary
      };
    }
  };
  // 날씨 아이콘 및 정보
  var getWeatherInfo = function () {
    if (!weather || !weather.condition) return null;
    var weatherIcons = {
      sunny: '☀️',
      cloudy: '☁️',
      rainy: '🌧️',
      snowy: '❄️'
    };
    return {
      icon: weatherIcons[weather.condition] || '🌤️',
      temp: weather.temperature
    };
  };
  var timeGreeting = getTimeBasedGreeting();
  var weatherInfo = getWeatherInfo();
  var displayGreeting = customGreeting || timeGreeting.greeting;
  // 요일 및 날짜 포맷팅
  var formatDate = function () {
    var days = ['일', '월', '화', '수', '목', '금', '토'];
    var month = currentTime.getMonth() + 1;
    var date = currentTime.getDate();
    var day = days[currentTime.getDay()];
    return "".concat(month, "\uC6D4 ").concat(date, "\uC77C (").concat(day, ")");
  };
  var headerStyles = {
    background: timeGreeting.bgGradient,
    padding: spacing.l,
    borderRadius: radius.l,
    position: 'relative',
    overflow: 'hidden',
    cursor: onClick ? 'pointer' : 'default',
    transition: 'all 0.3s ease',
    minHeight: '120px',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center'
  };
  return jsxs("div", {
    className: "greeting-header ".concat(className),
    style: headerStyles,
    onClick: onClick,
    children: [jsx("div", {
      style: {
        position: 'absolute',
        top: 0,
        right: 0,
        width: '150px',
        height: '150px',
        background: "radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px)",
        backgroundSize: '15px 15px',
        opacity: 0.6,
        pointerEvents: 'none'
      }
    }), jsxs("div", {
      style: {
        position: 'relative',
        zIndex: 1
      },
      children: [jsxs("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          marginBottom: spacing.s
        },
        children: [jsx("span", {
          style: {
            fontSize: '32px',
            marginRight: spacing.s
          },
          children: timeGreeting.emoji
        }), jsxs("div", {
          children: [jsx("h1", {
            style: __assign(__assign({}, textStyles.display1), {
              color: timeGreeting.textColor,
              margin: 0,
              marginBottom: spacing.xxxs,
              textShadow: '0px 1px 2px rgba(0,0,0,0.1)'
            }),
            children: displayGreeting
          }), jsxs("p", {
            style: __assign(__assign({}, textStyles.heading3), {
              color: timeGreeting.textColor,
              margin: 0,
              opacity: 0.9
            }),
            children: [userName, "\uB2D8 \uD83D\uDCAA"]
          })]
        })]
      }), jsxs("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginTop: spacing.m
        },
        children: [showDate && jsxs("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: spacing.xs
          },
          children: [jsx("span", {
            style: {
              fontSize: '16px'
            },
            children: "\uD83D\uDCC5"
          }), jsx("span", {
            style: __assign(__assign({}, textStyles.body2), {
              color: timeGreeting.textColor,
              opacity: 0.8
            }),
            children: formatDate()
          })]
        }), weatherInfo && jsxs("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: spacing.xs
          },
          children: [jsx("span", {
            style: {
              fontSize: '16px'
            },
            children: weatherInfo.icon
          }), weatherInfo.temp && jsxs("span", {
            style: __assign(__assign({}, textStyles.body2), {
              color: timeGreeting.textColor,
              opacity: 0.8
            }),
            children: [weatherInfo.temp, "\u00B0C"]
          })]
        })]
      })]
    }), jsx("div", {
      style: {
        position: 'absolute',
        bottom: spacing.s,
        right: spacing.m,
        opacity: 0.7
      },
      children: jsx("span", {
        style: __assign(__assign({}, textStyles.caption), {
          color: timeGreeting.textColor,
          fontStyle: 'italic'
        }),
        children: getMotivationalMessage()
      })
    })]
  });
};
// 동기부여 메시지 생성 함수
var getMotivationalMessage = function () {
  var messages = ['오늘도 화이팅! 💪', '한 걸음씩 나아가요 🚶‍♂️', '건강한 하루 되세요! 🌟', '당신은 할 수 있어요! ✨', '작은 변화, 큰 성장 🌱', '꾸준함이 답입니다 ⭐', '건강이 최고의 투자예요 💎'];
  return messages[Math.floor(Math.random() * messages.length)];
};

var ExerciseList = function (_a) {
  var exercises = _a.exercises,
    _b = _a.emptyMessage,
    emptyMessage = _b === void 0 ? '등록된 운동이 없습니다.' : _b,
    _c = _a.emptyIcon,
    emptyIcon = _c === void 0 ? '🏃‍♂️' : _c,
    _d = _a.showFilters,
    showFilters = _d === void 0 ? true : _d,
    _e = _a.showSearch,
    showSearch = _e === void 0 ? true : _e,
    onExerciseClick = _a.onExerciseClick,
    onFavoriteToggle = _a.onFavoriteToggle,
    onCompleteToggle = _a.onCompleteToggle,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var _g = useState(''),
    searchQuery = _g[0],
    setSearchQuery = _g[1];
  var _h = useState('all'),
    filterType = _h[0],
    setFilterType = _h[1];
  var _j = useState('name'),
    sortBy = _j[0],
    setSortBy = _j[1];
  var _k = useState(true),
    showCompleted = _k[0],
    setShowCompleted = _k[1];
  // 필터링 및 정렬된 운동 목록
  var filteredAndSortedExercises = useMemo(function () {
    var filtered = exercises;
    // 검색 필터
    if (searchQuery.trim()) {
      filtered = filtered.filter(function (exercise) {
        return exercise.title.toLowerCase().includes(searchQuery.toLowerCase()) || exercise.description && exercise.description.toLowerCase().includes(searchQuery.toLowerCase());
      });
    }
    // 타입 필터
    if (filterType !== 'all') {
      filtered = filtered.filter(function (exercise) {
        return exercise.type === filterType;
      });
    }
    // 완료 상태 필터
    if (!showCompleted) {
      filtered = filtered.filter(function (exercise) {
        return !exercise.isCompleted;
      });
    }
    // 정렬
    filtered.sort(function (a, b) {
      switch (sortBy) {
        case 'name':
          return a.title.localeCompare(b.title);
        case 'duration':
          return (b.duration || 0) - (a.duration || 0);
        case 'calories':
          return (b.calories || 0) - (a.calories || 0);
        case 'type':
          return (a.type || '').localeCompare(b.type || '');
        default:
          return 0;
      }
    });
    return filtered;
  }, [exercises, searchQuery, filterType, sortBy, showCompleted]);
  // 통계 정보
  var stats = useMemo(function () {
    var completed = exercises.filter(function (ex) {
      return ex.isCompleted;
    }).length;
    var total = exercises.length;
    var totalDuration = exercises.reduce(function (sum, ex) {
      return sum + (ex.duration || 0);
    }, 0);
    var totalCalories = exercises.reduce(function (sum, ex) {
      return sum + (ex.calories || 0);
    }, 0);
    return {
      completed: completed,
      total: total,
      completionRate: total > 0 ? Math.round(completed / total * 100) : 0,
      totalDuration: totalDuration,
      totalCalories: totalCalories
    };
  }, [exercises]);
  var filterOptions = [{
    value: 'all',
    label: '전체',
    icon: '🏃‍♂️'
  }, {
    value: 'cardio',
    label: '유산소',
    icon: '🏃‍♂️'
  }, {
    value: 'strength',
    label: '근력',
    icon: '💪'
  }, {
    value: 'stretching',
    label: '스트레칭',
    icon: '🧘‍♀️'
  }, {
    value: 'balance',
    label: '밸런스',
    icon: '⚖️'
  }];
  var sortOptions = [{
    value: 'name',
    label: '이름순'
  }, {
    value: 'duration',
    label: '시간순'
  }, {
    value: 'calories',
    label: '칼로리순'
  }, {
    value: 'type',
    label: '타입순'
  }];
  return jsxs("div", {
    className: "exercise-list ".concat(className),
    children: [jsxs("div", {
      style: {
        marginBottom: spacing.l
      },
      children: [jsxs("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: spacing.m,
          padding: spacing.m,
          backgroundColor: colors.primary.coolGray[50],
          borderRadius: radius.s,
          border: "1px solid ".concat(colors.semantic.border.default)
        },
        children: [jsxs("div", {
          children: [jsx("h2", {
            style: __assign(__assign({}, textStyles.heading2), {
              color: colors.semantic.text.primary,
              margin: 0,
              marginBottom: spacing.xxxs
            }),
            children: "\uB4F1\uB85D\uB41C \uC6B4\uB3D9 \uBAA9\uB85D"
          }), jsxs("p", {
            style: __assign(__assign({}, textStyles.body3), {
              color: colors.semantic.text.secondary,
              margin: 0
            }),
            children: ["\uCD1D ", stats.total, "\uAC1C \u2022 \uC644\uB8CC\uC728 ", stats.completionRate, "%"]
          })]
        }), jsxs("div", {
          style: {
            display: 'flex',
            gap: spacing.s,
            alignItems: 'center',
            fontSize: '12px'
          },
          children: [stats.totalDuration > 0 && jsx("div", {
            style: {
              textAlign: 'center',
              color: colors.semantic.text.tertiary
            },
            children: jsxs("div", {
              children: ["\u23F1\uFE0F ", stats.totalDuration, "\uBD84"]
            })
          }), stats.totalCalories > 0 && jsx("div", {
            style: {
              textAlign: 'center',
              color: colors.semantic.text.tertiary
            },
            children: jsxs("div", {
              children: ["\uD83D\uDD25 ", stats.totalCalories, "kcal"]
            })
          })]
        })]
      }), (showSearch || showFilters) && jsxs("div", {
        style: {
          marginBottom: spacing.m
        },
        children: [showSearch && jsx("div", {
          style: {
            marginBottom: spacing.s
          },
          children: jsx("input", {
            type: "text",
            placeholder: "\uC6B4\uB3D9 \uAC80\uC0C9...",
            value: searchQuery,
            onChange: function (e) {
              return setSearchQuery(e.target.value);
            },
            style: {
              width: '100%',
              padding: "".concat(spacing.s, " ").concat(spacing.m),
              border: "1px solid ".concat(colors.semantic.border.default),
              borderRadius: radius.s,
              fontSize: '14px',
              backgroundColor: colors.semantic.background.primary,
              color: colors.semantic.text.primary,
              outline: 'none',
              transition: 'border-color 0.2s ease'
            },
            onFocus: function (e) {
              e.target.style.borderColor = colors.primary.mainviolet;
            },
            onBlur: function (e) {
              e.target.style.borderColor = colors.semantic.border.default;
            }
          })
        }), showFilters && jsxs("div", {
          style: {
            display: 'flex',
            gap: spacing.s,
            flexWrap: 'wrap',
            alignItems: 'center'
          },
          children: [jsx("div", {
            style: {
              display: 'flex',
              gap: spacing.xxs
            },
            children: filterOptions.map(function (option) {
              return jsxs("button", {
                onClick: function () {
                  return setFilterType(option.value);
                },
                style: {
                  padding: "".concat(spacing.xs, " ").concat(spacing.s),
                  border: "1px solid ".concat(filterType === option.value ? colors.primary.mainviolet : colors.semantic.border.default),
                  borderRadius: radius.xs,
                  backgroundColor: filterType === option.value ? colors.primary.mainviolet : colors.semantic.background.primary,
                  color: filterType === option.value ? colors.semantic.background.primary : colors.semantic.text.primary,
                  cursor: 'pointer',
                  fontSize: '12px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: spacing.xxxs,
                  transition: 'all 0.2s ease'
                },
                children: [jsx("span", {
                  children: option.icon
                }), option.label]
              }, option.value);
            })
          }), jsx("select", {
            value: sortBy,
            onChange: function (e) {
              return setSortBy(e.target.value);
            },
            style: {
              padding: "".concat(spacing.xs, " ").concat(spacing.s),
              border: "1px solid ".concat(colors.semantic.border.default),
              borderRadius: radius.xs,
              backgroundColor: colors.semantic.background.primary,
              color: colors.semantic.text.primary,
              fontSize: '12px',
              cursor: 'pointer'
            },
            children: sortOptions.map(function (option) {
              return jsx("option", {
                value: option.value,
                children: option.label
              }, option.value);
            })
          }), jsxs("label", {
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: spacing.xs,
              cursor: 'pointer',
              fontSize: '12px',
              color: colors.semantic.text.secondary
            },
            children: [jsx("input", {
              type: "checkbox",
              checked: showCompleted,
              onChange: function (e) {
                return setShowCompleted(e.target.checked);
              },
              style: {
                cursor: 'pointer'
              }
            }), "\uC644\uB8CC\uB41C \uC6B4\uB3D9 \uD45C\uC2DC"]
          })]
        })]
      })]
    }), filteredAndSortedExercises.length > 0 ? jsx("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: spacing.s
      },
      children: filteredAndSortedExercises.map(function (exercise) {
        return jsx(ExerciseCard, __assign({}, exercise, {
          width: "fill",
          onClick: function () {
            return onExerciseClick === null || onExerciseClick === void 0 ? void 0 : onExerciseClick(exercise);
          },
          onFavoriteToggle: function () {
            return onFavoriteToggle === null || onFavoriteToggle === void 0 ? void 0 : onFavoriteToggle(exercise.id);
          },
          onCompleteToggle: function () {
            return onCompleteToggle === null || onCompleteToggle === void 0 ? void 0 : onCompleteToggle(exercise.id);
          }
        }), exercise.id);
      })
    }) : (/* 빈 상태 */
    jsxs("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: "".concat(spacing.xxxl, " ").concat(spacing.l),
        textAlign: 'center',
        color: colors.semantic.text.tertiary
      },
      children: [jsx("div", {
        style: {
          fontSize: '48px',
          marginBottom: spacing.m
        },
        children: emptyIcon
      }), jsx("h3", {
        style: __assign(__assign({}, textStyles.heading3), {
          color: colors.semantic.text.secondary,
          margin: 0,
          marginBottom: spacing.xs
        }),
        children: emptyMessage
      }), jsx("p", {
        style: __assign(__assign({}, textStyles.body3), {
          color: colors.semantic.text.tertiary,
          margin: 0,
          maxWidth: '300px'
        }),
        children: searchQuery || filterType !== 'all' ? '검색 조건을 변경해보세요.' : '새로운 운동을 추가해보세요!'
      })]
    }))]
  });
};

// 시간 변환 유틸리티 함수들
var formatTime = function (totalValue, baseUnit) {
  var totalSeconds;
  // baseUnit에 따라 초로 변환
  if (baseUnit === 'min') {
    totalSeconds = totalValue * 60;
  } else if (baseUnit === 'hour') {
    totalSeconds = totalValue * 3600;
  } else {
    totalSeconds = totalValue;
  }
  // baseUnit에 따라 최소 표시 단위 결정
  if (baseUnit === 'hour') {
    // 시간 단위: 최소 시간으로 표시
    var hours_1 = totalSeconds / 3600;
    if (hours_1 === Math.floor(hours_1)) {
      return "".concat(Math.floor(hours_1), "\uC2DC\uAC04");
    }
    var wholeHours = Math.floor(hours_1);
    var remainingMinutes = Math.round((hours_1 - wholeHours) * 60);
    if (wholeHours === 0) {
      return "".concat(remainingMinutes, "\uBD84");
    }
    if (remainingMinutes === 0) {
      return "".concat(wholeHours, "\uC2DC\uAC04");
    }
    return "".concat(wholeHours, "\uC2DC\uAC04 ").concat(remainingMinutes, "\uBD84");
  }
  if (baseUnit === 'min') {
    // 분 단위: 최소 분으로 표시 (초는 표시하지 않음)
    var totalMinutes = Math.round(totalSeconds / 60);
    if (totalMinutes < 60) {
      return "".concat(totalMinutes, "\uBD84");
    }
    var hours_2 = Math.floor(totalMinutes / 60);
    var minutes_1 = totalMinutes % 60;
    if (minutes_1 === 0) {
      return "".concat(hours_2, "\uC2DC\uAC04");
    }
    return "".concat(hours_2, "\uC2DC\uAC04 ").concat(minutes_1, "\uBD84");
  }
  // 초 단위: 초, 분, 시간 모두 표시
  if (totalSeconds < 60) {
    return "".concat(totalSeconds, "\uCD08");
  }
  if (totalSeconds < 3600) {
    var minutes_2 = Math.floor(totalSeconds / 60);
    var seconds_1 = totalSeconds % 60;
    if (seconds_1 === 0) {
      return "".concat(minutes_2, "\uBD84");
    }
    return "".concat(minutes_2, "\uBD84 ").concat(seconds_1, "\uCD08");
  }
  var hours = Math.floor(totalSeconds / 3600);
  var remainingSeconds = totalSeconds % 3600;
  var minutes = Math.floor(remainingSeconds / 60);
  var seconds = remainingSeconds % 60;
  var result = "".concat(hours, "\uC2DC\uAC04");
  if (minutes > 0) {
    result += " ".concat(minutes, "\uBD84");
  }
  if (seconds > 0) {
    result += " ".concat(seconds, "\uCD08");
  }
  return result;
};
var parseTimeString = function (timeStr, baseUnit) {
  // 빈 문자열이면 0 반환
  if (!timeStr.trim()) {
    return 0;
  }
  // "1시간 30분 45초" or "90분 30초" or "45초" 형태의 문자열을 파싱
  var hourMatch = timeStr.match(/(\d+)시간/);
  var minuteMatch = timeStr.match(/(\d+)분/);
  var secondMatch = timeStr.match(/(\d+)초/);
  var totalSeconds = 0;
  var hasValidInput = false;
  if (hourMatch) {
    var hours = parseInt(hourMatch[1]);
    if (!isNaN(hours)) {
      totalSeconds += hours * 3600;
      hasValidInput = true;
    }
  }
  if (minuteMatch) {
    var minutes = parseInt(minuteMatch[1]);
    if (!isNaN(minutes)) {
      totalSeconds += minutes * 60;
      hasValidInput = true;
    }
  }
  if (secondMatch && baseUnit === 'sec') {
    // 초는 baseUnit이 'sec'일 때만 처리
    var seconds = parseInt(secondMatch[1]);
    if (!isNaN(seconds)) {
      totalSeconds += seconds;
      hasValidInput = true;
    }
  }
  // 순수 숫자만 입력된 경우 (단위 없음)
  if (!hasValidInput) {
    var numericValue = parseInt(timeStr.trim());
    if (!isNaN(numericValue)) {
      totalSeconds = numericValue;
      // baseUnit에 따라 초로 변환
      if (baseUnit === 'min') {
        totalSeconds = numericValue * 60;
      } else if (baseUnit === 'hour') {
        totalSeconds = numericValue * 3600;
      }
      hasValidInput = true;
    }
  }
  // 유효한 입력이 없으면 에러 던지기
  if (!hasValidInput) {
    throw new Error('Invalid time format');
  }
  // baseUnit에 따라 원래 단위로 변환
  if (baseUnit === 'min') {
    return totalSeconds / 60;
  } else if (baseUnit === 'hour') {
    return totalSeconds / 3600;
  }
  return totalSeconds;
};
var Stepper = function (_a) {
  var _b = _a.value,
    value = _b === void 0 ? 0 : _b,
    _c = _a.min,
    min = _c === void 0 ? 0 : _c,
    _d = _a.max,
    max = _d === void 0 ? 100 : _d,
    onChange = _a.onChange,
    _e = _a.disabled,
    disabled = _e === void 0 ? false : _e,
    _f = _a.width,
    width = _f === void 0 ? '335px' : _f,
    _g = _a.error,
    error = _g === void 0 ? false : _g,
    errorMessage = _a.errorMessage,
    _h = _a.focused,
    focused = _h === void 0 ? false : _h,
    _j = _a.editable,
    editable = _j === void 0 ? false : _j,
    _k = _a.className,
    className = _k === void 0 ? '' : _k,
    _l = _a.style,
    style = _l === void 0 ? {} : _l,
    _m = _a.unit,
    unit = _m === void 0 ? '' : _m,
    _o = _a.step,
    step = _o === void 0 ? 1 : _o,
    _p = _a.isTime,
    isTime = _p === void 0 ? false : _p,
    _q = _a.timeBaseUnit,
    timeBaseUnit = _q === void 0 ? 'min' : _q,
    _r = _a.autoRound,
    autoRound = _r === void 0 ? false : _r;
  // value가 string인지 체크
  var isStringValue = typeof value === 'string';
  // string이면 자동으로 disabled 처리
  var isDisabled = disabled || isStringValue;
  // 숫자 값만 관리 (string일 때는 0으로 초기화하되 실제로는 사용하지 않음)
  var numericValue = typeof value === 'number' ? value : 0;
  var _s = useState(numericValue),
    internalValue = _s[0],
    setInternalValue = _s[1];
  var _t = useState(focused),
    isFocused = _t[0],
    setIsFocused = _t[1];
  var _u = useState(false),
    isEditing = _u[0],
    setIsEditing = _u[1];
  var _v = useState(String(numericValue)),
    editValue = _v[0],
    setEditValue = _v[1];
  var _w = useState(function () {
      // 초기 stepCount 계산 - value를 step으로 나눈 값의 반올림
      return step > 0 ? Math.round(numericValue / step) : 0;
    });
    _w[0];
    var setStepCount = _w[1];
  var inputRef = useRef(null);
  // value prop이 변경될 때 internalValue 동기화 (숫자일 때만)
  useEffect(function () {
    if (typeof value === 'number') {
      setInternalValue(value);
    }
  }, [value]);
  // value prop을 기반으로 currentValue 계산 (외부에서 제어되는 경우와 내부에서 제어되는 경우 구분)
  var currentValue = useMemo(function () {
    return typeof value === 'number' ? internalValue : 0;
  }, [internalValue, value]);
  // stepCount 기반으로 실제 값 계산
  var getActualValue = function (count) {
    var stepValue = count * step;
    return Math.max(min, Math.min(max, stepValue));
  };
  // min/max 도달 상태를 useMemo로 계산
  var _x = useMemo(function () {
      return {
        isMinReached: currentValue <= min,
        isMaxReached: currentValue >= max
      };
    }, [currentValue, min, max]),
    isMinReached = _x.isMinReached,
    isMaxReached = _x.isMaxReached;
  useEffect(function () {
    if (!isEditing) {
      if (isTime) {
        setEditValue(formatTime(currentValue, timeBaseUnit));
      } else {
        setEditValue(String(currentValue));
      }
    }
  }, [currentValue, isEditing, isTime, timeBaseUnit]);
  // value prop이 변경될 때 stepCount 동기화
  useEffect(function () {
    var newStepCount = step > 0 ? Math.round(currentValue / step) : 0;
    setStepCount(newStepCount);
  }, [currentValue, step]);
  var handleIncrement = function () {
    if (isDisabled || isMaxReached) return;
    var newValue;
    var isExactStepValue = currentValue % step === 0;
    if (isExactStepValue) {
      // 정확한 step 배수라면 step만큼 증가
      newValue = currentValue + step;
    } else {
      // step 배수가 아니라면 다음 step 배수로 올림
      newValue = Math.ceil(currentValue / step) * step;
    }
    // min/max 범위 체크
    newValue = Math.max(min, Math.min(max, newValue));
    // stepCount 업데이트
    var newStepCount = step > 0 ? Math.round(newValue / step) : 0;
    setStepCount(newStepCount);
    onChange && onChange(newValue);
    setInternalValue(newValue);
  };
  var handleDecrement = function () {
    if (isDisabled || isMinReached) return;
    var newValue;
    var isExactStepValue = currentValue % step === 0;
    if (isExactStepValue) {
      // 정확한 step 배수라면 step만큼 감소
      newValue = currentValue - step;
    } else {
      // step 배수가 아니라면 이전 step 배수로 내림
      newValue = Math.floor(currentValue / step) * step;
    }
    // min/max 범위 체크
    newValue = Math.max(min, Math.min(max, newValue));
    // stepCount 업데이트
    var newStepCount = step > 0 ? Math.round(newValue / step) : 0;
    setStepCount(newStepCount);
    onChange && onChange(newValue);
    setInternalValue(newValue);
  };
  var handleValueClick = function () {
    if (editable && !isDisabled && !error && !isStringValue) {
      setIsEditing(true);
      setIsFocused(true);
      if (isTime) {
        setEditValue(formatTime(currentValue, timeBaseUnit));
      } else {
        setEditValue(String(currentValue));
      }
      setTimeout(function () {
        var _a, _b;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        (_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.select();
      }, 0);
    }
  };
  var handleInputChange = function (e) {
    var inputValue = e.target.value;
    if (isTime) {
      // 시간 형식 입력 허용 (숫자, 시간, 분, 초, 공백)
      // 순수 숫자만 입력하는 경우도 허용 (나중에 baseUnit에 따라 해석)
      if (inputValue === '' || /^[\d시간분초\s]*$/.test(inputValue)) {
        setEditValue(inputValue);
      }
    } else {
      // 숫자와 마이너스 기호만 허용
      if (inputValue === '' || /^-?\d*$/.test(inputValue)) {
        setEditValue(inputValue);
      }
    }
  };
  var handleInputBlur = function () {
    setIsEditing(false);
    setIsFocused(false);
    var newValue;
    if (isTime) {
      // 시간 문자열을 숫자로 변환
      try {
        newValue = parseTimeString(editValue, timeBaseUnit);
      } catch (error) {
        // 파싱 실패시 현재 값 유지
        setEditValue(formatTime(currentValue, timeBaseUnit));
        return;
      }
    } else {
      newValue = parseInt(editValue, 10);
      // 빈 값이거나 유효하지 않은 값인 경우 현재 값 유지
      if (editValue === '' || isNaN(newValue)) {
        setEditValue(String(currentValue));
        return;
      }
    }
    // min, max 범위 체크 먼저
    if (newValue < min) {
      newValue = min;
    } else if (newValue > max) {
      newValue = max;
    }
    // step 단위로 반올림 (isTime이거나 autoRound가 true일 때만)
    if ((isTime || autoRound) && step && step > 0) {
      var roundedStepCount = Math.round(newValue / step);
      newValue = getActualValue(roundedStepCount);
      setStepCount(roundedStepCount);
    } else {
      // autoRound가 false인 경우에도 stepCount 업데이트
      var newStepCount = step > 0 ? Math.round(newValue / step) : 0;
      setStepCount(newStepCount);
    }
    if (isTime) {
      setEditValue(formatTime(newValue, timeBaseUnit));
    } else {
      setEditValue(String(newValue));
    }
    onChange && onChange(newValue);
    setInternalValue(newValue);
  };
  var handleInputKeyDown = function (e) {
    if (e.key === 'Enter') {
      handleInputBlur();
    } else if (e.key === 'Escape') {
      setIsEditing(false);
      setIsFocused(false);
      if (isTime) {
        setEditValue(formatTime(currentValue, timeBaseUnit));
      } else {
        setEditValue(String(currentValue));
      }
    }
  };
  // 표시할 값 계산
  var displayValue = useMemo(function () {
    // string 값이면 그대로 표시
    if (isStringValue) {
      return String(value);
    }
    if (isTime) {
      return formatTime(currentValue, timeBaseUnit);
    } else if (unit) {
      return "".concat(currentValue).concat(unit);
    }
    return String(currentValue);
  }, [currentValue, isTime, timeBaseUnit, unit, isStringValue, value]);
  // 스타일 계산
  var containerStyle = __assign({
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: error && errorMessage ? '6px' : '16px',
    width: width === 'fill' ? '100%' : width,
    userSelect: 'none'
  }, style);
  var stepperStyle = {
    display: 'flex',
    alignItems: 'center',
    gap: '15px',
    padding: '12px 16px',
    borderRadius: '8px',
    border: "1px solid ".concat(error ? colors.semantic.state.error : isFocused ? colors.primary.coolGray[800] : colors.primary.coolGray[300]),
    backgroundColor: isDisabled ? colors.primary.coolGray[50] : colors.primary.gray.white,
    width: '100%',
    boxSizing: 'border-box',
    transition: 'all 0.2s ease',
    position: 'relative',
    userSelect: 'none'
  };
  var valueContainerStyle = {
    flex: 1,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    cursor: editable && !isDisabled && !error && !isStringValue ? 'text' : 'default',
    userSelect: 'none'
  };
  var inputStyle = __assign(__assign({}, textStyles.heading3), {
    background: 'transparent',
    border: 'none',
    outline: 'none',
    fontWeight: fontWeight.semibold,
    textAlign: 'center',
    color: colors.primary.coolGray[800],
    width: '100%',
    padding: 0,
    margin: 0,
    userSelect: 'none'
  });
  return jsxs("div", {
    className: "stepper ".concat(className),
    style: containerStyle,
    children: [jsxs("div", {
      style: stepperStyle,
      children: [jsx(Icon, {
        type: "minus-circle-filled",
        size: 24,
        color: isDisabled || isMinReached ? colors.primary.coolGray[400] : colors.primary.coolGray[800],
        onClick: handleDecrement,
        style: {
          cursor: isDisabled || isMinReached ? 'not-allowed' : 'pointer',
          opacity: isDisabled || isMinReached ? 0.5 : 1,
          userSelect: 'none'
        }
      }), jsx("div", {
        style: valueContainerStyle,
        onClick: handleValueClick,
        children: isEditing ? jsx("input", {
          ref: inputRef,
          type: "text",
          value: editValue,
          onChange: handleInputChange,
          onBlur: handleInputBlur,
          onKeyDown: handleInputKeyDown,
          style: inputStyle
        }) : jsx(Font, {
          type: "heading3",
          fontWeight: "semibold",
          color: isDisabled ? colors.primary.coolGray[400] : error ? colors.semantic.state.error : colors.primary.coolGray[800],
          align: "center",
          style: {
            userSelect: 'none'
          },
          children: displayValue
        })
      }), jsx(Icon, {
        type: "add-circle-filled",
        size: 24,
        color: isDisabled || isMaxReached ? colors.primary.coolGray[400] : colors.primary.coolGray[800],
        onClick: handleIncrement,
        style: {
          cursor: isDisabled || isMaxReached ? 'not-allowed' : 'pointer',
          opacity: isDisabled || isMaxReached ? 0.5 : 1,
          userSelect: 'none'
        }
      })]
    }), error && errorMessage && jsx("div", {
      style: {
        paddingLeft: '16px',
        width: '100%',
        boxSizing: 'border-box',
        userSelect: 'none'
      },
      children: jsx(Font, {
        type: "body2",
        fontWeight: "medium",
        color: colors.semantic.state.error,
        align: "left",
        style: {
          userSelect: 'none'
        },
        children: errorMessage
      })
    })]
  });
};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
freeGlobal || freeSelf || Function('return this')();

var useSyncExternalStoreShim_production = {};

/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_production;

function requireUseSyncExternalStoreShim_production () {
	if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
	hasRequiredUseSyncExternalStoreShim_production = 1;
	var React$1 = React;
	function is(x, y) {
	  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is,
	  useState = React$1.useState,
	  useEffect = React$1.useEffect,
	  useLayoutEffect = React$1.useLayoutEffect,
	  useDebugValue = React$1.useDebugValue;
	function useSyncExternalStore$2(subscribe, getSnapshot) {
	  var value = getSnapshot(),
	    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),
	    inst = _useState[0].inst,
	    forceUpdate = _useState[1];
	  useLayoutEffect(
	    function () {
	      inst.value = value;
	      inst.getSnapshot = getSnapshot;
	      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	    },
	    [subscribe, value, getSnapshot]
	  );
	  useEffect(
	    function () {
	      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	      return subscribe(function () {
	        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	      });
	    },
	    [subscribe]
	  );
	  useDebugValue(value);
	  return value;
	}
	function checkIfSnapshotChanged(inst) {
	  var latestGetSnapshot = inst.getSnapshot;
	  inst = inst.value;
	  try {
	    var nextValue = latestGetSnapshot();
	    return !objectIs(inst, nextValue);
	  } catch (error) {
	    return !0;
	  }
	}
	function useSyncExternalStore$1(subscribe, getSnapshot) {
	  return getSnapshot();
	}
	var shim =
	  "undefined" === typeof window ||
	  "undefined" === typeof window.document ||
	  "undefined" === typeof window.document.createElement
	    ? useSyncExternalStore$1
	    : useSyncExternalStore$2;
	useSyncExternalStoreShim_production.useSyncExternalStore =
	  void 0 !== React$1.useSyncExternalStore ? React$1.useSyncExternalStore : shim;
	return useSyncExternalStoreShim_production;
}

var useSyncExternalStoreShim_development = {};

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_development;

function requireUseSyncExternalStoreShim_development () {
	if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
	hasRequiredUseSyncExternalStoreShim_development = 1;
	"production" !== process.env.NODE_ENV &&
	  (function () {
	    function is(x, y) {
	      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
	    }
	    function useSyncExternalStore$2(subscribe, getSnapshot) {
	      didWarnOld18Alpha ||
	        void 0 === React$1.startTransition ||
	        ((didWarnOld18Alpha = !0),
	        console.error(
	          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
	        ));
	      var value = getSnapshot();
	      if (!didWarnUncachedGetSnapshot) {
	        var cachedValue = getSnapshot();
	        objectIs(value, cachedValue) ||
	          (console.error(
	            "The result of getSnapshot should be cached to avoid an infinite loop"
	          ),
	          (didWarnUncachedGetSnapshot = !0));
	      }
	      cachedValue = useState({
	        inst: { value: value, getSnapshot: getSnapshot }
	      });
	      var inst = cachedValue[0].inst,
	        forceUpdate = cachedValue[1];
	      useLayoutEffect(
	        function () {
	          inst.value = value;
	          inst.getSnapshot = getSnapshot;
	          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	        },
	        [subscribe, value, getSnapshot]
	      );
	      useEffect(
	        function () {
	          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	          return subscribe(function () {
	            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	          });
	        },
	        [subscribe]
	      );
	      useDebugValue(value);
	      return value;
	    }
	    function checkIfSnapshotChanged(inst) {
	      var latestGetSnapshot = inst.getSnapshot;
	      inst = inst.value;
	      try {
	        var nextValue = latestGetSnapshot();
	        return !objectIs(inst, nextValue);
	      } catch (error) {
	        return !0;
	      }
	    }
	    function useSyncExternalStore$1(subscribe, getSnapshot) {
	      return getSnapshot();
	    }
	    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
	      "function" ===
	        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
	    var React$1 = React,
	      objectIs = "function" === typeof Object.is ? Object.is : is,
	      useState = React$1.useState,
	      useEffect = React$1.useEffect,
	      useLayoutEffect = React$1.useLayoutEffect,
	      useDebugValue = React$1.useDebugValue,
	      didWarnOld18Alpha = !1,
	      didWarnUncachedGetSnapshot = !1,
	      shim =
	        "undefined" === typeof window ||
	        "undefined" === typeof window.document ||
	        "undefined" === typeof window.document.createElement
	          ? useSyncExternalStore$1
	          : useSyncExternalStore$2;
	    useSyncExternalStoreShim_development.useSyncExternalStore =
	      void 0 !== React$1.useSyncExternalStore ? React$1.useSyncExternalStore : shim;
	    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
	      "function" ===
	        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	  })();
	return useSyncExternalStoreShim_development;
}

if (process.env.NODE_ENV === 'production') {
  requireUseSyncExternalStoreShim_production();
} else {
  requireUseSyncExternalStoreShim_development();
}

var raf$1 = {exports: {}};

var performanceNow = {exports: {}};

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    performanceNow.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    performanceNow.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);



var performanceNowExports = performanceNow.exports;

var now = performanceNowExports
  , root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

raf$1.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
raf$1.exports.cancel = function() {
  caf.apply(root, arguments);
};
raf$1.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

// src/hooks/useOnLongHover.ts

// src/hooks/warning.ts
process.env.NODE_ENV !== "production";
function useEffectOnceWhen(callback, when = true) {
  const hasRunOnceRef = useRef(false);
  const callbackRef = useRef(callback);
  useEffect(() => {
    callbackRef.current = callback;
  });
  useEffect(() => {
    if (when && !hasRunOnceRef.current) {
      callbackRef.current();
      hasRunOnceRef.current = true;
    }
  }, [when]);
}

var assets = [
];
var ddd = 0;
var fr = 30;
var h = 300;
var ip = 0;
var layers = [
	{
		ddd: 0,
		ind: 1,
		ty: 4,
		nm: "Group 1",
		hd: false,
		sr: 1,
		ks: {
			a: {
				a: 0,
				k: [
					0,
					0
				]
			},
			o: {
				a: 0,
				k: 100
			},
			p: {
				a: 0,
				k: [
					150,
					150
				]
			},
			r: {
				a: 0,
				k: 0
			},
			s: {
				a: 0,
				k: [
					100,
					100
				]
			},
			sk: {
				a: 0,
				k: 0
			},
			sa: {
				a: 0,
				k: 0
			}
		},
		ao: 0,
		ip: 0,
		op: 42,
		st: 0,
		bm: 0,
		shapes: [
			{
				ty: "gr",
				hd: false,
				nm: "Shape Layer 2 Group",
				bm: 0,
				it: [
					{
						ty: "gr",
						hd: false,
						nm: "Ellipse Path 1 Group",
						bm: 0,
						it: [
							{
								ty: "el",
								hd: false,
								nm: "Ellipse Path 1",
								p: {
									a: 0,
									k: [
										125,
										125
									]
								},
								s: {
									a: 0,
									k: [
										250,
										250
									]
								},
								d: 1
							},
							{
								ty: "st",
								hd: false,
								bm: 0,
								c: {
									a: 0,
									k: [
										0.447,
										0.282,
										0.851
									]
								},
								lc: 2,
								lj: 1,
								ml: 4,
								o: {
									a: 0,
									k: 100
								},
								w: {
									a: 0,
									k: 30
								}
							},
							{
								ty: "tr",
								nm: "Transform",
								a: {
									a: 0,
									k: [
										125,
										125
									]
								},
								o: {
									a: 0,
									k: 100
								},
								p: {
									a: 0,
									k: [
										0,
										0
									]
								},
								r: {
									a: 0,
									k: 0
								},
								s: {
									a: 0,
									k: [
										100,
										100
									]
								},
								sk: {
									a: 0,
									k: 0
								},
								sa: {
									a: 0,
									k: 0
								}
							}
						],
						np: 0
					},
					{
						ty: "tm",
						hd: false,
						bm: 0,
						e: {
							a: 1,
							k: [
								{
									t: 0,
									s: [
										0.1
									],
									i: {
										x: 0.667,
										y: 1
									},
									o: {
										x: 0.333,
										y: 0
									}
								},
								{
									t: 20.1,
									s: [
										100
									],
									i: {
										x: 0,
										y: 0
									},
									o: {
										x: 1,
										y: 1
									}
								}
							]
						},
						o: {
							a: 0,
							k: 0
						},
						s: {
							a: 1,
							k: [
								{
									t: 0,
									s: [
										0
									],
									i: {
										x: 0.75,
										y: 0.75
									},
									o: {
										x: 0.25,
										y: 0.25
									}
								},
								{
									t: 20.1,
									s: [
										0
									],
									i: {
										x: 0.667,
										y: 1
									},
									o: {
										x: 0.333,
										y: 0
									}
								},
								{
									t: 39.9,
									s: [
										99.99
									],
									i: {
										x: 0,
										y: 0
									},
									o: {
										x: 1,
										y: 1
									}
								}
							]
						},
						m: 1
					},
					{
						ty: "tr",
						nm: "Transform",
						a: {
							a: 0,
							k: [
								0,
								0
							]
						},
						o: {
							a: 0,
							k: 100
						},
						p: {
							a: 0,
							k: [
								0,
								0
							]
						},
						r: {
							a: 0,
							k: 0
						},
						s: {
							a: 0,
							k: [
								100,
								100
							]
						},
						sk: {
							a: 0,
							k: 0
						},
						sa: {
							a: 0,
							k: 0
						}
					}
				],
				np: 0
			},
			{
				ty: "gr",
				hd: false,
				nm: "Shape Layer 3 Group",
				bm: 0,
				it: [
					{
						ty: "gr",
						hd: false,
						nm: "Ellipse Path 1 Group",
						bm: 0,
						it: [
							{
								ty: "el",
								hd: false,
								nm: "Ellipse Path 1",
								p: {
									a: 0,
									k: [
										125,
										125
									]
								},
								s: {
									a: 0,
									k: [
										250,
										250
									]
								},
								d: 1
							},
							{
								ty: "st",
								hd: false,
								bm: 0,
								c: {
									a: 0,
									k: [
										1,
										1,
										1
									]
								},
								lc: 2,
								lj: 1,
								ml: 4,
								o: {
									a: 0,
									k: 0
								},
								w: {
									a: 0,
									k: 30
								}
							},
							{
								ty: "tr",
								nm: "Transform",
								a: {
									a: 0,
									k: [
										125,
										125
									]
								},
								o: {
									a: 0,
									k: 100
								},
								p: {
									a: 0,
									k: [
										0,
										0
									]
								},
								r: {
									a: 0,
									k: 0
								},
								s: {
									a: 0,
									k: [
										100,
										100
									]
								},
								sk: {
									a: 0,
									k: 0
								},
								sa: {
									a: 0,
									k: 0
								}
							}
						],
						np: 0
					},
					{
						ty: "tr",
						nm: "Transform",
						a: {
							a: 0,
							k: [
								0,
								0
							]
						},
						o: {
							a: 0,
							k: 100
						},
						p: {
							a: 0,
							k: [
								0,
								0
							]
						},
						r: {
							a: 0,
							k: 0
						},
						s: {
							a: 0,
							k: [
								100,
								100
							]
						},
						sk: {
							a: 0,
							k: 0
						},
						sa: {
							a: 0,
							k: 0
						}
					}
				],
				np: 0
			}
		]
	}
];
var meta = {
	g: "@phase-software/lottie-exporter 0.7.0"
};
var nm = "";
var op = 41;
var v = "5.6.0";
var w = 300;
var loadingSpinnerData = {
	assets: assets,
	ddd: ddd,
	fr: fr,
	h: h,
	ip: ip,
	layers: layers,
	meta: meta,
	nm: nm,
	op: op,
	v: v,
	w: w
};

var Table = function (_a) {
  var data = _a.data,
    columns = _a.columns,
    rowAccordion = _a.rowAccordion,
    _b = _a.type,
    type = _b === void 0 ? 'parent' : _b,
    isLoading = _a.isLoading,
    emptyIcon = _a.emptyIcon,
    _c = _a.emptyIconSize,
    emptyIconSize = _c === void 0 ? 32 : _c,
    _d = _a.emptyIconColor,
    emptyIconColor = _d === void 0 ? colors.primary.coolGray[300] : _d,
    emptyText = _a.emptyText;
  // 각 열의 최대 너비를 저장하는 상태
  var _e = useState({}),
    columnLayouts = _e[0],
    setColumnLayouts = _e[1];
  // 너비 계산이 완료되었는지 추적하는 상태
  var _f = useState(false),
    isWidthCalculationComplete = _f[0],
    setIsWidthCalculationComplete = _f[1];
  // 헤더 셀의 참조를 저장할 배열
  var headerRefs = useRef([]);
  // 열 너비를 업데이트하는 함수
  var updateColumnWidth = function (index, width) {
    setColumnLayouts(function (prevLayouts) {
      var _a;
      var currentWidth = prevLayouts[index] || 0;
      if (width > currentWidth) {
        return __assign(__assign({}, prevLayouts), (_a = {}, _a[index] = width, _a));
      }
      return prevLayouts;
    });
  };
  var formattedColumns = useMemo(function () {
    if (type === 'child') return columns;
    return __spreadArray([], columns, true);
  }, [columns]);
  // 컴포넌트 마운트 시 헤더 셀의 너비를 측정하여 초기화
  useLayoutEffect(function () {
    formattedColumns.forEach(function (column, index) {
      var headerEl = headerRefs.current[index];
      if (headerEl) {
        var width = Math.ceil(headerEl.getBoundingClientRect().width);
        updateColumnWidth(index, width);
      }
    });
  }, [formattedColumns, data]);
  // 모든 컬럼의 너비 계산이 완료되었는지 확인
  useEffect(function () {
    if (data.length > 0 && formattedColumns.length > 0) {
      // 모든 컬럼에 너비가 설정되었는지 확인
      var allColumnsHaveWidth = formattedColumns.every(function (_, index) {
        return columnLayouts[index] > 0;
      });
      if (allColumnsHaveWidth && !isWidthCalculationComplete) {
        // 약간의 지연을 주어 모든 셀의 너비 계산이 완료되도록 함
        setTimeout(function () {
          setIsWidthCalculationComplete(true);
        }, 100);
      }
    }
  }, [columnLayouts, data.length, formattedColumns.length, isWidthCalculationComplete]);
  // 데이터나 컬럼이 변경되면 계산 완료 상태 리셋
  useEffect(function () {
    setIsWidthCalculationComplete(false);
  }, [data, columns]);
  // 창 크기 변경 시 열 너비를 재측정하도록 초기화
  useEffect(function () {
    var handleResize = function () {
      setIsWidthCalculationComplete(false);
      formattedColumns.forEach(function (column, index) {
        var headerEl = headerRefs.current[index];
        if (headerEl) {
          var width = Math.ceil(headerEl.getBoundingClientRect().width);
          updateColumnWidth(index, width);
        }
      });
    };
    window.addEventListener('resize', handleResize);
    return function () {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  if (isLoading) {
    return jsx("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: 100
      },
      children: jsx(YouthLottie, {
        animationData: loadingSpinnerData,
        style: {
          width: 48,
          aspectRatio: 1
        },
        loop: true
      })
    });
  }
  return jsxs("div", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      flex: 1
    },
    children: [jsx("div", {
      style: {
        display: 'flex'
      },
      children: formattedColumns.map(function (column, index) {
        return jsx("div", {
          ref: function (el) {
            headerRefs.current[index] = el;
          },
          style: __assign(__assign(__assign({
            display: 'flex',
            alignItems: 'center',
            borderBottom: '1px solid #eee',
            backgroundColor: type === 'parent' ? colors.primary.coolGray[50] : 'transparent',
            whiteSpace: 'nowrap',
            padding: '8px 12px',
            width: columnLayouts[index] ? "".concat(columnLayouts[index], "px") : 'auto',
            boxSizing: 'border-box',
            overflow: 'visible',
            height: 48
          }, data.length === 0 && {
            flex: 1,
            minWidth: 0,
            width: 'auto'
          }), isWidthCalculationComplete && data.length > 0 && __assign(__assign({}, type === 'parent' ? index === formattedColumns.length - 2 && {
            flex: 1,
            minWidth: 0,
            width: 'auto'
          } : index === formattedColumns.length - 1 && {
            flex: 2,
            minWidth: 0,
            width: 'auto'
          }), type === 'child' && index !== formattedColumns.length - 1 && {
            flex: 1,
            width: 'auto'
          })), column.style),
          children: jsx(Font, __assign({}, type === 'parent' && {
            hide: index === 0 || column.header === 'empty'
          }, {
            type: "body2",
            fontWeight: "medium",
            color: type === 'parent' ? colors.primary.coolGray[800] : colors.primary.coolGray[500],
            noWhiteSpace: true,
            children: column.header
          }))
        }, "header-".concat(index));
      })
    }), jsx("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        flexWrap: 'nowrap'
      },
      children: data.length === 0 ? jsxs("div", {
        style: {
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          width: '100%',
          height: 200,
          gap: 10
        },
        children: [emptyIcon && jsx(Icon, {
          type: emptyIcon,
          size: emptyIconSize,
          color: emptyIconColor
        }), emptyText && jsx(Font, {
          type: "body2",
          fontWeight: "medium",
          color: colors.primary.coolGray[300],
          children: emptyText
        })]
      }) : data.map(function (rowData, rowIndex) {
        return jsx(Row, {
          data: rowData,
          columns: formattedColumns,
          updateColumnWidth: updateColumnWidth,
          columnLayouts: columnLayouts,
          isWidthCalculationComplete: isWidthCalculationComplete,
          rowAccordion: rowAccordion,
          tableType: type
        }, "row-".concat(rowIndex));
      })
    })]
  });
};
var Row = function (_a) {
  var data = _a.data,
    columns = _a.columns,
    updateColumnWidth = _a.updateColumnWidth,
    columnLayouts = _a.columnLayouts,
    isWidthCalculationComplete = _a.isWidthCalculationComplete,
    rowAccordion = _a.rowAccordion,
    tableType = _a.tableType;
  var _b = useState(false),
    isRowAccordionOpen = _b[0],
    setIsRowAccordionOpen = _b[1];
  var rowDetailRef = useRef(null);
  var _c = useState('auto'),
    rowDetailHeight = _c[0],
    setRowDetailHeight = _c[1];
  var onPressRow = function () {
    // @ts-ignore
    if (data.status === '미등록') return;
    setIsRowAccordionOpen(function (prev) {
      return !prev;
    });
  };
  useEffectOnceWhen(function () {
    setIsRowAccordionOpen(true);
    // @ts-ignore
  }, data.status === '등록 완료');
  useEffect(function () {
    if (rowAccordion && data && rowDetailRef.current) {
      var calculatedHeight = rowDetailRef.current.scrollHeight; // 자식 요소의 실제 높이 계산
      setRowDetailHeight(calculatedHeight);
    }
  }, [rowAccordion, data]); // 자식 요소가 변경될 때마다 높이 계산
  return jsxs("div", {
    children: [jsx("div", {
      onClick: onPressRow,
      style: {
        display: 'flex'
      },
      children: columns.map(function (column, index) {
        return jsx(Cell, {
          cell: column.cell(data),
          updateColumnWidth: updateColumnWidth,
          columnIndex: index,
          columnWidth: columnLayouts[index],
          columnLength: columns.length,
          isRowAccordionOpen: isRowAccordionOpen,
          tableType: tableType,
          style: column.style,
          isWidthCalculationComplete: isWidthCalculationComplete,
          hasRowAccordion: !!rowAccordion
        }, "cell-".concat(index));
      })
    }), jsx("div", {
      ref: rowDetailRef,
      style: {
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        height: isRowAccordionOpen ? rowDetailHeight : 0,
        transition: 'height 330ms ease-in-out',
        overflow: 'hidden'
      },
      children: rowAccordion && rowAccordion(data)
    })]
  });
};
var Cell = memo(function (_a) {
  var cell = _a.cell,
    updateColumnWidth = _a.updateColumnWidth,
    columnIndex = _a.columnIndex,
    columnWidth = _a.columnWidth,
    columnLength = _a.columnLength,
    isRowAccordionOpen = _a.isRowAccordionOpen,
    tableType = _a.tableType,
    style = _a.style,
    isWidthCalculationComplete = _a.isWidthCalculationComplete,
    hasRowAccordion = _a.hasRowAccordion;
  var cellRef = useRef(null);
  useLayoutEffect(function () {
    if (cellRef.current) {
      var width = cellRef.current.getBoundingClientRect().width;
      var ceilWidth = Math.ceil(width);
      if (ceilWidth > (columnWidth || 0)) {
        updateColumnWidth(columnIndex, ceilWidth);
      }
    }
  }, [cell, updateColumnWidth, columnIndex, columnWidth]);
  var handleClick = function (e) {
    if (columnIndex === columnLength - 1) {
      e.stopPropagation();
    }
  };
  return jsx("div", {
    ref: cellRef,
    onClick: handleClick,
    style: __assign(__assign({
      display: 'flex',
      borderBottom: tableType === 'parent' ? '1px solid #eee' : 'none',
      padding: tableType === 'parent' && columnIndex === columnLength - 1 ? '16px 12px' : '8px 12px',
      whiteSpace: 'nowrap',
      boxSizing: 'border-box',
      minWidth: columnIndex === 1 ? 84 : columnWidth ? "".concat(columnWidth, "px") : '0',
      width: columnWidth ? "".concat(columnWidth, "px") : 'auto',
      overflow: 'visible'
    }, isWidthCalculationComplete && __assign(__assign({}, tableType === 'parent' ? columnIndex === columnLength - 2 && {
      flex: 1,
      minWidth: 0
    } : columnIndex === columnLength - 1 && {
      flex: 2,
      minWidth: 0
    }), tableType === 'child' && columnIndex !== columnLength - 1 && {
      flex: 1
    })), style),
    children: columnIndex === 0 ? jsx("div", {
      style: __assign({
        display: 'flex'
      }, columnIndex === 0 && hasRowAccordion && {
        transition: 'transform 0.3s ease',
        transform: isRowAccordionOpen && tableType === 'parent' ? 'rotate(180deg)' : 'rotate(0deg)'
      }),
      children: cell
    }) : jsx("div", {
      style: {
        display: 'flex'
      },
      children: cell
    })
  });
});

// 타입별 설정
var typeConfig = {
  normal: {
    iconType: 'info-filled',
    iconColor: colors.primary.tint.blue[400],
    backgroundColor: colors.primary.coolGray[50],
    textColor: colors.primary.coolGray[800]
  },
  success: {
    iconType: 'check-circle-filled',
    iconColor: colors.primary.gray.white,
    backgroundColor: colors.primary.tint.green[500],
    textColor: colors.primary.gray.white
  },
  warning: {
    iconType: 'info-filled',
    iconColor: colors.primary.tint.red[400],
    backgroundColor: colors.primary.tint.red[50],
    textColor: colors.primary.tint.red[500]
  }
};
// 사이즈별 설정
var sizeConfig = {
  s: {
    padding: '8px 12px',
    iconSize: 20,
    textStyle: textStyles.body2,
    fontWeight: fontWeight.regular,
    gap: '8px'
  },
  m: {
    padding: '12px 16px',
    iconSize: 24,
    textStyle: textStyles.body2,
    fontWeight: fontWeight.medium,
    gap: '12px'
  }
};
/**
 * 인라인 알림 컴포넌트
 *
 * 페이지 내에서 사용자에게 중요한 정보나 상태를 알려주는 컴포넌트입니다.
 * 피그마 디자인에 따라 크기(s, m)와 타입(normal, success, warning)을 지원합니다.
 */
var InlineNotification = React.memo(function (_a) {
  var type = _a.type,
    message = _a.message,
    _b = _a.size,
    size = _b === void 0 ? 'm' : _b,
    _c = _a.isButton,
    isButton = _c === void 0 ? false : _c,
    onClick = _a.onClick,
    _d = _a.borderRadius,
    borderRadius = _d === void 0 ? false : _d,
    textStyle = _a.textStyle,
    customFontWeight = _a.fontWeight,
    _e = _a.width,
    width = _e === void 0 ? '480px' : _e,
    _f = _a.className,
    className = _f === void 0 ? '' : _f;
  var typeConf = typeConfig[type];
  var sizeConf = sizeConfig[size];
  var handleClick = useCallback(function () {
    if (isButton && onClick) {
      onClick();
    }
  }, [isButton, onClick]);
  var notificationStyle = {
    display: 'flex',
    alignItems: 'center',
    gap: sizeConf.gap,
    padding: sizeConf.padding,
    backgroundColor: typeConf.backgroundColor,
    borderRadius: borderRadius ? '8px' : 0,
    width: width === 'fill' ? '100%' : width,
    flex: width === 'fill' ? 1 : undefined,
    minHeight: 'fit-content',
    cursor: isButton ? 'pointer' : 'default',
    transition: isButton ? 'background-color 0.2s ease' : 'none'
  };
  var contentStyle = __assign(__assign({}, textStyle || sizeConf.textStyle), {
    fontWeight: customFontWeight || sizeConf.fontWeight,
    color: typeConf.textColor,
    margin: 0,
    flex: 1,
    display: 'flex',
    alignItems: 'center'
  });
  return jsxs("div", {
    className: "inline-notification inline-notification--".concat(type, " inline-notification--").concat(size, " ").concat(className),
    style: notificationStyle,
    role: isButton ? 'button' : 'alert',
    "aria-live": isButton ? undefined : 'polite',
    onClick: isButton ? handleClick : undefined,
    children: [jsx("div", {
      className: "inline-notification__icon",
      style: {
        display: 'flex',
        alignItems: 'center'
      },
      children: jsx(Icon, {
        type: typeConf.iconType,
        size: sizeConf.iconSize,
        color: typeConf.iconColor
      })
    }), jsx("div", {
      className: "inline-notification__content",
      style: contentStyle,
      children: message
    }), isButton && jsx("div", {
      className: "inline-notification__arrow",
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      children: jsx(Icon, {
        type: "chevron-right",
        size: sizeConf.iconSize,
        color: typeConf.textColor
      })
    })]
  });
});
InlineNotification.displayName = 'InlineNotification';

export { ActivityGoalCard, Button, Checkbox, Chips, Dropdown, ExerciseCard, ExerciseList, Font, GreetingHeader, Icon, Illust, InlineNotification, Label, Modal, Popup, Radio, Stepper, Tab, TabBar, Table, TextArea, TextButton, TextField, TextInput, Toast, ToastProvider, Toggle, YouthLottie, borders, colors, coolGray, fontFamily, fontSize, fontWeight, gray, illustration, letterSpacing, lineHeight, primary, radius, semantic, shadows, spacing, textStyles, tint, tokens, typography, useToast };
//# sourceMappingURL=index.esm.js.map
